/* 
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/

-- src/lib.rs:27
-- bootstrap
DO LANGUAGE plpgsql $$
    DECLARE
        session_preload_libraries text;
    BEGIN
        session_preload_libraries = COALESCE (current_setting('session_preload_libraries'), '');
        IF (session_preload_libraries NOT LIKE '%zombodb.so%') THEN
            IF (session_preload_libraries = '') THEN
                session_preload_libraries = '"zombodb.so"';
            ELSE
                session_preload_libraries = format('"zombodb.so",%s', session_preload_libraries);
            END IF;

            EXECUTE format('ALTER DATABASE %I SET session_preload_libraries TO %s', current_database(), session_preload_libraries);
        END IF;

    END;
$$;

-- it's imperative for `update-versions.sh` that this function be formatted exactly this way
CREATE FUNCTION zdb.schema_version() RETURNS text LANGUAGE sql AS $$
SELECT '3000.2.7 (fb94ddb4bc206056ebcbd566d8bcc7df86c65932)'
$$;

CREATE SCHEMA dsl;

GRANT ALL ON SCHEMA zdb TO PUBLIC;
GRANT ALL ON SCHEMA dsl TO PUBLIC;


-- src/access_method/triggers.rs:9
-- zombodb::access_method::triggers::zdb_update_trigger

        CREATE OR REPLACE FUNCTION zdb.zdb_update_trigger() RETURNS trigger LANGUAGE c AS 'MODULE_PATHNAME', 'zdb_update_trigger_wrapper';
    



-- src/access_method/triggers.rs:61
-- zombodb::access_method::triggers::zdb_delete_trigger

    CREATE OR REPLACE FUNCTION zdb.zdb_delete_trigger() RETURNS trigger LANGUAGE c AS 'MODULE_PATHNAME', 'zdb_delete_trigger_wrapper';
    



-- src/elasticsearch/aggregates/builders/metrics.rs:728
-- zombodb::elasticsearch::aggregates::builders::metrics::weighted_avg_agg
CREATE  FUNCTION zdb."weighted_avg_agg"(
	"aggregate_name" TEXT, /* &str */
	"field_value" TEXT, /* &str */
	"field_weight" TEXT, /* &str */
	"value_missing" bigint, /* i64 */
	"weight_missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'weighted_avg_missings_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:706
-- zombodb::elasticsearch::aggregates::builders::metrics::weighted_avg_agg
CREATE  FUNCTION zdb."weighted_avg_agg"(
	"aggregate_name" TEXT, /* &str */
	"field_value" TEXT, /* &str */
	"field_weight" TEXT, /* &str */
	"value_missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'weighted_avg_missing_value_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:690
-- zombodb::elasticsearch::aggregates::builders::metrics::weighted_avg_agg
CREATE  FUNCTION zdb."weighted_avg_agg"(
	"aggregate_name" TEXT, /* &str */
	"field_value" TEXT, /* &str */
	"field_weight" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'weighted_avg_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:366
-- zombodb::elasticsearch::aggregates::builders::metrics::value_count_agg
CREATE  FUNCTION zdb."value_count_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'value_count_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:773
-- zombodb::elasticsearch::aggregates::builders::metrics::top_metrics_agg
CREATE  FUNCTION zdb."top_metrics_agg"(
	"aggregate_name" TEXT, /* &str */
	"metric_field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'top_metric_score_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:789
-- zombodb::elasticsearch::aggregates::builders::metrics::top_metrics_agg
CREATE  FUNCTION zdb."top_metrics_agg"(
	"aggregate_name" TEXT, /* &str */
	"metric_field" TEXT, /* &str */
	"sort_type_lat_long" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'top_metric_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:61
-- zombodb::elasticsearch::aggregates::builders::metrics::sum_agg
CREATE  FUNCTION zdb."sum_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sum_agg_missing_int_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:47
-- zombodb::elasticsearch::aggregates::builders::metrics::sum_agg
CREATE  FUNCTION zdb."sum_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" double precision /* f64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sum_agg_missing_float_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:34
-- zombodb::elasticsearch::aggregates::builders::metrics::sum_agg
CREATE  FUNCTION zdb."sum_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sum_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:656
-- zombodb::elasticsearch::aggregates::builders::metrics::string_stats_agg
CREATE  FUNCTION zdb."string_stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'string_stats_missing_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:670
-- zombodb::elasticsearch::aggregates::builders::metrics::string_stats_agg
CREATE  FUNCTION zdb."string_stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"show_distribution" bool, /* bool */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'string_stats_char_distribution_missing_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:638
-- zombodb::elasticsearch::aggregates::builders::metrics::string_stats_agg
CREATE  FUNCTION zdb."string_stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"show_distribution" bool /* bool */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'string_stats_char_distribution_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:623
-- zombodb::elasticsearch::aggregates::builders::metrics::string_stats_agg
CREATE  FUNCTION zdb."string_stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'string_stats_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:211
-- zombodb::elasticsearch::aggregates::builders::metrics::stats_agg
CREATE  FUNCTION zdb."stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'stats_agg_missing_int_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:225
-- zombodb::elasticsearch::aggregates::builders::metrics::stats_agg
CREATE  FUNCTION zdb."stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" double precision /* f64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'stats_agg_missing_float_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:198
-- zombodb::elasticsearch::aggregates::builders::metrics::stats_agg
CREATE  FUNCTION zdb."stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'stats_agg_wrapper';

-- src/access_method/options.rs:460
-- zombodb::access_method::options::shadow

        -- we don't want any SQL generated for the "shadow" function, but we do want its '_wrapper' symbol
        -- exported so that shadow indexes can reference it using whatever argument type they want
    



-- src/scoring/mod.rs:6
-- zombodb::scoring::score
CREATE  FUNCTION zdb."score"(
	"ctid" tid /* core::option::Option<pgrx_pg_sys::pg14::ItemPointerData> */
) RETURNS double precision /* f64 */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'score_wrapper';

-- src/elasticsearch/aggregates/builders/sampler.rs:11
-- zombodb::elasticsearch::aggregates::builders::sampler::sampler_agg
CREATE  FUNCTION zdb."sampler_agg"(
	"aggregate_name" TEXT, /* &str */
	"shard_size" bigint, /* i64 */
	"children" jsonb[] DEFAULT NULL /* core::option::Option<alloc::vec::Vec<pgrx::datum::json::JsonB>> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sampler_agg_wrapper';

-- src/zdbquery/opclass.rs:92
-- zombodb::zdbquery::opclass::restrict
CREATE  FUNCTION zdb."restrict"(
	"planner_info" internal, /* pgrx::datum::internal::Internal */
	"_operator_oid" oid, /* pgrx_pg_sys::submodules::oids::Oid */
	"args" internal, /* pgrx::datum::internal::Internal */
	"var_relid" INT /* i32 */
) RETURNS double precision /* f64 */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'restrict_wrapper';

-- src/mapping/mod.rs:9
-- zombodb::mapping::reapply_mapping
CREATE  FUNCTION zdb."reapply_mapping"(
	"index_relation" regclass /* pgrx::rel::PgRelation */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'reapply_mapping_wrapper';

-- src/elasticsearch/aggregates/builders/range.rs:12
-- zombodb::elasticsearch::aggregates::builders::range::range_agg
CREATE  FUNCTION zdb."range_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"ranges" json[], /* alloc::vec::Vec<pgrx::datum::json::Json> */
	"children" jsonb[] DEFAULT NULL /* core::option::Option<alloc::vec::Vec<pgrx::datum::json::JsonB>> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'range_agg_wrapper';

-- src/query_dsl/geo.rs:26
-- zombodb::query_dsl::geo::point_to_json
CREATE  FUNCTION zdb."point_to_json"(
	"point" point /* pgrx_pg_sys::pg14::Point */
) RETURNS json /* pgrx::datum::json::Json */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'point_to_json_wrapper';

-- src/query_dsl/geo.rs:31
-- zombodb::query_dsl::geo::point_array_to_json
CREATE  FUNCTION zdb."point_array_to_json"(
	"points" point[] /* pgrx::datum::array::Array<pgrx_pg_sys::pg14::Point> */
) RETURNS json /* pgrx::datum::json::Json */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'point_array_to_json_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:601
-- zombodb::elasticsearch::aggregates::builders::metrics::percentiles_agg
CREATE  FUNCTION zdb."percentiles_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"percents" double precision[], /* alloc::vec::Vec<f64> */
	"keyed" bool, /* bool */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'percentiles_precents_keyed_missing_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:561
-- zombodb::elasticsearch::aggregates::builders::metrics::percentiles_agg
CREATE  FUNCTION zdb."percentiles_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"precents" double precision[], /* alloc::vec::Vec<f64> */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'percentiles_precent_missing_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:541
-- zombodb::elasticsearch::aggregates::builders::metrics::percentiles_agg
CREATE  FUNCTION zdb."percentiles_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"percents" double precision[], /* alloc::vec::Vec<f64> */
	"keyed" bool /* bool */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'percentiles_precent_keyed_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:527
-- zombodb::elasticsearch::aggregates::builders::metrics::percentiles_agg
CREATE  FUNCTION zdb."percentiles_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'percentiles_missing_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:581
-- zombodb::elasticsearch::aggregates::builders::metrics::percentiles_agg
CREATE  FUNCTION zdb."percentiles_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"keyed" bool, /* bool */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'percentiles_keyed_missing_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:486
-- zombodb::elasticsearch::aggregates::builders::metrics::percentiles_agg
CREATE  FUNCTION zdb."percentiles_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'percentiles_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:499
-- zombodb::elasticsearch::aggregates::builders::metrics::percentiles
CREATE  FUNCTION zdb."percentiles"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"percents" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'percentiles_precents_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:513
-- zombodb::elasticsearch::aggregates::builders::metrics::percentiles
CREATE  FUNCTION zdb."percentiles"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"keyed" bool /* bool */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'percentiles_keyed_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:129
-- zombodb::elasticsearch::aggregates::builders::metrics::min_agg
CREATE  FUNCTION zdb."min_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_agg_missing_int_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:143
-- zombodb::elasticsearch::aggregates::builders::metrics::min_agg
CREATE  FUNCTION zdb."min_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" double precision /* f64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_agg_missing_float_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:116
-- zombodb::elasticsearch::aggregates::builders::metrics::min_agg
CREATE  FUNCTION zdb."min_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:452
-- zombodb::elasticsearch::aggregates::builders::metrics::median_absolute_deviation_agg
CREATE  FUNCTION zdb."median_absolute_deviation_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'median_absolute_deviation_missing_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:466
-- zombodb::elasticsearch::aggregates::builders::metrics::median_absolute_deviation_agg
CREATE  FUNCTION zdb."median_absolute_deviation_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"compression" bigint, /* i64 */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'median_absolute_deviation_compression_missing_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:439
-- zombodb::elasticsearch::aggregates::builders::metrics::median_absolute_deviation_agg
CREATE  FUNCTION zdb."median_absolute_deviation_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'median_absolute_deviation_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:170
-- zombodb::elasticsearch::aggregates::builders::metrics::max_agg
CREATE  FUNCTION zdb."max_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_agg_missing_int_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:184
-- zombodb::elasticsearch::aggregates::builders::metrics::max_agg
CREATE  FUNCTION zdb."max_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" double precision /* f64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_agg_missing_float_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:157
-- zombodb::elasticsearch::aggregates::builders::metrics::max_agg
CREATE  FUNCTION zdb."max_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:333
-- zombodb::elasticsearch::aggregates::builders::metrics::matrix_stats_agg
CREATE  FUNCTION zdb."matrix_stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT[], /* alloc::vec::Vec<&str> */
	"missing_field" TEXT, /* &str */
	"missing_value" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'matrix_stats_agg_missing_i64_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:321
-- zombodb::elasticsearch::aggregates::builders::metrics::matrix_stats_agg
CREATE  FUNCTION zdb."matrix_stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT[] /* alloc::vec::Vec<&str> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'matrix_stats_agg_wrapper';

-- src/elasticsearch/aggregates/builders/ip_range.rs:19
-- zombodb::elasticsearch::aggregates::builders::ip_range::ip_range_agg
CREATE  FUNCTION zdb."ip_range_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"range" json[], /* alloc::vec::Vec<pgrx::datum::json::Json> */
	"keyed" bool DEFAULT NULL /* core::option::Option<bool> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'ip_range_agg_wrapper';

-- src/zdbquery/mvcc.rs:9
-- zombodb::zdbquery::mvcc::internal_visibility_clause
CREATE  FUNCTION zdb."internal_visibility_clause"(
	"index_relation" regclass /* pgrx::rel::PgRelation */
) RETURNS json /* pgrx::datum::json::Json */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'internal_visibility_clause_wrapper';

-- src/lib.rs:64
-- zombodb::internal_version
CREATE  FUNCTION zdb."internal_version"() RETURNS TEXT /* alloc::string::String */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'internal_version_wrapper';

-- src/access_method/options.rs:495
-- zombodb::access_method::options::index_url
CREATE  FUNCTION zdb."index_url"(
	"index_relation" regclass /* pgrx::rel::PgRelation */
) RETURNS TEXT /* alloc::string::String */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'index_url_wrapper';

-- src/access_method/options.rs:502
-- zombodb::access_method::options::index_type_name
CREATE  FUNCTION zdb."index_type_name"(
	"index_relation" regclass /* pgrx::rel::PgRelation */
) RETURNS TEXT /* alloc::string::String */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'index_type_name_wrapper';

-- src/access_method/options.rs:519
-- zombodb::access_method::options::index_settings
CREATE  FUNCTION zdb."index_settings"(
	"index_relation" regclass /* pgrx::rel::PgRelation */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'index_settings_wrapper';

-- src/access_method/options.rs:529
-- zombodb::access_method::options::index_options
CREATE  FUNCTION zdb."index_options"(
	"index_relation" regclass /* pgrx::rel::PgRelation */
) RETURNS TEXT[] /* core::option::Option<alloc::vec::Vec<alloc::string::String>> */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'index_options_wrapper';

-- src/access_method/options.rs:481
-- zombodb::access_method::options::index_name
CREATE  FUNCTION zdb."index_name"(
	"index_relation" regclass /* pgrx::rel::PgRelation */
) RETURNS TEXT /* alloc::string::String */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'index_name_wrapper';

-- src/access_method/options.rs:509
-- zombodb::access_method::options::index_mapping
CREATE  FUNCTION zdb."index_mapping"(
	"index_relation" regclass /* pgrx::rel::PgRelation */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'index_mapping_wrapper';

-- src/access_method/options.rs:475
-- zombodb::access_method::options::index_links
CREATE  FUNCTION zdb."index_links"(
	"relation" regclass /* pgrx::rel::PgRelation */
) RETURNS TEXT[] /* core::option::Option<alloc::vec::Vec<alloc::string::String>> */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'index_links_wrapper';

-- src/access_method/options.rs:536
-- zombodb::access_method::options::index_field_lists
CREATE  FUNCTION zdb."index_field_lists"(
	"index_relation" regclass /* pgrx::rel::PgRelation */
) RETURNS TABLE (
	"fieldname" TEXT,  /* alloc::string::String */
	"fields" TEXT[]  /* alloc::vec::Vec<alloc::string::String> */
)
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'index_field_lists_wrapper';

-- src/access_method/options.rs:488
-- zombodb::access_method::options::index_alias
CREATE  FUNCTION zdb."index_alias"(
	"index_relation" regclass /* pgrx::rel::PgRelation */
) RETURNS TEXT /* alloc::string::String */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'index_alias_wrapper';

-- src/elasticsearch/aggregates/builders/histogram.rs:24
-- zombodb::elasticsearch::aggregates::builders::histogram::histogram_agg
CREATE  FUNCTION zdb."histogram_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"interval" bigint, /* i64 */
	"min_count" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"keyed" bool DEFAULT NULL, /* core::option::Option<bool> */
	"missing" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"children" jsonb[] DEFAULT NULL /* core::option::Option<alloc::vec::Vec<pgrx::datum::json::JsonB>> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'histogram_agg_wrapper';

-- src/highlighting/document_highlighter.rs:862
-- zombodb::highlighting::document_highlighter::highlight_wildcard
CREATE  FUNCTION zdb."highlight_wildcard"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_name" TEXT, /* &str */
	"text" TEXT, /* alloc::string::String */
	"token_to_highlight" TEXT /* &str */
) RETURNS TABLE (
	"field_name" TEXT,  /* alloc::string::String */
	"term" TEXT,  /* alloc::string::String */
	"type" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_wildcard_wrapper';

-- src/highlighting/document_highlighter.rs:782
-- zombodb::highlighting::document_highlighter::highlight_term
CREATE  FUNCTION zdb."highlight_term"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_name" TEXT, /* &str */
	"text" TEXT, /* alloc::string::String */
	"token_to_highlight" TEXT /* alloc::string::String */
) RETURNS TABLE (
	"field_name" TEXT,  /* alloc::string::String */
	"term" TEXT,  /* alloc::string::String */
	"type" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_term_wrapper';

-- src/highlighting/document_highlighter.rs:902
-- zombodb::highlighting::document_highlighter::highlight_regex
CREATE  FUNCTION zdb."highlight_regex"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_name" TEXT, /* &str */
	"text" TEXT, /* alloc::string::String */
	"token_to_highlight" TEXT /* &str */
) RETURNS TABLE (
	"field_name" TEXT,  /* alloc::string::String */
	"term" TEXT,  /* alloc::string::String */
	"type" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_regex_wrapper';

-- src/highlighting/document_highlighter.rs:822
-- zombodb::highlighting::document_highlighter::highlight_phrase
CREATE  FUNCTION zdb."highlight_phrase"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_name" TEXT, /* &str */
	"text" TEXT, /* alloc::string::String */
	"tokens_to_highlight" TEXT /* &str */
) RETURNS TABLE (
	"field_name" TEXT,  /* alloc::string::String */
	"term" TEXT,  /* alloc::string::String */
	"type" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_phrase_wrapper';

-- src/highlighting/document_highlighter.rs:942
-- zombodb::highlighting::document_highlighter::highlight_fuzzy
CREATE  FUNCTION zdb."highlight_fuzzy"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_name" TEXT, /* &str */
	"text" TEXT, /* alloc::string::String */
	"token_to_highlight" TEXT, /* &str */
	"prefix" INT /* i32 */
) RETURNS TABLE (
	"field_name" TEXT,  /* alloc::string::String */
	"term" TEXT,  /* alloc::string::String */
	"type" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_fuzzy_wrapper';

-- src/highlighting/query_highlighter.rs:529
-- zombodb::highlighting::query_highlighter::highlight_document
CREATE  FUNCTION zdb."highlight_document"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"document" jsonb, /* pgrx::datum::json::JsonB */
	"query_string" TEXT, /* &str */
	"dedup_results" bool DEFAULT true /* bool */
) RETURNS TABLE (
	"field_name" TEXT,  /* alloc::string::String */
	"array_index" INT,  /* i32 */
	"term" TEXT,  /* alloc::string::String */
	"type" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint,  /* i64 */
	"query_clause" TEXT  /* alloc::string::String */
)
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_document_jsonb_wrapper';

-- src/highlighting/query_highlighter.rs:550
-- zombodb::highlighting::query_highlighter::highlight_document
CREATE  FUNCTION zdb."highlight_document"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"document" json, /* pgrx::datum::json::Json */
	"query_string" TEXT, /* &str */
	"dedup_results" bool DEFAULT true /* bool */
) RETURNS TABLE (
	"field_name" TEXT,  /* alloc::string::String */
	"array_index" INT,  /* i32 */
	"term" TEXT,  /* alloc::string::String */
	"type" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint,  /* i64 */
	"query_clause" TEXT  /* alloc::string::String */
)
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_document_json_wrapper';

-- src/elasticsearch/aggregates/builders/global.rs:11
-- zombodb::elasticsearch::aggregates::builders::global::global_agg
CREATE  FUNCTION zdb."global_agg"(
	"aggregate_name" TEXT, /* &str */
	"children" jsonb[] DEFAULT NULL /* core::option::Option<alloc::vec::Vec<pgrx::datum::json::JsonB>> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'global_agg_wrapper';

-- src/elasticsearch/aggregates/builders/geohash_grid.rs:24
-- zombodb::elasticsearch::aggregates::builders::geohash_grid::geohash_grid_agg
CREATE  FUNCTION zdb."geohash_grid_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"precision" smallint DEFAULT NULL, /* core::option::Option<i16> */
	"bounds" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"size" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"shard_size" bigint DEFAULT NULL /* core::option::Option<i64> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'geohash_grid_agg_wrapper';

-- src/elasticsearch/aggregates/builders/geotile_grid.rs:24
-- zombodb::elasticsearch::aggregates::builders::geotile_grid::geogrid_grid_agg
CREATE  FUNCTION zdb."geogrid_grid_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"precision" smallint DEFAULT NULL, /* core::option::Option<i16> */
	"bounds" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"size" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"shard_size" bigint DEFAULT NULL /* core::option::Option<i64> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'geogrid_grid_agg_wrapper';

-- src/elasticsearch/aggregates/builders/geo_distance.rs:22
-- zombodb::elasticsearch::aggregates::builders::geo_distance::geo_distance_agg
CREATE  FUNCTION zdb."geo_distance_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"origin" TEXT, /* &str */
	"range" json[], /* alloc::vec::Vec<pgrx::datum::json::Json> */
	"unit" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"keyed" bool DEFAULT NULL /* core::option::Option<bool> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'geo_distance_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:426
-- zombodb::elasticsearch::aggregates::builders::metrics::geo_centroid_agg
CREATE  FUNCTION zdb."geo_centroid_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'geo_centroid_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:352
-- zombodb::elasticsearch::aggregates::builders::metrics::geo_bounds_agg
CREATE  FUNCTION zdb."geo_bounds_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"wrap_longitude" bool /* bool */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'geo_bounds_agg_wrapper';

-- src/access_method/options.rs:548
-- zombodb::access_method::options::field_mapping
CREATE  FUNCTION zdb."field_mapping"(
	"index_relation" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT /* &str */
) RETURNS jsonb /* core::option::Option<pgrx::datum::json::JsonB> */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'field_mapping_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:293
-- zombodb::elasticsearch::aggregates::builders::metrics::extended_stats_agg
CREATE  FUNCTION zdb."extended_stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'extended_stats_agg_missing_int_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:307
-- zombodb::elasticsearch::aggregates::builders::metrics::extended_stats_agg
CREATE  FUNCTION zdb."extended_stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" double precision /* f64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'extended_stats_agg_missing_float_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:280
-- zombodb::elasticsearch::aggregates::builders::metrics::extended_stats_agg
CREATE  FUNCTION zdb."extended_stats_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'extended_stats_agg_wrapper';

-- src/access_method/options.rs:465
-- zombodb::access_method::options::determine_index
CREATE  FUNCTION zdb."determine_index"(
	"relation" regclass /* pgrx::rel::PgRelation */
) RETURNS regclass /* core::option::Option<pgrx::rel::PgRelation> */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'determine_index_wrapper';

-- src/zql/dsl/mod.rs:24
-- zombodb::zql::dsl::debug_query
CREATE  FUNCTION zdb."debug_query"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"query" TEXT /* &str */
) RETURNS TABLE (
	"normalized_query" TEXT,  /* alloc::string::String */
	"used_fields" TEXT[],  /* alloc::vec::Vec<alloc::string::String> */
	"ast" TEXT  /* alloc::string::String */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'debug_query_wrapper';

-- src/elasticsearch/aggregates/builders/date_range.rs:24
-- zombodb::elasticsearch::aggregates::builders::date_range::date_range_agg
CREATE  FUNCTION zdb."date_range_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"format" TEXT, /* &str */
	"range" json[], /* alloc::vec::Vec<pgrx::datum::json::Json> */
	"missing" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"keyed" bool DEFAULT NULL, /* core::option::Option<bool> */
	"time_zone" TEXT DEFAULT NULL /* core::option::Option<&str> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'date_range_agg_wrapper';

-- src/lib.rs:85
-- zombodb::ctid
CREATE  FUNCTION zdb."ctid"(
	"as_u64" bigint /* i64 */
) RETURNS tid /* pgrx_pg_sys::pg14::ItemPointerData */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'ctid_wrapper';

-- src/elasticsearch/aggregates/builders/childern.rs:11
-- zombodb::elasticsearch::aggregates::builders::childern::children_agg
CREATE  FUNCTION zdb."children_agg"(
	"aggregate_name" TEXT, /* &str */
	"join_type" TEXT, /* &str */
	"children" jsonb[] DEFAULT NULL /* core::option::Option<alloc::vec::Vec<pgrx::datum::json::JsonB>> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'children_agg_wrapper';

-- src/cat/mod.rs:6
-- zombodb::cat::cat_request
CREATE  FUNCTION zdb."cat_request"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"endpoint" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cat_request_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:252
-- zombodb::elasticsearch::aggregates::builders::metrics::cardinality_agg
CREATE  FUNCTION zdb."cardinality_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cardinality_agg_missing_int_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:266
-- zombodb::elasticsearch::aggregates::builders::metrics::cardinality_agg
CREATE  FUNCTION zdb."cardinality_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" double precision /* f64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cardinality_agg_missing_float_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:239
-- zombodb::elasticsearch::aggregates::builders::metrics::cardinality_agg
CREATE  FUNCTION zdb."cardinality_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cardinality_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:392
-- zombodb::elasticsearch::aggregates::builders::metrics::boxplot_agg
CREATE  FUNCTION zdb."boxplot_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'boxplot_missing_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:406
-- zombodb::elasticsearch::aggregates::builders::metrics::boxplot_agg
CREATE  FUNCTION zdb."boxplot_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"compression" bigint, /* i64 */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'boxplot_compression_missing_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:379
-- zombodb::elasticsearch::aggregates::builders::metrics::boxplot_agg
CREATE  FUNCTION zdb."boxplot_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'boxplot_agg_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:88
-- zombodb::elasticsearch::aggregates::builders::metrics::avg_agg
CREATE  FUNCTION zdb."avg_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'avg_agg_missing_int_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:102
-- zombodb::elasticsearch::aggregates::builders::metrics::avg_agg
CREATE  FUNCTION zdb."avg_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"missing" double precision /* f64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'avg_agg_missing_float_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:75
-- zombodb::elasticsearch::aggregates::builders::metrics::avg_agg
CREATE  FUNCTION zdb."avg_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT /* &str */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'avg_agg_wrapper';

-- src/elasticsearch/analyze.rs:140
-- zombodb::elasticsearch::analyze::analyze_with_field
CREATE  FUNCTION zdb."analyze_with_field"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"text" TEXT /* &str */
) RETURNS TABLE (
	"type" TEXT,  /* alloc::string::String */
	"token" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'analyze_with_field_wrapper';

-- src/elasticsearch/analyze.rs:120
-- zombodb::elasticsearch::analyze::analyze_text
CREATE  FUNCTION zdb."analyze_text"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"analyzer" TEXT, /* &str */
	"text" TEXT /* &str */
) RETURNS TABLE (
	"type" TEXT,  /* alloc::string::String */
	"token" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'analyze_text_wrapper';

-- src/elasticsearch/analyze.rs:160
-- zombodb::elasticsearch::analyze::analyze_custom
CREATE  FUNCTION zdb."analyze_custom"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"text" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"tokenizer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"normalizer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"filter" TEXT[] DEFAULT NULL, /* core::option::Option<pgrx::datum::array::Array<&str>> */
	"char_filter" TEXT[] DEFAULT NULL /* core::option::Option<pgrx::datum::array::Array<&str>> */
) RETURNS TABLE (
	"type" TEXT,  /* alloc::string::String */
	"token" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint  /* i64 */
)
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'analyze_custom_wrapper';

-- src/access_method/mod.rs:15
-- zombodb::access_method::amhandler

    CREATE OR REPLACE FUNCTION amhandler(internal) RETURNS index_am_handler PARALLEL SAFE IMMUTABLE STRICT COST 0.0001 LANGUAGE c AS 'MODULE_PATHNAME', 'amhandler_wrapper';
    CREATE ACCESS METHOD zombodb TYPE INDEX HANDLER amhandler;




-- src/elasticsearch/aggregates/builders/metrics.rs:26
-- zombodb::elasticsearch::aggregates::builders::metrics::TTestType
CREATE TYPE zdb.TTestType AS ENUM (
	'Paired',
	'Homoscedastic',
	'Heteroscedastic'
);

-- src/elasticsearch/aggregates/builders/metrics.rs:809
-- zombodb::elasticsearch::aggregates::builders::metrics::t_test_agg
CREATE  FUNCTION zdb."t_test_agg"(
	"aggregate_name" TEXT, /* &str */
	"fields" TEXT[], /* alloc::vec::Vec<&str> */
	"t_type" zdb.TTestType /* zombodb::elasticsearch::aggregates::builders::metrics::TTestType */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 't_test_fields_agg_wrapper';

-- src/elasticsearch/aggregates/builders/auto_date_histogram.rs:10
-- zombodb::elasticsearch::aggregates::builders::auto_date_histogram::Intervals
CREATE TYPE zdb.Intervals AS ENUM (
	'Year',
	'Month',
	'Day',
	'Hour',
	'Minute',
	'Second'
);

-- src/elasticsearch/aggregates/builders/auto_date_histogram.rs:33
-- zombodb::elasticsearch::aggregates::builders::auto_date_histogram::auto_date_histogram_agg
CREATE  FUNCTION zdb."auto_date_histogram_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"buckets" bigint, /* i64 */
	"format" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"minimum_interval" zdb.Intervals DEFAULT NULL, /* core::option::Option<zombodb::elasticsearch::aggregates::builders::auto_date_histogram::Intervals> */
	"missing" TEXT DEFAULT NULL /* core::option::Option<&str> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'auto_date_histogram_agg_wrapper';

-- src/elasticsearch/aggregates/builders/diversified_sampler.rs:11
-- zombodb::elasticsearch::aggregates::builders::diversified_sampler::ExecutionHint
CREATE TYPE zdb.ExecutionHint AS ENUM (
	'Map',
	'GlobalOrdinals',
	'BytesHash'
);

-- src/elasticsearch/aggregates/builders/diversified_sampler.rs:29
-- zombodb::elasticsearch::aggregates::builders::diversified_sampler::diversified_sampler_agg
CREATE  FUNCTION zdb."diversified_sampler_agg"(
	"aggregate_name" TEXT, /* &str */
	"shard_size" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"max_docs_per_value" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"execution_hint" zdb.ExecutionHint DEFAULT NULL, /* core::option::Option<zombodb::elasticsearch::aggregates::builders::diversified_sampler::ExecutionHint> */
	"children" jsonb[] DEFAULT NULL /* core::option::Option<alloc::vec::Vec<pgrx::datum::json::JsonB>> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'diversified_sampler_agg_wrapper';

-- src/zql/ast.rs:59
-- zombodb::zql::ast::pg_catalog::ProximityPart
CREATE TYPE pg_catalog.ProximityPart;

-- src/zql/ast.rs:59
-- zombodb::zql::ast::pg_catalog::proximitypart_in
CREATE  FUNCTION pg_catalog."proximitypart_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS pg_catalog.ProximityPart /* core::option::Option<zombodb::zql::ast::pg_catalog::ProximityPart> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'proximitypart_in_wrapper';

-- src/zql/ast.rs:59
-- zombodb::zql::ast::pg_catalog::proximitypart_out
CREATE  FUNCTION pg_catalog."proximitypart_out"(
	"input" pg_catalog.ProximityPart /* zombodb::zql::ast::pg_catalog::ProximityPart */
) RETURNS cstring /* &core::ffi::c_str::CStr */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'proximitypart_out_wrapper';

-- src/zql/ast.rs:59
-- zombodb::zql::ast::pg_catalog::ProximityPart
CREATE TYPE pg_catalog.ProximityPart (
	INTERNALLENGTH = variable,
	INPUT = pg_catalog.proximitypart_in, /* zombodb::zql::ast::pg_catalog::proximitypart_in */
	OUTPUT = pg_catalog.proximitypart_out, /* zombodb::zql::ast::pg_catalog::proximitypart_out */
	STORAGE = extended
);

-- src/highlighting/document_highlighter.rs:987
-- zombodb::highlighting::document_highlighter::highlight_proximity
CREATE  FUNCTION zdb."highlight_proximity"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_name" TEXT, /* &str */
	"text" TEXT, /* alloc::string::String */
	"prox_clause" pg_catalog.ProximityPart[], /* alloc::vec::Vec<core::option::Option<zombodb::zql::ast::pg_catalog::ProximityPart>> */
	"dedup_results" bool DEFAULT true /* bool */
) RETURNS TABLE (
	"field_name" TEXT,  /* alloc::string::String */
	"term" TEXT,  /* alloc::string::String */
	"type" TEXT,  /* alloc::string::String */
	"position" INT,  /* i32 */
	"start_offset" bigint,  /* i64 */
	"end_offset" bigint  /* i64 */
)
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_proximity_wrapper';

-- src/zdbquery/mod.rs:117
-- zombodb::zdbquery::pg_catalog::ZDBQuery
CREATE TYPE pg_catalog.ZDBQuery;

-- src/zdbquery/mod.rs:117
-- zombodb::zdbquery::pg_catalog::zdbquery_in
CREATE  FUNCTION pg_catalog."zdbquery_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS pg_catalog.ZDBQuery /* core::option::Option<zombodb::zdbquery::pg_catalog::ZDBQuery> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'zdbquery_in_wrapper';

-- src/zdbquery/mod.rs:117
-- zombodb::zdbquery::pg_catalog::zdbquery_out
CREATE  FUNCTION pg_catalog."zdbquery_out"(
	"input" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS cstring /* &core::ffi::c_str::CStr */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'zdbquery_out_wrapper';

-- src/zdbquery/mod.rs:117
-- zombodb::zdbquery::pg_catalog::ZDBQuery
CREATE TYPE pg_catalog.ZDBQuery (
	INTERNALLENGTH = variable,
	INPUT = pg_catalog.zdbquery_in, /* zombodb::zdbquery::pg_catalog::zdbquery_in */
	OUTPUT = pg_catalog.zdbquery_out, /* zombodb::zdbquery::pg_catalog::zdbquery_out */
	STORAGE = extended
);

-- src/elasticsearch/aggregates/metrics.rs:95
-- zombodb::elasticsearch::aggregates::metrics::max
CREATE  FUNCTION zdb."max"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS NUMERIC /* pgrx::datum::numeric::AnyNumeric */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_wrapper';

-- src/elasticsearch/aggregates/extended_stats.rs:9
-- zombodb::elasticsearch::aggregates::extended_stats::extended_stats
CREATE  FUNCTION zdb."extended_stats"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"sigma" bigint DEFAULT 0 /* i64 */
) RETURNS TABLE (
	"count" bigint,  /* i64 */
	"min" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"max" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"avg" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"sum" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"sum_of_squares" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"variance" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"std_deviation" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"upper" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"lower" NUMERIC  /* pgrx::datum::numeric::AnyNumeric */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'extended_stats_wrapper';

-- src/elasticsearch/aggregates/count.rs:7
-- zombodb::elasticsearch::aggregates::count::count
CREATE  FUNCTION zdb."count"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS bigint /* i64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'count_wrapper';

-- src/elasticsearch/aggregates/arbitrary_agg.rs:6
-- zombodb::elasticsearch::aggregates::arbitrary_agg::arbitrary_agg
CREATE  FUNCTION zdb."arbitrary_agg"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"json" jsonb /* pgrx::datum::json::JsonB */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'arbitrary_agg_wrapper';

-- src/zdbquery/cast.rs:5
-- zombodb::zdbquery::cast::zdbquery_from_text
CREATE  FUNCTION zdb."zdbquery_from_text"(
	"input" TEXT /* &str */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'zdbquery_from_text_wrapper';

-- src/elasticsearch/suggest_term.rs:89
-- zombodb::elasticsearch::suggest_term::suggest_terms
CREATE  FUNCTION zdb."suggest_terms"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_name" TEXT, /* alloc::string::String */
	"suggest" TEXT, /* alloc::string::String */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS TABLE (
	"term" TEXT,  /* alloc::string::String */
	"offset" bigint,  /* i64 */
	"length" bigint,  /* i64 */
	"suggestion" TEXT,  /* alloc::string::String */
	"score" double precision,  /* f64 */
	"frequency" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'suggest_terms_wrapper';

-- src/elasticsearch/aggregates/metrics.rs:8
-- zombodb::elasticsearch::aggregates::metrics::sum
CREATE  FUNCTION zdb."sum"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS NUMERIC /* pgrx::datum::numeric::AnyNumeric */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sum_wrapper';

-- src/zql/dsl/mod.rs:18
-- zombodb::zql::dsl::dump_query
CREATE  FUNCTION zdb."dump_query"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS TEXT /* alloc::string::String */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'dump_query_wrapper';

-- src/zdbquery/opclass.rs:10
-- zombodb::zdbquery::opclass::anyelement_cmpfunc
CREATE  FUNCTION zdb."anyelement_cmpfunc"(
	"element" anyelement, /* pgrx::datum::anyelement::AnyElement */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'anyelement_cmpfunc_wrapper';

-- src/zdbquery/mvcc.rs:18
-- zombodb::zdbquery::mvcc::wrap_with_visibility_clause
CREATE  FUNCTION zdb."wrap_with_visibility_clause"(
	"index_relation" regclass, /* pgrx::rel::PgRelation */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'wrap_with_visibility_clause_wrapper';

-- src/misc/mod.rs:8
-- zombodb::misc::query_tids
CREATE  FUNCTION zdb."query_tids"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS tid[] /* alloc::vec::Vec<pgrx_pg_sys::pg14::ItemPointerData> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'query_tids_wrapper';

-- src/zdbquery/cast.rs:21
-- zombodb::zdbquery::cast::zdbquery_to_json
CREATE  FUNCTION zdb."zdbquery_to_json"(
	"input" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS json /* pgrx::datum::json::Json */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'zdbquery_to_json_wrapper';

-- src/zdbquery/mod.rs:894
-- zombodb::zdbquery::to_queries_dsl
CREATE  FUNCTION zdb."to_queries_dsl"(
	"queries" pg_catalog.ZDBQuery[] /* pgrx::datum::array::Array<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS json[] /* alloc::vec::Vec<core::option::Option<pgrx::datum::json::Json>> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'to_queries_dsl_wrapper';

-- src/zdbquery/cast.rs:11
-- zombodb::zdbquery::cast::zdbquery_from_json
CREATE  FUNCTION zdb."zdbquery_from_json"(
	"input" json /* pgrx::datum::json::Json */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'zdbquery_from_json_wrapper';

-- src/elasticsearch/aggregates/metrics.rs:153
-- zombodb::elasticsearch::aggregates::metrics::missing
CREATE  FUNCTION zdb."missing"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS NUMERIC /* pgrx::datum::numeric::AnyNumeric */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'missing_wrapper';

-- src/scoring/mod.rs:31
-- zombodb::scoring::want_scores
CREATE  FUNCTION zdb."want_scores"(
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'want_scores_wrapper';

-- src/elasticsearch/aggregates/adjacency_matrix.rs:12
-- zombodb::elasticsearch::aggregates::adjacency_matrix::adjacency_matrix
CREATE  FUNCTION zdb."adjacency_matrix"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"labels" TEXT[], /* pgrx::datum::array::Array<&str> */
	"filters" pg_catalog.ZDBQuery[] /* pgrx::datum::array::Array<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS TABLE (
	"term" TEXT,  /* core::option::Option<alloc::string::String> */
	"doc_count" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'adjacency_matrix_wrapper';

-- src/elasticsearch/aggregates/metrics.rs:66
-- zombodb::elasticsearch::aggregates::metrics::cardinality
CREATE  FUNCTION zdb."cardinality"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS NUMERIC /* pgrx::datum::numeric::AnyNumeric */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cardinality_wrapper';

-- src/elasticsearch/aggregates/builders/filter.rs:14
-- zombodb::elasticsearch::aggregates::builders::filter::filter_agg
CREATE  FUNCTION zdb."filter_agg"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"aggregate_name" TEXT, /* &str */
	"filter" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"children" jsonb[] DEFAULT NULL /* core::option::Option<alloc::vec::Vec<pgrx::datum::json::JsonB>> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'filter_agg_wrapper';

-- src/elasticsearch/aggregates/count.rs:18
-- zombodb::elasticsearch::aggregates::count::raw_count
CREATE  FUNCTION zdb."raw_count"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS bigint /* i64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'raw_count_wrapper';

-- src/elasticsearch/aggregates/query.rs:7
-- zombodb::elasticsearch::aggregates::query::query
CREATE  FUNCTION zdb."query"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS SETOF tid /* pgrx_pg_sys::pg14::ItemPointerData */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'query_wrapper';

-- src/elasticsearch/aggregates/matrix_stats.rs:9
-- zombodb::elasticsearch::aggregates::matrix_stats::matrix_stats
CREATE  FUNCTION zdb."matrix_stats"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"fields" TEXT[], /* pgrx::datum::array::Array<&str> */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS TABLE (
	"term" TEXT,  /* alloc::string::String */
	"count" bigint,  /* i64 */
	"mean" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"variance" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"skewness" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"kurtosis" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"covariance" json,  /* core::option::Option<pgrx::datum::json::Json> */
	"correlation" json  /* core::option::Option<pgrx::datum::json::Json> */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'matrix_stats_wrapper';

-- src/elasticsearch/profile_query.rs:41
-- zombodb::elasticsearch::profile_query::profile_query
CREATE  FUNCTION zdb."profile_query"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'profile_query_wrapper';

-- src/elasticsearch/aggregates/stats.rs:9
-- zombodb::elasticsearch::aggregates::stats::stats
CREATE  FUNCTION zdb."stats"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS TABLE (
	"count" bigint,  /* i64 */
	"min" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"max" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"avg" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"sum" NUMERIC  /* pgrx::datum::numeric::AnyNumeric */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'stats_wrapper';

-- src/elasticsearch/aggregates/ip_range.rs:10
-- zombodb::elasticsearch::aggregates::ip_range::ip_range
CREATE  FUNCTION zdb."ip_range"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"range_array" json /* pgrx::datum::json::Json */
) RETURNS TABLE (
	"key" TEXT,  /* alloc::string::String */
	"from" inet,  /* core::option::Option<pgrx::datum::inet::Inet> */
	"to" inet,  /* core::option::Option<pgrx::datum::inet::Inet> */
	"doc_count" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'ip_range_wrapper';

-- src/zdbquery/mod.rs:887
-- zombodb::zdbquery::to_query_dsl
CREATE  FUNCTION zdb."to_query_dsl"(
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS json /* core::option::Option<pgrx::datum::json::Json> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'to_query_dsl_wrapper';

-- src/elasticsearch/aggregates/top_hits_with_id.rs:9
-- zombodb::elasticsearch::aggregates::top_hits_with_id::top_hits_with_id
CREATE  FUNCTION zdb."top_hits_with_id"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"fields" TEXT[], /* pgrx::datum::array::Array<&str> */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"size_limit" bigint /* i64 */
) RETURNS TABLE (
	"id" TEXT,  /* alloc::string::String */
	"score" double precision,  /* f64 */
	"source" json  /* pgrx::datum::json::Json */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'top_hits_with_id_wrapper';

-- src/elasticsearch/aggregates/top_hits.rs:9
-- zombodb::elasticsearch::aggregates::top_hits::top_hits
CREATE  FUNCTION zdb."top_hits"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"fields" TEXT[], /* pgrx::datum::array::Array<&str> */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"size_limit" bigint /* i64 */
) RETURNS TABLE (
	"id" tid,  /* pgrx_pg_sys::pg14::ItemPointerData */
	"score" double precision,  /* f64 */
	"source" json  /* pgrx::datum::json::Json */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'top_hits_wrapper';

-- src/elasticsearch/aggregates/metrics.rs:124
-- zombodb::elasticsearch::aggregates::metrics::min
CREATE  FUNCTION zdb."min"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS NUMERIC /* pgrx::datum::numeric::AnyNumeric */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_wrapper';

-- src/zdbquery/cast.rs:26
-- zombodb::zdbquery::cast::zdbquery_to_jsonb
CREATE  FUNCTION zdb."zdbquery_to_jsonb"(
	"input" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'zdbquery_to_jsonb_wrapper';

-- src/elasticsearch/aggregates/percentiles.rs:9
-- zombodb::elasticsearch::aggregates::percentiles::percentiles
CREATE  FUNCTION zdb."percentiles"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"percents" json DEFAULT NULL /* core::option::Option<pgrx::datum::json::Json> */
) RETURNS TABLE (
	"key" double precision,  /* f64 */
	"value" NUMERIC  /* pgrx::datum::numeric::AnyNumeric */
)
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'percentiles_wrapper';

-- src/zdbquery/cast.rs:16
-- zombodb::zdbquery::cast::zdbquery_from_jsonb
CREATE  FUNCTION zdb."zdbquery_from_jsonb"(
	"input" jsonb /* pgrx::datum::json::JsonB */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'zdbquery_from_jsonb_wrapper';

-- src/elasticsearch/aggregates/builders/metrics.rs:829
-- zombodb::elasticsearch::aggregates::builders::metrics::t_test_agg
CREATE  FUNCTION zdb."t_test_agg"(
	"aggregate_name" TEXT, /* &str */
	"fields" TEXT[], /* alloc::vec::Vec<&str> */
	"queries" pg_catalog.ZDBQuery[], /* alloc::vec::Vec<zombodb::zdbquery::pg_catalog::ZDBQuery> */
	"t_type" zdb.TTestType /* zombodb::elasticsearch::aggregates::builders::metrics::TTestType */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 't_test_fields_queries_agg_wrapper';

-- src/elasticsearch/aggregates/percentile_ranks.rs:9
-- zombodb::elasticsearch::aggregates::percentile_ranks::percentile_ranks
CREATE  FUNCTION zdb."percentile_ranks"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"values" json /* pgrx::datum::json::Json */
) RETURNS TABLE (
	"key" double precision,  /* f64 */
	"value" NUMERIC  /* pgrx::datum::numeric::AnyNumeric */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'percentile_ranks_wrapper';

-- src/elasticsearch/aggregates/query.rs:34
-- zombodb::elasticsearch::aggregates::query::query_raw

        CREATE OR REPLACE FUNCTION query_raw(index regclass, query zdbquery)
            RETURNS SETOF tid SET zdb.ignore_visibility = true
            IMMUTABLE STRICT ROWS 2500 LANGUAGE c AS 'MODULE_PATHNAME', 'query_raw_wrapper';
    



-- src/elasticsearch/aggregates/significant_terms_two_level.rs:10
-- zombodb::elasticsearch::aggregates::significant_terms_two_level::significant_terms_two_level
CREATE  FUNCTION zdb."significant_terms_two_level"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_first" TEXT, /* &str */
	"field_second" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"size_limit" INT DEFAULT 2147483647 /* core::option::Option<i32> */
) RETURNS TABLE (
	"term_one" TEXT,  /* core::option::Option<alloc::string::String> */
	"term_two" TEXT,  /* core::option::Option<alloc::string::String> */
	"doc_count" bigint,  /* i64 */
	"score" double precision,  /* f64 */
	"bg_count" bigint,  /* i64 */
	"doc_count_error_upper_bound" bigint,  /* i64 */
	"sum_other_doc_count" bigint  /* i64 */
)
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'significant_terms_two_level_wrapper';

-- src/elasticsearch/aggregates/date_range.rs:10
-- zombodb::elasticsearch::aggregates::date_range::date_range
CREATE  FUNCTION zdb."date_range"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"date_range_array" json /* pgrx::datum::json::Json */
) RETURNS TABLE (
	"key" TEXT,  /* alloc::string::String */
	"from" NUMERIC,  /* core::option::Option<pgrx::datum::numeric::AnyNumeric> */
	"from_as_string" TEXT,  /* core::option::Option<alloc::string::String> */
	"to" NUMERIC,  /* core::option::Option<pgrx::datum::numeric::AnyNumeric> */
	"to_as_string" TEXT,  /* core::option::Option<alloc::string::String> */
	"doc_count" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'date_range_wrapper';

-- src/elasticsearch/aggregates/builders/filters.rs:14
-- zombodb::elasticsearch::aggregates::builders::filters::filters_agg
CREATE  FUNCTION zdb."filters_agg"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"aggregate_name" TEXT, /* &str */
	"labels" TEXT[], /* pgrx::datum::array::Array<&str> */
	"filters" pg_catalog.ZDBQuery[] /* pgrx::datum::array::Array<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'filters_agg_wrapper';

-- src/elasticsearch/aggregates/metrics.rs:182
-- zombodb::elasticsearch::aggregates::metrics::value_count
CREATE  FUNCTION zdb."value_count"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS NUMERIC /* pgrx::datum::numeric::AnyNumeric */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'value_count_wrapper';

-- src/elasticsearch/aggregates/significant_terms.rs:10
-- zombodb::elasticsearch::aggregates::significant_terms::significant_terms
CREATE  FUNCTION zdb."significant_terms"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"include" TEXT DEFAULT '.*', /* core::option::Option<&str> */
	"size_limit" INT DEFAULT 2147483647, /* core::option::Option<i32> */
	"min_doc_count" INT DEFAULT 3 /* core::option::Option<i32> */
) RETURNS TABLE (
	"term" TEXT,  /* core::option::Option<alloc::string::String> */
	"doc_count" bigint,  /* i64 */
	"score" real,  /* f32 */
	"bg_count" bigint  /* i64 */
)
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'significant_terms_wrapper';

-- src/elasticsearch/aggregates/range.rs:10
-- zombodb::elasticsearch::aggregates::range::range
CREATE  FUNCTION zdb."range"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"range_array" json /* pgrx::datum::json::Json */
) RETURNS TABLE (
	"key" TEXT,  /* alloc::string::String */
	"from" NUMERIC,  /* core::option::Option<pgrx::datum::numeric::AnyNumeric> */
	"to" NUMERIC,  /* core::option::Option<pgrx::datum::numeric::AnyNumeric> */
	"doc_count" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'range_wrapper';

-- src/elasticsearch/aggregates/histogram.rs:9
-- zombodb::elasticsearch::aggregates::histogram::histogram
CREATE  FUNCTION zdb."histogram"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"interval" double precision, /* f64 */
	"min_doc_count" INT DEFAULT 0 /* i32 */
) RETURNS TABLE (
	"term" NUMERIC,  /* pgrx::datum::numeric::AnyNumeric */
	"doc_count" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'histogram_wrapper';

-- src/elasticsearch/aggregates/builders/adjacency_matrix.rs:15
-- zombodb::elasticsearch::aggregates::builders::adjacency_matrix::adjacency_matrix_agg
CREATE  FUNCTION zdb."adjacency_matrix_agg"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"aggregate_name" TEXT, /* &str */
	"labels" TEXT[], /* pgrx::datum::array::Array<&str> */
	"filters" pg_catalog.ZDBQuery[] /* pgrx::datum::array::Array<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'adjacency_matrix_agg_wrapper';

-- src/elasticsearch/aggregates/metrics.rs:37
-- zombodb::elasticsearch::aggregates::metrics::avg
CREATE  FUNCTION zdb."avg"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS NUMERIC /* pgrx::datum::numeric::AnyNumeric */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'avg_wrapper';

-- src/elasticsearch/aggregates/significant_text.rs:10
-- zombodb::elasticsearch::aggregates::significant_text::significant_text
CREATE  FUNCTION zdb."significant_text"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"size" INT DEFAULT 10, /* i32 */
	"filter_duplicate_text" bool DEFAULT true /* core::option::Option<bool> */
) RETURNS TABLE (
	"term" TEXT,  /* core::option::Option<alloc::string::String> */
	"doc_count" bigint,  /* i64 */
	"score" double precision,  /* f64 */
	"bg_count" bigint  /* i64 */
)
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'significant_text_wrapper';

-- src/elasticsearch/aggregates/filters.rs:11
-- zombodb::elasticsearch::aggregates::filters::filters
CREATE  FUNCTION zdb."filters"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"labels" TEXT[], /* pgrx::datum::array::Array<&str> */
	"filters" pg_catalog.ZDBQuery[] /* pgrx::datum::array::Array<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS TABLE (
	"term" TEXT,  /* alloc::string::String */
	"doc_count" bigint  /* i64 */
)
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'filters_wrapper';

-- src/zdbquery/mod.rs:167
-- zombodb::zdbquery::pg_catalog::SortDescriptor
CREATE TYPE pg_catalog.SortDescriptor;

-- src/zdbquery/mod.rs:167
-- zombodb::zdbquery::pg_catalog::sortdescriptor_in
CREATE  FUNCTION pg_catalog."sortdescriptor_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS pg_catalog.SortDescriptor /* core::option::Option<zombodb::zdbquery::pg_catalog::SortDescriptor> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sortdescriptor_in_wrapper';

-- src/zdbquery/mod.rs:167
-- zombodb::zdbquery::pg_catalog::sortdescriptor_out
CREATE  FUNCTION pg_catalog."sortdescriptor_out"(
	"input" pg_catalog.SortDescriptor /* zombodb::zdbquery::pg_catalog::SortDescriptor */
) RETURNS cstring /* &core::ffi::c_str::CStr */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sortdescriptor_out_wrapper';

-- src/zdbquery/mod.rs:167
-- zombodb::zdbquery::pg_catalog::SortDescriptor
CREATE TYPE pg_catalog.SortDescriptor (
	INTERNALLENGTH = variable,
	INPUT = pg_catalog.sortdescriptor_in, /* zombodb::zdbquery::pg_catalog::sortdescriptor_in */
	OUTPUT = pg_catalog.sortdescriptor_out, /* zombodb::zdbquery::pg_catalog::sortdescriptor_out */
	STORAGE = extended
);

-- src/elasticsearch/aggregates/builders/metrics.rs:752
-- zombodb::elasticsearch::aggregates::builders::metrics::top_metrics_agg
CREATE  FUNCTION zdb."top_metrics_agg"(
	"aggregate_name" TEXT, /* &str */
	"metric_field" TEXT, /* &str */
	"sort_type" pg_catalog.SortDescriptor /* zombodb::zdbquery::pg_catalog::SortDescriptor */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'top_metric_sort_desc_agg_wrapper';

-- src/zdbquery/mod.rs:156
-- zombodb::zdbquery::pg_catalog::SortDescriptorOptions
CREATE TYPE pg_catalog.SortDescriptorOptions;

-- src/zdbquery/mod.rs:156
-- zombodb::zdbquery::pg_catalog::sortdescriptoroptions_in
CREATE  FUNCTION pg_catalog."sortdescriptoroptions_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS pg_catalog.SortDescriptorOptions /* core::option::Option<zombodb::zdbquery::pg_catalog::SortDescriptorOptions> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sortdescriptoroptions_in_wrapper';

-- src/zdbquery/mod.rs:156
-- zombodb::zdbquery::pg_catalog::sortdescriptoroptions_out
CREATE  FUNCTION pg_catalog."sortdescriptoroptions_out"(
	"input" pg_catalog.SortDescriptorOptions /* zombodb::zdbquery::pg_catalog::SortDescriptorOptions */
) RETURNS cstring /* &core::ffi::c_str::CStr */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sortdescriptoroptions_out_wrapper';

-- src/zdbquery/mod.rs:156
-- zombodb::zdbquery::pg_catalog::SortDescriptorOptions
CREATE TYPE pg_catalog.SortDescriptorOptions (
	INTERNALLENGTH = variable,
	INPUT = pg_catalog.sortdescriptoroptions_in, /* zombodb::zdbquery::pg_catalog::sortdescriptoroptions_in */
	OUTPUT = pg_catalog.sortdescriptoroptions_out, /* zombodb::zdbquery::pg_catalog::sortdescriptoroptions_out */
	STORAGE = extended
);

-- src/zdbquery/mod.rs:141
-- zombodb::zdbquery::pg_catalog::SortDirection
CREATE TYPE pg_catalog.SortDirection AS ENUM (
	'asc',
	'desc'
);

-- src/zdbquery/mod.rs:147
-- zombodb::zdbquery::pg_catalog::SortMode
CREATE TYPE pg_catalog.SortMode AS ENUM (
	'min',
	'max',
	'sum',
	'avg',
	'median'
);

-- src/query_dsl/zdb.rs:1
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::zdb::dsl */

-- src/query_dsl/zdb.rs:11
-- zombodb::query_dsl::zdb::dsl::zdb
CREATE  FUNCTION dsl."zdb"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"input" TEXT /* &str */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'zdb_wrapper';

-- src/query_dsl/zdb.rs:31
-- zombodb::query_dsl::zdb::dsl::link_options
CREATE  FUNCTION dsl."link_options"(
	"options" TEXT[], /* alloc::vec::Vec<core::option::Option<alloc::string::String>> */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'link_options_wrapper';

-- src/query_dsl/terms_lookup.rs:7
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::terms_lookup::dsl */

-- src/query_dsl/terms_lookup.rs:24
-- zombodb::query_dsl::terms_lookup::dsl::terms_lookup
CREATE  FUNCTION dsl."terms_lookup"(
	"field" TEXT, /* &str */
	"index" TEXT, /* &str */
	"id" TEXT, /* &str */
	"path" TEXT, /* &str */
	"routing" TEXT DEFAULT NULL /* core::option::Option<&str> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_lookup_wrapper';

-- src/query_dsl/terms_array.rs:4
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::terms_array::dsl */

-- src/query_dsl/terms_array.rs:11
-- zombodb::query_dsl::terms_array::dsl::terms_array
CREATE  FUNCTION dsl."terms_array"(
	"fieldname" TEXT, /* &str */
	"array" anyarray /* pgrx::datum::anyarray::AnyArray */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_array_wrapper';

-- src/query_dsl/terms.rs:6
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::terms::dsl */

-- src/query_dsl/terms.rs:33
-- zombodb::query_dsl::terms::dsl::terms
CREATE  FUNCTION dsl."terms"(
	"field" TEXT, /* &str */
	"values" VARIADIC bigint[] /* pgrx::datum::array::VariadicArray<i64> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_i64_wrapper';

-- src/query_dsl/terms.rs:13
-- zombodb::query_dsl::terms::dsl::terms
CREATE  FUNCTION dsl."terms"(
	"field" TEXT, /* &str */
	"values" VARIADIC TEXT[] /* pgrx::datum::array::VariadicArray<&str> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_str_wrapper';

-- src/query_dsl/terms.rs:28
-- zombodb::query_dsl::terms::dsl::terms
CREATE  FUNCTION dsl."terms"(
	"field" TEXT, /* &str */
	"values" VARIADIC INT[] /* pgrx::datum::array::VariadicArray<i32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_i32_wrapper';

-- src/query_dsl/terms.rs:23
-- zombodb::query_dsl::terms::dsl::terms
CREATE  FUNCTION dsl."terms"(
	"field" TEXT, /* &str */
	"values" VARIADIC smallint[] /* pgrx::datum::array::VariadicArray<i16> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_i16_wrapper';

-- src/query_dsl/terms.rs:18
-- zombodb::query_dsl::terms::dsl::terms
CREATE  FUNCTION dsl."terms"(
	"field" TEXT, /* &str */
	"values" VARIADIC bool[] /* pgrx::datum::array::VariadicArray<bool> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_bool_wrapper';

-- src/query_dsl/terms.rs:43
-- zombodb::query_dsl::terms::dsl::terms
CREATE  FUNCTION dsl."terms"(
	"field" TEXT, /* &str */
	"values" VARIADIC double precision[] /* pgrx::datum::array::VariadicArray<f64> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_f64_wrapper';

-- src/query_dsl/terms.rs:38
-- zombodb::query_dsl::terms::dsl::terms
CREATE  FUNCTION dsl."terms"(
	"field" TEXT, /* &str */
	"values" VARIADIC real[] /* pgrx::datum::array::VariadicArray<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_f32_wrapper';

-- src/query_dsl/term.rs:6
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::term::dsl */

-- src/query_dsl/term.rs:122
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" timestamp, /* pgrx::datum::time_stamp::Timestamp */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_timestamp_wrapper';

-- src/query_dsl/term.rs:112
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" time with time zone, /* pgrx::datum::time_with_timezone::TimeWithTimeZone */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_time_with_timezone_wrapper';

-- src/query_dsl/term.rs:62
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" bigint, /* i64 */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_i64_wrapper';

-- src/query_dsl/term.rs:52
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" INT, /* i32 */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_i32_wrapper';

-- src/query_dsl/term.rs:32
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" bool, /* bool */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_bool_wrapper';

-- src/query_dsl/term.rs:102
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" date, /* pgrx::datum::date::Date */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_date_wrapper';

-- src/query_dsl/term.rs:92
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" time, /* pgrx::datum::time::Time */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_time_wrapper';

-- src/query_dsl/term.rs:135
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" timestamp with time zone, /* pgrx::datum::time_stamp_with_timezone::TimestampWithTimeZone */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_timestamp_with_timezone_wrapper';

-- src/query_dsl/term.rs:22
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" TEXT, /* &str */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_str_wrapper';

-- src/query_dsl/term.rs:72
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" real, /* f32 */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_f32_wrapper';

-- src/query_dsl/term.rs:42
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" smallint, /* i16 */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_i16_wrapper';

-- src/query_dsl/term.rs:82
-- zombodb::query_dsl::term::dsl::term
CREATE  FUNCTION dsl."term"(
	"field" TEXT, /* &str */
	"value" double precision, /* f64 */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'term_f64_wrapper';

-- src/query_dsl/span.rs:6
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::span::dsl */

-- src/query_dsl/span.rs:162
-- zombodb::query_dsl::span::dsl::span_within
CREATE  FUNCTION dsl."span_within"(
	"little" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"big" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'span_within_wrapper';

-- src/query_dsl/span.rs:14
-- zombodb::query_dsl::span::dsl::span_containing
CREATE  FUNCTION dsl."span_containing"(
	"little" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"big" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'span_containing_wrapper';

-- src/query_dsl/span.rs:145
-- zombodb::query_dsl::span::dsl::span_term
CREATE  FUNCTION dsl."span_term"(
	"field" TEXT, /* &str */
	"value" TEXT, /* &str */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'span_term_wrapper';

-- src/query_dsl/span.rs:94
-- zombodb::query_dsl::span::dsl::span_not
CREATE  FUNCTION dsl."span_not"(
	"include" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"exclude" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"pre_integer" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"post_integer" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"dis_integer" bigint DEFAULT NULL /* core::option::Option<i64> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'span_not_wrapper';

-- src/query_dsl/span.rs:119
-- zombodb::query_dsl::span::dsl::span_or
CREATE  FUNCTION dsl."span_or"(
	"clauses" VARIADIC pg_catalog.ZDBQuery[] /* pgrx::datum::array::VariadicArray<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'span_or_wrapper';

-- src/query_dsl/span.rs:56
-- zombodb::query_dsl::span::dsl::span_near
CREATE  FUNCTION dsl."span_near"(
	"in_order" bool, /* bool */
	"slop" bigint, /* i64 */
	"clauses" VARIADIC pg_catalog.ZDBQuery[] /* pgrx::datum::array::VariadicArray<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'span_near_wrapper';

-- src/query_dsl/span.rs:36
-- zombodb::query_dsl::span::dsl::span_masking
CREATE  FUNCTION dsl."span_masking"(
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'span_masking_wrapper';

-- src/query_dsl/span.rs:26
-- zombodb::query_dsl::span::dsl::span_first
CREATE  FUNCTION dsl."span_first"(
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"end" bigint /* i64 */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'span_first_wrapper';

-- src/query_dsl/span.rs:47
-- zombodb::query_dsl::span::dsl::span_multi
CREATE  FUNCTION dsl."span_multi"(
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'span_multi_wrapper';

-- src/query_dsl/sort.rs:6
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::sort::dsl */

-- src/query_dsl/sort.rs:31
-- zombodb::query_dsl::sort::dsl::sd_nested
CREATE  FUNCTION dsl."sd_nested"(
	"field" TEXT, /* &str */
	"order" pg_catalog.SortDirection, /* zombodb::zdbquery::pg_catalog::SortDirection */
	"nested_path" TEXT, /* &str */
	"nested_filter" pg_catalog.ZDBQuery DEFAULT NULL, /* core::option::Option<zombodb::zdbquery::pg_catalog::ZDBQuery> */
	"mode" pg_catalog.SortMode DEFAULT NULL /* core::option::Option<zombodb::zdbquery::pg_catalog::SortMode> */
) RETURNS pg_catalog.SortDescriptor /* zombodb::zdbquery::pg_catalog::SortDescriptor */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sd_nested_wrapper';

-- src/query_dsl/sort.rs:67
-- zombodb::query_dsl::sort::dsl::sort_many
CREATE  FUNCTION dsl."sort_many"(
	"zdbquery" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"sort_descriptors" VARIADIC pg_catalog.SortDescriptor[] /* pgrx::datum::array::VariadicArray<zombodb::zdbquery::pg_catalog::SortDescriptor> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sort_many_wrapper';

-- src/query_dsl/sort.rs:54
-- zombodb::query_dsl::sort::dsl::sort
CREATE  FUNCTION dsl."sort"(
	"sort_field" TEXT, /* &str */
	"sort_direction" pg_catalog.SortDirection, /* zombodb::zdbquery::pg_catalog::SortDirection */
	"zdbquery" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sort_wrapper';

-- src/query_dsl/sort.rs:72
-- zombodb::query_dsl::sort::dsl::sort_direct
CREATE  FUNCTION dsl."sort_direct"(
	"sort_json" json, /* pgrx::datum::json::Json */
	"zdbquery" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sort_direct_wrapper';

-- src/query_dsl/sort.rs:14
-- zombodb::query_dsl::sort::dsl::sd
CREATE  FUNCTION dsl."sd"(
	"field" TEXT, /* &str */
	"order" pg_catalog.SortDirection, /* zombodb::zdbquery::pg_catalog::SortDirection */
	"mode" pg_catalog.SortMode DEFAULT NULL /* core::option::Option<zombodb::zdbquery::pg_catalog::SortMode> */
) RETURNS pg_catalog.SortDescriptor /* zombodb::zdbquery::pg_catalog::SortDescriptor */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sd_wrapper';

-- src/query_dsl/range.rs:1
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::range::dsl */

-- src/query_dsl/range.rs:62
-- zombodb::query_dsl::range::dsl::range
CREATE  FUNCTION dsl."range"(
	"field" TEXT, /* &str */
	"lt" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"gt" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"lte" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"gte" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'range_numeric_wrapper';

-- src/query_dsl/range.rs:37
-- zombodb::query_dsl::range::dsl::range
CREATE  FUNCTION dsl."range"(
	"field" TEXT, /* &str */
	"lt" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"gt" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"lte" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"gte" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'range_str_wrapper';

-- src/query_dsl/query_string.rs:7
-- zombodb::query_dsl::query_string::pg_catalog::QueryStringDefaultOperator
CREATE TYPE pg_catalog.QueryStringDefaultOperator AS ENUM (
	'and',
	'or'
);

-- src/query_dsl/query_string.rs:14
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::query_string::dsl */

-- src/query_dsl/query_string.rs:68
-- zombodb::query_dsl::query_string::dsl::query_string
CREATE  FUNCTION dsl."query_string"(
	"query" TEXT, /* &str */
	"default_field" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"allow_leading_wildcard" bool DEFAULT NULL, /* core::option::Option<bool> */
	"analyze_wildcard" bool DEFAULT NULL, /* core::option::Option<bool> */
	"analyzer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"auto_generate_synonyms_phrase_query" bool DEFAULT NULL, /* core::option::Option<bool> */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"default_operator" pg_catalog.QueryStringDefaultOperator DEFAULT NULL, /* core::option::Option<zombodb::query_dsl::query_string::pg_catalog::QueryStringDefaultOperator> */
	"enable_position_increments" bool DEFAULT NULL, /* core::option::Option<bool> */
	"fields" TEXT[] DEFAULT NULL, /* core::option::Option<pgrx::datum::array::Array<&str>> */
	"fuzziness" INT DEFAULT NULL, /* core::option::Option<i32> */
	"fuzzy_max_expansions" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"fuzzy_transpositions" bool DEFAULT NULL, /* core::option::Option<bool> */
	"fuzzy_prefix_length" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"lenient" bool DEFAULT NULL, /* core::option::Option<bool> */
	"max_determinized_states" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"minimum_should_match" INT DEFAULT NULL, /* core::option::Option<i32> */
	"quote_analyzer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"phrase_slop" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"quote_field_suffix" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"time_zone" TEXT DEFAULT NULL /* core::option::Option<&str> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'query_string_wrapper';

-- src/query_dsl/prefix.rs:6
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::prefix::dsl */

-- src/query_dsl/prefix.rs:13
-- zombodb::query_dsl::prefix::dsl::prefix
CREATE  FUNCTION dsl."prefix"(
	"field" TEXT, /* &str */
	"value" TEXT /* &str */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'prefix_wrapper';

-- src/query_dsl/nested.rs:7
-- zombodb::query_dsl::nested::pg_catalog::ScoreMode
CREATE TYPE pg_catalog.ScoreMode AS ENUM (
	'avg',
	'sum',
	'min',
	'max',
	'none'
);

-- src/query_dsl/nested.rs:17
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::nested::dsl */

-- src/query_dsl/nested.rs:24
-- zombodb::query_dsl::nested::dsl::nested
CREATE  FUNCTION dsl."nested"(
	"path" TEXT, /* alloc::string::String */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"score_mode" pg_catalog.ScoreMode DEFAULT 'avg', /* zombodb::query_dsl::nested::pg_catalog::ScoreMode */
	"ignore_unmapped" bool DEFAULT NULL /* core::option::Option<bool> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'nested_wrapper';

-- src/query_dsl/more_like_this.rs:1
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::more_like_this::dsl */

-- src/query_dsl/more_like_this.rs:117
-- zombodb::query_dsl::more_like_this::dsl::more_like_this
CREATE  FUNCTION dsl."more_like_this"(
	"like" TEXT, /* &str */
	"fields" TEXT[] DEFAULT NULL, /* core::option::Option<pgrx::datum::array::Array<&str>> */
	"stop_words" TEXT[] DEFAULT ARRAY['http', 'span', 'class', 'flashtext', 'let', 'its', 'may', 'well', 'got', 'too', 'them', 'really', 'new', 'set', 'please', 'how', 'our', 'from', 'sent', 'subject', 'sincerely', 'thank', 'thanks', 'just', 'get', 'going', 'were', 'much', 'can', 'also', 'she', 'her', 'him', 'his', 'has', 'been', 'ok', 'still', 'okay', 'does', 'did', 'about', 'yes', 'you', 'your', 'when', 'know', 'have', 'who', 'what', 'where', 'sir', 'page', 'a', 'an', 'and', 'are', 'as', 'at', 'be', 'but', 'by', 'for', 'if', 'in', 'into', 'is', 'it', 'no', 'not', 'of', 'on', 'or', 'such', 'that', 'the', 'their', 'than', 'then', 'there', 'these', 'they', 'this', 'to', 'was', 'will', 'with'], /* pgrx::datum::array::Array<&str> */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"unlike" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"analyzer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"minimum_should_match" INT DEFAULT NULL, /* core::option::Option<i32> */
	"boost_terms" real DEFAULT NULL, /* core::option::Option<f32> */
	"include" bool DEFAULT NULL, /* core::option::Option<bool> */
	"min_term_freq" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"max_query_terms" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"min_doc_freq" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"max_doc_freq" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"min_word_length" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"max_word_length" bigint DEFAULT NULL /* core::option::Option<i64> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'more_like_this_without_array_wrapper';

-- src/query_dsl/more_like_this.rs:73
-- zombodb::query_dsl::more_like_this::dsl::more_like_this
CREATE  FUNCTION dsl."more_like_this"(
	"like" TEXT[], /* pgrx::datum::array::Array<&str> */
	"stop_words" TEXT[] DEFAULT ARRAY['http', 'span', 'class', 'flashtext', 'let', 'its', 'may', 'well', 'got', 'too', 'them', 'really', 'new', 'set', 'please', 'how', 'our', 'from', 'sent', 'subject', 'sincerely', 'thank', 'thanks', 'just', 'get', 'going', 'were', 'much', 'can', 'also', 'she', 'her', 'him', 'his', 'has', 'been', 'ok', 'still', 'okay', 'does', 'did', 'about', 'yes', 'you', 'your', 'when', 'know', 'have', 'who', 'what', 'where', 'sir', 'page', 'a', 'an', 'and', 'are', 'as', 'at', 'be', 'but', 'by', 'for', 'if', 'in', 'into', 'is', 'it', 'no', 'not', 'of', 'on', 'or', 'such', 'that', 'the', 'their', 'than', 'then', 'there', 'these', 'they', 'this', 'to', 'was', 'will', 'with'], /* pgrx::datum::array::Array<&str> */
	"fields" TEXT[] DEFAULT NULL, /* core::option::Option<pgrx::datum::array::Array<&str>> */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"unlike" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"analyzer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"minimum_should_match" INT DEFAULT NULL, /* core::option::Option<i32> */
	"boost_terms" real DEFAULT NULL, /* core::option::Option<f32> */
	"include" bool DEFAULT NULL, /* core::option::Option<bool> */
	"min_term_freq" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"max_query_terms" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"min_doc_freq" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"max_doc_freq" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"min_word_length" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"max_word_length" bigint DEFAULT NULL /* core::option::Option<i64> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'more_like_this_with_array_wrapper';

-- src/query_dsl/misc.rs:12
-- zombodb::query_dsl::misc::pg_catalog::RegexFlags
CREATE TYPE pg_catalog.RegexFlags AS ENUM (
	'all',
	'complement',
	'interval',
	'intersection',
	'anystring'
);

-- src/query_dsl/misc.rs:22
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::misc::dsl */

-- src/query_dsl/misc.rs:50
-- zombodb::query_dsl::misc::dsl::wildcard
CREATE  FUNCTION dsl."wildcard"(
	"field" TEXT, /* &str */
	"value" TEXT, /* &str */
	"boost" real DEFAULT 1.0 /* f32 */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'wildcard_wrapper';

-- src/query_dsl/misc.rs:64
-- zombodb::query_dsl::misc::dsl::regexp
CREATE  FUNCTION dsl."regexp"(
	"field" TEXT, /* &str */
	"regexp" TEXT, /* &str */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"flags" pg_catalog.RegexFlags[] DEFAULT NULL, /* core::option::Option<pgrx::datum::array::Array<zombodb::query_dsl::misc::pg_catalog::RegexFlags>> */
	"max_determinized_states" INT DEFAULT NULL /* core::option::Option<i32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'regexp_wrapper';

-- src/query_dsl/misc.rs:87
-- zombodb::query_dsl::misc::dsl::script
CREATE  FUNCTION dsl."script"(
	"source" TEXT, /* &str */
	"params" json DEFAULT NULL, /* core::option::Option<pgrx::datum::json::Json> */
	"lang" TEXT DEFAULT 'painless' /* &str */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'script_wrapper';

-- src/query_dsl/matches.rs:14
-- zombodb::query_dsl::matches::pg_catalog::Operator
CREATE TYPE pg_catalog.Operator AS ENUM (
	'and',
	'or'
);

-- src/query_dsl/matches.rs:7
-- zombodb::query_dsl::matches::pg_catalog::ZeroTermsQuery
CREATE TYPE pg_catalog.ZeroTermsQuery AS ENUM (
	'none',
	'all'
);

-- src/query_dsl/matches.rs:21
-- zombodb::query_dsl::matches::pg_catalog::MatchType
CREATE TYPE pg_catalog.MatchType AS ENUM (
	'best_fields',
	'most_fields',
	'cross_fields',
	'phrase',
	'phrase_prefix'
);

-- src/query_dsl/matches.rs:31
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::matches::dsl */

-- src/query_dsl/matches.rs:213
-- zombodb::query_dsl::matches::dsl::match_phrase
CREATE  FUNCTION dsl."match_phrase"(
	"field" TEXT, /* &str */
	"query" TEXT, /* &str */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"slop" INT DEFAULT NULL, /* core::option::Option<i32> */
	"analyzer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"zero_terms_query" pg_catalog.ZeroTermsQuery DEFAULT NULL /* core::option::Option<zombodb::query_dsl::matches::pg_catalog::ZeroTermsQuery> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'match_phrase_wrapper';

-- src/query_dsl/matches.rs:130
-- zombodb::query_dsl::matches::dsl::match
CREATE  FUNCTION dsl."match"(
	"field" TEXT, /* &str */
	"query" TEXT, /* &str */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"analyzer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"minimum_should_match" INT DEFAULT NULL, /* core::option::Option<i32> */
	"lenient" bool DEFAULT NULL, /* core::option::Option<bool> */
	"fuzziness" INT DEFAULT NULL, /* core::option::Option<i32> */
	"fuzzy_rewrite" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"fuzzy_transpositions" bool DEFAULT NULL, /* core::option::Option<bool> */
	"prefix_length" INT DEFAULT NULL, /* core::option::Option<i32> */
	"cutoff_frequency" real DEFAULT NULL, /* core::option::Option<f32> */
	"auto_generate_synonyms_phrase_query" bool DEFAULT NULL, /* core::option::Option<bool> */
	"zero_terms_query" pg_catalog.ZeroTermsQuery DEFAULT NULL, /* core::option::Option<zombodb::query_dsl::matches::pg_catalog::ZeroTermsQuery> */
	"operator" pg_catalog.Operator DEFAULT NULL /* core::option::Option<zombodb::query_dsl::matches::pg_catalog::Operator> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'match_wrapper_wrapper';

-- src/query_dsl/matches.rs:171
-- zombodb::query_dsl::matches::dsl::multi_match
CREATE  FUNCTION dsl."multi_match"(
	"fields" TEXT[], /* pgrx::datum::array::Array<&str> */
	"query" TEXT, /* &str */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"analyzer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"minimum_should_match" INT DEFAULT NULL, /* core::option::Option<i32> */
	"lenient" bool DEFAULT NULL, /* core::option::Option<bool> */
	"fuzziness" INT DEFAULT NULL, /* core::option::Option<i32> */
	"fuzzy_rewrite" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"fuzzy_transpositions" bool DEFAULT NULL, /* core::option::Option<bool> */
	"prefix_length" INT DEFAULT NULL, /* core::option::Option<i32> */
	"cutoff_frequency" real DEFAULT NULL, /* core::option::Option<f32> */
	"auto_generate_synonyms_phrase_query" bool DEFAULT NULL, /* core::option::Option<bool> */
	"zero_terms_query" pg_catalog.ZeroTermsQuery DEFAULT NULL, /* core::option::Option<zombodb::query_dsl::matches::pg_catalog::ZeroTermsQuery> */
	"operator" pg_catalog.Operator DEFAULT NULL, /* core::option::Option<zombodb::query_dsl::matches::pg_catalog::Operator> */
	"match_type" pg_catalog.MatchType DEFAULT NULL /* core::option::Option<zombodb::query_dsl::matches::pg_catalog::MatchType> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'multi_match_wrapper';

-- src/query_dsl/matches.rs:238
-- zombodb::query_dsl::matches::dsl::phrase
CREATE  FUNCTION dsl."phrase"(
	"field" TEXT, /* &str */
	"query" TEXT, /* &str */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"slop" INT DEFAULT NULL, /* core::option::Option<i32> */
	"analyzer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"zero_terms_query" pg_catalog.ZeroTermsQuery DEFAULT NULL /* core::option::Option<zombodb::query_dsl::matches::pg_catalog::ZeroTermsQuery> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'phrase_wrapper';

-- src/query_dsl/matches.rs:250
-- zombodb::query_dsl::matches::dsl::match_phrase_prefix
CREATE  FUNCTION dsl."match_phrase_prefix"(
	"field" TEXT, /* &str */
	"query" TEXT, /* &str */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"slop" INT DEFAULT NULL, /* core::option::Option<i32> */
	"analyzer" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"maxexpansion" INT DEFAULT NULL, /* core::option::Option<i32> */
	"zero_terms_query" pg_catalog.ZeroTermsQuery DEFAULT NULL /* core::option::Option<zombodb::query_dsl::matches::pg_catalog::ZeroTermsQuery> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'match_phrase_prefix_wrapper';

-- src/query_dsl/match_all.rs:6
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::match_all::dsl */

-- src/query_dsl/match_all.rs:13
-- zombodb::query_dsl::match_all::dsl::match_all
CREATE  FUNCTION dsl."match_all"(
	"boost" real DEFAULT 1.0 /* f32 */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'match_all_wrapper';

-- src/query_dsl/match_all.rs:30
-- zombodb::query_dsl::match_all::dsl::match_none
CREATE  FUNCTION dsl."match_none"() RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'match_none_wrapper';

-- src/query_dsl/limit.rs:1
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::limit::dsl */

-- src/query_dsl/limit.rs:7
-- zombodb::query_dsl::limit::dsl::limit
CREATE  FUNCTION dsl."limit"(
	"limit" bigint, /* i64 */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'limit_wrapper';

-- src/query_dsl/limit.rs:15
-- zombodb::query_dsl::limit::dsl::offset
CREATE  FUNCTION dsl."offset"(
	"offset" bigint, /* i64 */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'offset_wrapper';

-- src/query_dsl/limit.rs:23
-- zombodb::query_dsl::limit::dsl::offset_limit
CREATE  FUNCTION dsl."offset_limit"(
	"offset" bigint, /* i64 */
	"limit" bigint, /* i64 */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'offset_limit_wrapper';

-- src/query_dsl/limit.rs:29
-- zombodb::query_dsl::limit::dsl::min_score
CREATE  FUNCTION dsl."min_score"(
	"min_score" double precision, /* f64 */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_score_wrapper';

-- src/query_dsl/limit.rs:34
-- zombodb::query_dsl::limit::dsl::row_estimate
CREATE  FUNCTION dsl."row_estimate"(
	"row_estimate" bigint, /* i64 */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'row_estimate_wrapper';

-- src/query_dsl/geo.rs:9
-- zombodb::query_dsl::geo::pg_catalog::GeoShapeRelation
CREATE TYPE pg_catalog.GeoShapeRelation AS ENUM (
	'INTERSECTS',
	'DISJOINT',
	'WITHIN',
	'CONTAINS'
);

-- src/query_dsl/geo.rs:18
-- zombodb::query_dsl::geo::pg_catalog::GeoBoundingBoxType
CREATE TYPE pg_catalog.GeoBoundingBoxType AS ENUM (
	'indexed',
	'memory'
);

-- src/query_dsl/geo.rs:43
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::geo::dsl */

-- src/query_dsl/geo.rs:90
-- zombodb::query_dsl::geo::dsl::geo_polygon
CREATE  FUNCTION dsl."geo_polygon"(
	"field" TEXT, /* &str */
	"points" VARIADIC point[] /* pgrx::datum::array::VariadicArray<pgrx_pg_sys::pg14::Point> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'geo_polygon_wrapper';

-- src/query_dsl/geo.rs:52
-- zombodb::query_dsl::geo::dsl::geo_shape
CREATE  FUNCTION dsl."geo_shape"(
	"field" TEXT, /* &str */
	"geojson_shape" json, /* pgrx::datum::json::Json */
	"relation" pg_catalog.GeoShapeRelation /* zombodb::query_dsl::geo::pg_catalog::GeoShapeRelation */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'geo_shape_wrapper';

-- src/query_dsl/geo.rs:66
-- zombodb::query_dsl::geo::dsl::geo_bounding_box
CREATE  FUNCTION dsl."geo_bounding_box"(
	"field" TEXT, /* &str */
	"bounding_box" box, /* pgrx_pg_sys::pg14::BOX */
	"box_type" pg_catalog.GeoBoundingBoxType DEFAULT 'memory' /* zombodb::query_dsl::geo::pg_catalog::GeoBoundingBoxType */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'geo_bounding_box_wrapper';

-- src/query_dsl/fuzzy.rs:1
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::fuzzy::dsl */

-- src/query_dsl/fuzzy.rs:24
-- zombodb::query_dsl::fuzzy::dsl::fuzzy
CREATE  FUNCTION dsl."fuzzy"(
	"field" TEXT, /* &str */
	"value" TEXT, /* &str */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"fuzziness" INT DEFAULT NULL, /* core::option::Option<i32> */
	"prefix_length" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"max_expansions" bigint DEFAULT 50, /* core::option::Option<i64> */
	"transpositions" bool DEFAULT NULL /* core::option::Option<bool> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'fuzzy_wrapper';

-- src/query_dsl/field_missing.rs:6
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::field_missing::dsl */

-- src/query_dsl/field_missing.rs:13
-- zombodb::query_dsl::field_missing::dsl::field_missing
CREATE  FUNCTION dsl."field_missing"(
	"field" TEXT /* &str */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'field_missing_wrapper';

-- src/query_dsl/field_exists.rs:6
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::field_exists::dsl */

-- src/query_dsl/field_exists.rs:13
-- zombodb::query_dsl::field_exists::dsl::field_exists
CREATE  FUNCTION dsl."field_exists"(
	"field" TEXT /* &str */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'field_exists_wrapper';

-- src/query_dsl/datetime_range.rs:7
-- zombodb::query_dsl::datetime_range::pg_catalog::Relation
CREATE TYPE pg_catalog.Relation AS ENUM (
	'intersects',
	'contains',
	'within'
);

-- src/query_dsl/datetime_range.rs:15
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::datetime_range::dsl */

-- src/query_dsl/datetime_range.rs:84
-- zombodb::query_dsl::datetime_range::dsl::datetime_range
CREATE  FUNCTION dsl."datetime_range"(
	"field" TEXT, /* &str */
	"lt" timestamp DEFAULT NULL, /* core::option::Option<pgrx::datum::time_stamp::Timestamp> */
	"gt" timestamp DEFAULT NULL, /* core::option::Option<pgrx::datum::time_stamp::Timestamp> */
	"lte" timestamp DEFAULT NULL, /* core::option::Option<pgrx::datum::time_stamp::Timestamp> */
	"gte" timestamp DEFAULT NULL, /* core::option::Option<pgrx::datum::time_stamp::Timestamp> */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"relation" pg_catalog.Relation DEFAULT 'intersects' /* core::option::Option<zombodb::query_dsl::datetime_range::pg_catalog::Relation> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'datetime_range_time_stamp_wrapper';

-- src/query_dsl/datetime_range.rs:63
-- zombodb::query_dsl::datetime_range::dsl::datetime_range
CREATE  FUNCTION dsl."datetime_range"(
	"field" TEXT, /* &str */
	"lt" time DEFAULT NULL, /* core::option::Option<pgrx::datum::time::Time> */
	"gt" time DEFAULT NULL, /* core::option::Option<pgrx::datum::time::Time> */
	"lte" time DEFAULT NULL, /* core::option::Option<pgrx::datum::time::Time> */
	"gte" time DEFAULT NULL, /* core::option::Option<pgrx::datum::time::Time> */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"relation" pg_catalog.Relation DEFAULT 'intersects' /* core::option::Option<zombodb::query_dsl::datetime_range::pg_catalog::Relation> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'datetime_range_time_wrapper';

-- src/query_dsl/datetime_range.rs:42
-- zombodb::query_dsl::datetime_range::dsl::datetime_range
CREATE  FUNCTION dsl."datetime_range"(
	"field" TEXT, /* &str */
	"lt" date DEFAULT NULL, /* core::option::Option<pgrx::datum::date::Date> */
	"gt" date DEFAULT NULL, /* core::option::Option<pgrx::datum::date::Date> */
	"lte" date DEFAULT NULL, /* core::option::Option<pgrx::datum::date::Date> */
	"gte" date DEFAULT NULL, /* core::option::Option<pgrx::datum::date::Date> */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"relation" pg_catalog.Relation DEFAULT 'intersects' /* core::option::Option<zombodb::query_dsl::datetime_range::pg_catalog::Relation> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'datetime_range_date_wrapper';

-- src/query_dsl/datetime_range.rs:126
-- zombodb::query_dsl::datetime_range::dsl::datetime_range
CREATE  FUNCTION dsl."datetime_range"(
	"field" TEXT, /* &str */
	"lt" time with time zone DEFAULT NULL, /* core::option::Option<pgrx::datum::time_with_timezone::TimeWithTimeZone> */
	"gt" time with time zone DEFAULT NULL, /* core::option::Option<pgrx::datum::time_with_timezone::TimeWithTimeZone> */
	"lte" time with time zone DEFAULT NULL, /* core::option::Option<pgrx::datum::time_with_timezone::TimeWithTimeZone> */
	"gte" time with time zone DEFAULT NULL, /* core::option::Option<pgrx::datum::time_with_timezone::TimeWithTimeZone> */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"relation" pg_catalog.Relation DEFAULT 'intersects' /* core::option::Option<zombodb::query_dsl::datetime_range::pg_catalog::Relation> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'datetime_range_time_with_timezone_wrapper';

-- src/query_dsl/datetime_range.rs:105
-- zombodb::query_dsl::datetime_range::dsl::datetime_range
CREATE  FUNCTION dsl."datetime_range"(
	"field" TEXT, /* &str */
	"lt" timestamp with time zone DEFAULT NULL, /* core::option::Option<pgrx::datum::time_stamp_with_timezone::TimestampWithTimeZone> */
	"gt" timestamp with time zone DEFAULT NULL, /* core::option::Option<pgrx::datum::time_stamp_with_timezone::TimestampWithTimeZone> */
	"lte" timestamp with time zone DEFAULT NULL, /* core::option::Option<pgrx::datum::time_stamp_with_timezone::TimestampWithTimeZone> */
	"gte" timestamp with time zone DEFAULT NULL, /* core::option::Option<pgrx::datum::time_stamp_with_timezone::TimestampWithTimeZone> */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"relation" pg_catalog.Relation DEFAULT 'intersects' /* core::option::Option<zombodb::query_dsl::datetime_range::pg_catalog::Relation> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'datetime_range_timestamp_with_timezone_wrapper';

-- src/query_dsl/constant_score.rs:1
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::constant_score::dsl */

-- src/query_dsl/constant_score.rs:13
-- zombodb::query_dsl::constant_score::dsl::boosting
CREATE  FUNCTION dsl."boosting"(
	"positive_query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"negative_query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"negative_boost" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'boosting_wrapper';

-- src/query_dsl/constant_score.rs:7
-- zombodb::query_dsl::constant_score::dsl::constant_score
CREATE  FUNCTION dsl."constant_score"(
	"boost" real, /* f32 */
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'constant_score_wrapper';

-- src/query_dsl/constant_score.rs:26
-- zombodb::query_dsl::constant_score::dsl::dis_max
CREATE  FUNCTION dsl."dis_max"(
	"queries" pg_catalog.ZDBQuery[], /* pgrx::datum::array::Array<zombodb::zdbquery::pg_catalog::ZDBQuery> */
	"boost" real DEFAULT NULL, /* core::option::Option<f32> */
	"tie_breaker" real DEFAULT NULL /* core::option::Option<f32> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'dis_max_wrapper';

-- src/query_dsl/bool.rs:7
-- zombodb::query_dsl::bool::pg_catalog::BoolQueryPart
CREATE TYPE pg_catalog.BoolQueryPart;

-- src/query_dsl/bool.rs:7
-- zombodb::query_dsl::bool::pg_catalog::boolquerypart_in
CREATE  FUNCTION pg_catalog."boolquerypart_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS pg_catalog.BoolQueryPart /* core::option::Option<zombodb::query_dsl::bool::pg_catalog::BoolQueryPart> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'boolquerypart_in_wrapper';

-- src/query_dsl/bool.rs:7
-- zombodb::query_dsl::bool::pg_catalog::boolquerypart_out
CREATE  FUNCTION pg_catalog."boolquerypart_out"(
	"input" pg_catalog.BoolQueryPart /* zombodb::query_dsl::bool::pg_catalog::BoolQueryPart */
) RETURNS cstring /* &core::ffi::c_str::CStr */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'boolquerypart_out_wrapper';

-- src/query_dsl/bool.rs:7
-- zombodb::query_dsl::bool::pg_catalog::BoolQueryPart
CREATE TYPE pg_catalog.BoolQueryPart (
	INTERNALLENGTH = variable,
	INPUT = pg_catalog.boolquerypart_in, /* zombodb::query_dsl::bool::pg_catalog::boolquerypart_in */
	OUTPUT = pg_catalog.boolquerypart_out, /* zombodb::query_dsl::bool::pg_catalog::boolquerypart_out */
	STORAGE = extended
);

-- src/query_dsl/bool.rs:11
CREATE SCHEMA IF NOT EXISTS dsl; /* zombodb::query_dsl::bool::dsl */

-- src/query_dsl/bool.rs:134
-- zombodb::query_dsl::bool::dsl::and
CREATE  FUNCTION dsl."and"(
	"queries" VARIADIC pg_catalog.ZDBQuery[] /* pgrx::datum::array::VariadicArray<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'and_wrapper';

-- src/query_dsl/bool.rs:172
-- zombodb::query_dsl::bool::dsl::or
CREATE  FUNCTION dsl."or"(
	"queries" VARIADIC pg_catalog.ZDBQuery[] /* pgrx::datum::array::VariadicArray<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'or_wrapper';

-- src/query_dsl/bool.rs:46
-- zombodb::query_dsl::bool::dsl::should
CREATE  FUNCTION dsl."should"(
	"queries" VARIADIC pg_catalog.ZDBQuery[] /* pgrx::datum::array::VariadicArray<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS pg_catalog.BoolQueryPart /* zombodb::query_dsl::bool::pg_catalog::BoolQueryPart */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'should_wrapper';

-- src/query_dsl/bool.rs:210
-- zombodb::query_dsl::bool::dsl::noteq
CREATE  FUNCTION dsl."noteq"(
	"query" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'noteq_wrapper';

-- src/query_dsl/bool.rs:103
-- zombodb::query_dsl::bool::dsl::filter
CREATE  FUNCTION dsl."filter"(
	"queries" VARIADIC pg_catalog.ZDBQuery[] /* pgrx::datum::array::VariadicArray<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS pg_catalog.BoolQueryPart /* zombodb::query_dsl::bool::pg_catalog::BoolQueryPart */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'filter_wrapper';

-- src/query_dsl/bool.rs:191
-- zombodb::query_dsl::bool::dsl::not
CREATE  FUNCTION dsl."not"(
	"queries" VARIADIC pg_catalog.ZDBQuery[] /* pgrx::datum::array::VariadicArray<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'not_wrapper';

-- src/query_dsl/bool.rs:122
-- zombodb::query_dsl::bool::dsl::binary_and
CREATE  FUNCTION dsl."binary_and"(
	"a" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"b" pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'binary_and_wrapper';

-- src/query_dsl/bool.rs:18
-- zombodb::query_dsl::bool::dsl::bool
CREATE  FUNCTION dsl."bool"(
	"parts" VARIADIC pg_catalog.BoolQueryPart[] /* pgrx::datum::array::VariadicArray<zombodb::query_dsl::bool::pg_catalog::BoolQueryPart> */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'bool_wrapper';

-- src/query_dsl/bool.rs:65
-- zombodb::query_dsl::bool::dsl::must
CREATE  FUNCTION dsl."must"(
	"queries" VARIADIC pg_catalog.ZDBQuery[] /* pgrx::datum::array::VariadicArray<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS pg_catalog.BoolQueryPart /* zombodb::query_dsl::bool::pg_catalog::BoolQueryPart */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_wrapper';

-- src/query_dsl/bool.rs:84
-- zombodb::query_dsl::bool::dsl::must_not
CREATE  FUNCTION dsl."must_not"(
	"queries" VARIADIC pg_catalog.ZDBQuery[] /* pgrx::datum::array::VariadicArray<zombodb::zdbquery::pg_catalog::ZDBQuery> */
) RETURNS pg_catalog.BoolQueryPart /* zombodb::query_dsl::bool::pg_catalog::BoolQueryPart */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_not_wrapper';

-- src/highlighting/es_highlighting.rs:36
-- zombodb::highlighting::es_highlighting::pg_catalog::BoundaryScannerType
CREATE TYPE pg_catalog.BoundaryScannerType AS ENUM (
	'chars',
	'sentence',
	'word'
);

-- src/highlighting/es_highlighting.rs:14
-- zombodb::highlighting::es_highlighting::pg_catalog::HighlightType
CREATE TYPE pg_catalog.HighlightType AS ENUM (
	'unified',
	'plain',
	'fvh'
);

-- src/highlighting/es_highlighting.rs:29
-- zombodb::highlighting::es_highlighting::pg_catalog::EncoderType
CREATE TYPE pg_catalog.EncoderType AS ENUM (
	'default',
	'html'
);

-- src/highlighting/es_highlighting.rs:22
-- zombodb::highlighting::es_highlighting::pg_catalog::FragmenterType
CREATE TYPE pg_catalog.FragmenterType AS ENUM (
	'simple',
	'span'
);

-- src/highlighting/es_highlighting.rs:45
-- zombodb::highlighting::es_highlighting::highlight
CREATE  FUNCTION zdb."highlight"(
	"highlight_type" pg_catalog.HighlightType DEFAULT NULL, /* core::option::Option<zombodb::highlighting::es_highlighting::pg_catalog::HighlightType> */
	"require_field_match" bool DEFAULT false, /* core::option::Option<bool> */
	"number_of_fragments" INT DEFAULT NULL, /* core::option::Option<i32> */
	"highlight_query" pg_catalog.ZDBQuery DEFAULT NULL, /* core::option::Option<zombodb::zdbquery::pg_catalog::ZDBQuery> */
	"pre_tags" TEXT[] DEFAULT NULL, /* core::option::Option<alloc::vec::Vec<core::option::Option<alloc::string::String>>> */
	"post_tags" TEXT[] DEFAULT NULL, /* core::option::Option<alloc::vec::Vec<core::option::Option<alloc::string::String>>> */
	"tags_schema" TEXT DEFAULT NULL, /* core::option::Option<alloc::string::String> */
	"no_match_size" INT DEFAULT NULL, /* core::option::Option<i32> */
	"fragmenter" pg_catalog.FragmenterType DEFAULT NULL, /* core::option::Option<zombodb::highlighting::es_highlighting::pg_catalog::FragmenterType> */
	"fragment_size" INT DEFAULT NULL, /* core::option::Option<i32> */
	"fragment_offset" INT DEFAULT NULL, /* core::option::Option<i32> */
	"force_source" bool DEFAULT true, /* core::option::Option<bool> */
	"encoder" pg_catalog.EncoderType DEFAULT NULL, /* core::option::Option<zombodb::highlighting::es_highlighting::pg_catalog::EncoderType> */
	"boundary_scanner_locale" TEXT DEFAULT NULL, /* core::option::Option<alloc::string::String> */
	"boundary_scan_max" INT DEFAULT NULL, /* core::option::Option<i32> */
	"boundary_chars" TEXT DEFAULT NULL, /* core::option::Option<alloc::string::String> */
	"phrase_limit" INT DEFAULT NULL, /* core::option::Option<i32> */
	"matched_fields" bool DEFAULT NULL, /* core::option::Option<bool> */
	"order" TEXT DEFAULT NULL /* core::option::Option<alloc::string::String> */
) RETURNS json /* pgrx::datum::json::Json */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_wrapper';

-- src/highlighting/es_highlighting.rs:135
-- zombodb::highlighting::es_highlighting::highlight
-- requires:
--   highlighting::es_highlighting::highlight
CREATE  FUNCTION zdb."highlight"(
	"ctid" tid, /* pgrx_pg_sys::pg14::ItemPointerData */
	"field" TEXT, /* &str */
	"_highlight_definition" json DEFAULT zdb.highlight() /* pgrx::datum::json::Json */
) RETURNS TEXT[] /* core::option::Option<alloc::vec::Vec<core::option::Option<&alloc::string::String>>> */
IMMUTABLE STRICT PARALLEL SAFE  
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_field_wrapper';

-- src/highlighting/es_highlighting.rs:164
-- zombodb::highlighting::es_highlighting::highlight_all_fields
-- requires:
--   highlighting::es_highlighting::highlight
CREATE  FUNCTION zdb."highlight_all_fields"(
	"ctid" tid, /* pgrx_pg_sys::pg14::ItemPointerData */
	"_highlight_definition" json DEFAULT zdb.highlight() /* pgrx::datum::json::Json */
) RETURNS json /* pgrx::datum::json::Json */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'highlight_all_fields_wrapper';

-- src/highlighting/es_highlighting.rs:186
-- zombodb::highlighting::es_highlighting::want_highlight
-- requires:
--   highlighting::es_highlighting::highlight
CREATE  FUNCTION zdb."want_highlight"(
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"field" TEXT, /* alloc::string::String */
	"highlight_definition" json DEFAULT zdb.highlight() /* pgrx::datum::json::Json */
) RETURNS pg_catalog.ZDBQuery /* zombodb::zdbquery::pg_catalog::ZDBQuery */
IMMUTABLE STRICT PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'want_highlight_wrapper';

-- src/elasticsearch/mod.rs:66
-- zombodb::elasticsearch::pg_catalog::ArbitraryRequestType
CREATE TYPE pg_catalog.ArbitraryRequestType AS ENUM (
	'GET',
	'POST',
	'PUT',
	'DELETE'
);

-- src/elasticsearch/mod.rs:567
-- zombodb::elasticsearch::request
CREATE  FUNCTION zdb."request"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"endpoint" TEXT, /* &str */
	"method" pg_catalog.ArbitraryRequestType DEFAULT 'GET', /* zombodb::elasticsearch::pg_catalog::ArbitraryRequestType */
	"post_data" jsonb DEFAULT NULL, /* core::option::Option<pgrx::datum::json::JsonB> */
	"null_on_error" bool DEFAULT false /* core::option::Option<bool> */
) RETURNS TEXT /* core::option::Option<alloc::string::String> */
VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'request_wrapper';

-- src/elasticsearch/aggregates/terms_two_level.rs:16
-- zombodb::elasticsearch::aggregates::terms_two_level::pg_catalog::TwoLevelTermsOrderBy
CREATE TYPE pg_catalog.TwoLevelTermsOrderBy AS ENUM (
	'count',
	'term',
	'key',
	'reverse_count',
	'reverse_term',
	'reverse_key'
);

-- src/elasticsearch/aggregates/terms_two_level.rs:28
-- zombodb::elasticsearch::aggregates::terms_two_level::terms_two_level
CREATE  FUNCTION zdb."terms_two_level"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_first" TEXT, /* &str */
	"field_second" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"order_by" pg_catalog.TwoLevelTermsOrderBy DEFAULT 'count', /* core::option::Option<zombodb::elasticsearch::aggregates::terms_two_level::pg_catalog::TwoLevelTermsOrderBy> */
	"size_limit" INT DEFAULT 2147483647 /* core::option::Option<i32> */
) RETURNS TABLE (
	"term_one" TEXT,  /* core::option::Option<alloc::string::String> */
	"term_two" TEXT,  /* core::option::Option<alloc::string::String> */
	"doc_count" bigint  /* i64 */
)
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_two_level_wrapper';

-- src/elasticsearch/aggregates/terms.rs:21
-- zombodb::elasticsearch::aggregates::terms::pg_catalog::TermsOrderBy
CREATE TYPE pg_catalog.TermsOrderBy AS ENUM (
	'count',
	'term',
	'key',
	'reverse_count',
	'reverse_term',
	'reverse_key'
);

-- src/elasticsearch/aggregates/builders/terms.rs:12
-- zombodb::elasticsearch::aggregates::builders::terms::terms_agg
CREATE  FUNCTION zdb."terms_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"size_limit" INT, /* i32 */
	"order_by" pg_catalog.TermsOrderBy, /* zombodb::elasticsearch::aggregates::terms::pg_catalog::TermsOrderBy */
	"children" jsonb[] DEFAULT NULL /* core::option::Option<alloc::vec::Vec<pgrx::datum::json::JsonB>> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_agg_wrapper';

-- src/elasticsearch/aggregates/terms.rs:65
-- zombodb::elasticsearch::aggregates::terms::tally
CREATE  FUNCTION zdb."tally"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_name" TEXT, /* &str */
	"stem" TEXT, /* core::option::Option<&str> */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"size_limit" INT DEFAULT 2147483647, /* core::option::Option<i32> */
	"order_by" pg_catalog.TermsOrderBy DEFAULT 'count', /* core::option::Option<zombodb::elasticsearch::aggregates::terms::pg_catalog::TermsOrderBy> */
	"shard_size" INT DEFAULT 2147483647, /* core::option::Option<i32> */
	"count_nulls" bool DEFAULT true /* core::option::Option<bool> */
) RETURNS TABLE (
	"term" TEXT,  /* core::option::Option<alloc::string::String> */
	"count" bigint  /* i64 */
)
IMMUTABLE PARALLEL SAFE 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'tally_not_nested_wrapper';

-- src/elasticsearch/aggregates/terms.rs:89
-- zombodb::elasticsearch::aggregates::terms::tally
CREATE  FUNCTION zdb."tally"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_name" TEXT, /* &str */
	"is_nested" bool, /* bool */
	"stem" TEXT, /* core::option::Option<&str> */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"size_limit" INT DEFAULT 2147483647, /* core::option::Option<i32> */
	"order_by" pg_catalog.TermsOrderBy DEFAULT 'count', /* core::option::Option<zombodb::elasticsearch::aggregates::terms::pg_catalog::TermsOrderBy> */
	"shard_size" INT DEFAULT 2147483647, /* core::option::Option<i32> */
	"count_nulls" bool DEFAULT true /* core::option::Option<bool> */
) RETURNS TABLE (
	"term" TEXT,  /* core::option::Option<alloc::string::String> */
	"count" bigint  /* i64 */
)
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'tally_wrapper';

-- src/elasticsearch/aggregates/terms.rs:33
-- zombodb::elasticsearch::aggregates::terms::terms
CREATE  FUNCTION zdb."terms"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field_name" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"size_limit" INT DEFAULT 2147483647, /* core::option::Option<i32> */
	"order_by" pg_catalog.TermsOrderBy DEFAULT 'count' /* core::option::Option<zombodb::elasticsearch::aggregates::terms::pg_catalog::TermsOrderBy> */
) RETURNS TABLE (
	"term" TEXT,  /* core::option::Option<alloc::string::String> */
	"doc_count" bigint  /* i64 */
)
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'terms_wrapper';

-- src/elasticsearch/aggregates/terms.rs:382
-- zombodb::elasticsearch::aggregates::terms::terms_array_agg

        CREATE OR REPLACE FUNCTION zdb."terms_array"(
            "index" regclass,
            "field_name" text,
            "query" ZDBQuery,
            "size_limit" integer DEFAULT '2147483647',
            "order_by" TermsOrderBy DEFAULT 'count')
        RETURNS text[]
        IMMUTABLE PARALLEL SAFE
        LANGUAGE c AS 'MODULE_PATHNAME', 'terms_array_agg_wrapper';
    



-- src/elasticsearch/aggregates/date_histogram.rs:15
-- zombodb::elasticsearch::aggregates::date_histogram::pg_catalog::CalendarInterval
CREATE TYPE pg_catalog.CalendarInterval AS ENUM (
	'minute',
	'hour',
	'day',
	'week',
	'month',
	'quarter',
	'year'
);

-- src/elasticsearch/aggregates/builders/date_histogram.rs:13
-- zombodb::elasticsearch::aggregates::builders::date_histogram::date_histogram_agg
CREATE  FUNCTION zdb."date_histogram_agg"(
	"aggregate_name" TEXT, /* &str */
	"field" TEXT, /* &str */
	"calendar_interval" pg_catalog.CalendarInterval DEFAULT NULL, /* core::option::Option<zombodb::elasticsearch::aggregates::date_histogram::pg_catalog::CalendarInterval> */
	"fixed_interval" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"time_zone" TEXT DEFAULT '+00:00', /* &str */
	"format" TEXT DEFAULT 'yyyy-MM-dd', /* &str */
	"children" jsonb[] DEFAULT NULL /* core::option::Option<alloc::vec::Vec<pgrx::datum::json::JsonB>> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'date_histogram_agg_wrapper';

-- src/elasticsearch/aggregates/date_histogram.rs:28
-- zombodb::elasticsearch::aggregates::date_histogram::date_histogram
CREATE  FUNCTION zdb."date_histogram"(
	"index" regclass, /* pgrx::rel::PgRelation */
	"field" TEXT, /* &str */
	"query" pg_catalog.ZDBQuery, /* zombodb::zdbquery::pg_catalog::ZDBQuery */
	"calendar_interval" pg_catalog.CalendarInterval DEFAULT NULL, /* core::option::Option<zombodb::elasticsearch::aggregates::date_histogram::pg_catalog::CalendarInterval> */
	"fixed_interval" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"time_zone" TEXT DEFAULT '+00:00', /* &str */
	"format" TEXT DEFAULT 'yyyy-MM-dd' /* &str */
) RETURNS TABLE (
	"key_as_string" TEXT,  /* alloc::string::String */
	"term" bigint,  /* i64 */
	"doc_count" bigint  /* i64 */
)
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'date_histogram_wrapper';

-- src/lib.rs:34
CREATE OR REPLACE FUNCTION dsl.join(left_field name, index regclass, right_field name, query zdbquery,
                                    size int DEFAULT 0) RETURNS zdbquery
    PARALLEL SAFE STABLE
    LANGUAGE plpgsql AS
$$
BEGIN
    IF size > 0 THEN
        /* if we have a size limit, then limit to the top matching hits */
        RETURN dsl.bool(dsl.filter(
                dsl.terms(left_field, VARIADIC (SELECT coalesce(array_agg(source ->> right_field), ARRAY []::text[])
                                                FROM zdb.top_hits(index, ARRAY [right_field], query, size)))));
    ELSE
        /* otherwise, return all the matching terms */
        RETURN dsl.bool(dsl.filter(dsl.terms(left_field, VARIADIC zdb.terms_array(index, right_field, query))));
    END IF;
END ;
$$;


-- src/zdbquery/opclass.rs:191

CREATE OPERATOR pg_catalog.==> (
    PROCEDURE = anyelement_cmpfunc,
    RESTRICT = restrict,
    LEFTARG = anyelement,
    RIGHTARG = zdbquery
);

CREATE OPERATOR CLASS anyelement_zdb_ops DEFAULT FOR TYPE anyelement USING zombodb AS
    OPERATOR 1 pg_catalog.==>(anyelement, zdbquery),
--    OPERATOR 2 pg_catalog.==|(anyelement, zdbquery[]),
--    OPERATOR 3 pg_catalog.==&(anyelement, zdbquery[]),
--    OPERATOR 4 pg_catalog.==!(anyelement, zdbquery[]),
    STORAGE anyelement;



-- src/zdbquery/cast.rs:30

CREATE CAST (text AS zdbquery) WITH FUNCTION zdbquery_from_text(text) AS IMPLICIT;
CREATE CAST (json AS zdbquery) WITH FUNCTION zdbquery_from_json(json) AS IMPLICIT;
CREATE CAST (jsonb AS zdbquery) WITH FUNCTION zdbquery_from_jsonb(jsonb) AS IMPLICIT;
CREATE CAST (zdbquery AS json) WITH FUNCTION zdbquery_to_json(zdbquery) AS IMPLICIT;
CREATE CAST (zdbquery AS jsonb) WITH FUNCTION zdbquery_to_jsonb(zdbquery) AS IMPLICIT;


-- src/lib.rs:28
--
-- PG to ES type mapping support
--

--
-- filter/analyzer/mapping support
--

CREATE TABLE zdb.filters
(
    name       text                  NOT NULL PRIMARY KEY,
    definition jsonb                 NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);

CREATE TABLE zdb.char_filters
(
    name       text                  NOT NULL PRIMARY KEY,
    definition jsonb                 NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);

CREATE TABLE zdb.analyzers
(
    name       text                  NOT NULL PRIMARY KEY,
    definition jsonb                 NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);

CREATE TABLE zdb.normalizers
(
    name       text                  NOT NULL PRIMARY KEY,
    definition jsonb                 NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);

CREATE TABLE zdb.mappings
(
    table_name regclass NOT NULL,
    field_name text     NOT NULL,
    definition jsonb    NOT NULL,
    es_only    boolean  NOT NULL DEFAULT false,
    PRIMARY KEY (table_name, field_name)
);

CREATE TABLE zdb.type_mappings
(
    type_name  regtype               NOT NULL PRIMARY KEY,
    definition jsonb   DEFAULT NULL,
    is_default boolean DEFAULT false NOT NULL,
    funcid     regproc DEFAULT null
);

CREATE TABLE zdb.tokenizers
(
    name       text                  NOT NULL PRIMARY KEY,
    definition jsonb                 NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);

CREATE TABLE zdb.type_conversions
(
    typeoid    regtype NOT NULL PRIMARY KEY,
    funcoid    regproc NOT NULL,
    is_default boolean DEFAULT false
);

CREATE TABLE zdb.similarities
(
    name       text NOT NULL PRIMARY KEY,
    definition jsonb
);

SELECT pg_catalog.pg_extension_config_dump('zdb.filters', 'WHERE NOT is_default');
SELECT pg_catalog.pg_extension_config_dump('zdb.char_filters', 'WHERE NOT is_default');
SELECT pg_catalog.pg_extension_config_dump('zdb.analyzers', 'WHERE NOT is_default');
SELECT pg_catalog.pg_extension_config_dump('zdb.normalizers', 'WHERE NOT is_default');
SELECT pg_catalog.pg_extension_config_dump('zdb.mappings', '');
SELECT pg_catalog.pg_extension_config_dump('zdb.tokenizers', 'WHERE NOT is_default');
SELECT pg_catalog.pg_extension_config_dump('zdb.type_mappings', 'WHERE NOT is_default');
SELECT pg_catalog.pg_extension_config_dump('zdb.type_conversions', 'WHERE NOT is_default');
SELECT pg_catalog.pg_extension_config_dump('zdb.similarities', '');


CREATE OR REPLACE FUNCTION zdb.define_filter(name text, definition json) RETURNS void
    LANGUAGE sql
    VOLATILE STRICT AS
$$
DELETE
FROM zdb.filters
WHERE name = $1;
INSERT INTO zdb.filters(name, definition)
VALUES ($1, $2);
$$;

CREATE OR REPLACE FUNCTION zdb.define_char_filter(name text, definition json) RETURNS void
    LANGUAGE sql
    VOLATILE STRICT AS
$$
DELETE
FROM zdb.char_filters
WHERE name = $1;
INSERT INTO zdb.char_filters(name, definition)
VALUES ($1, $2);
$$;

CREATE OR REPLACE FUNCTION zdb.define_analyzer(name text, definition json) RETURNS void
    LANGUAGE sql
    VOLATILE STRICT AS
$$
DELETE
FROM zdb.analyzers
WHERE name = $1;
INSERT INTO zdb.analyzers(name, definition)
VALUES ($1, $2);
$$;

CREATE OR REPLACE FUNCTION zdb.define_normalizer(name text, definition json) RETURNS void
    LANGUAGE sql
    VOLATILE STRICT AS
$$
DELETE
FROM zdb.normalizers
WHERE name = $1;
INSERT INTO zdb.normalizers(name, definition)
VALUES ($1, $2);
$$;

CREATE OR REPLACE FUNCTION zdb.define_field_mapping(table_name regclass, field_name text, definition json) RETURNS void
    LANGUAGE sql
    VOLATILE STRICT AS
$$
DELETE
FROM zdb.mappings
WHERE table_name = $1
  AND field_name = $2;
INSERT INTO zdb.mappings(table_name, field_name, definition)
VALUES ($1, $2, $3);
$$;

CREATE OR REPLACE FUNCTION zdb.define_es_only_field(table_name regclass, field_name text, definition json) RETURNS void
    LANGUAGE sql
    VOLATILE STRICT AS
$$
DELETE
FROM zdb.mappings
WHERE table_name = $1
  AND field_name = $2;
INSERT INTO zdb.mappings(table_name, field_name, definition, es_only)
VALUES ($1, $2, $3, true);
$$;

CREATE OR REPLACE FUNCTION zdb.define_type_mapping(type_name regtype, definition json) RETURNS void
    LANGUAGE sql
    VOLATILE STRICT AS
$$
DELETE
FROM zdb.type_mappings
WHERE type_name = $1;
INSERT INTO zdb.type_mappings(type_name, definition)
VALUES ($1, $2);
$$;

CREATE OR REPLACE FUNCTION zdb.define_type_mapping(type_name regtype, funcid regproc) RETURNS void
    LANGUAGE sql
    VOLATILE STRICT AS
$$
DELETE
FROM zdb.type_mappings
WHERE type_name = $1;
INSERT INTO zdb.type_mappings(type_name, funcid)
VALUES ($1, $2);
$$;

CREATE OR REPLACE FUNCTION zdb.define_tokenizer(name text, definition json) RETURNS void
    LANGUAGE sql
    VOLATILE STRICT AS
$$
DELETE
FROM zdb.tokenizers
WHERE name = $1;
INSERT INTO zdb.tokenizers(name, definition)
VALUES ($1, $2);
$$;

CREATE OR REPLACE FUNCTION zdb.define_similarity(name text, definition json) RETURNS void
    LANGUAGE sql
    VOLATILE STRICT AS
$$
    DELETE FROM zdb.similarities WHERE name = $1;
    INSERT INTO zdb.similarities(name, definition) VALUES ($1, $2);
$$;

INSERT INTO zdb.filters(name, definition, is_default)
VALUES ('zdb_truncate_to_fit', '{
  "type": "truncate",
  "length": 10922
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.filters(name, definition, is_default)
VALUES ('shingle_filter', '{
  "type": "shingle",
  "min_shingle_size": 2,
  "max_shingle_size": 2,
  "output_unigrams": true,
  "token_separator": "$"
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.filters(name, definition, is_default)
VALUES ('shingle_filter_search', '{
  "type": "shingle",
  "min_shingle_size": 2,
  "max_shingle_size": 2,
  "output_unigrams": false,
  "output_unigrams_if_no_shingles": true,
  "token_separator": "$"
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.normalizers(name, definition, is_default)
VALUES ('lowercase', '{
  "type": "custom",
  "char_filter": [],
  "filter": [
    "lowercase"
  ]
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

-- same as 'lowercase' for backwards compatibility
INSERT INTO zdb.normalizers(name, definition, is_default)
VALUES ('exact', '{
  "type": "custom",
  "char_filter": [],
  "filter": [
    "lowercase"
  ]
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.analyzers(name, definition, is_default)
VALUES ('zdb_standard', '{
  "type": "standard",
  "filter": [
    "zdb_truncate_to_fit",
    "lowercase"
  ]
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.analyzers(name, definition, is_default)
VALUES ('zdb_all_analyzer', '{
  "type": "standard",
  "filter": [
    "zdb_truncate_to_fit",
    "lowercase"
  ]
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.analyzers(name, definition, is_default)
VALUES ('fulltext_with_shingles', '{
  "type": "custom",
  "tokenizer": "standard",
  "filter": [
    "lowercase",
    "shingle_filter",
    "zdb_truncate_to_fit"
  ]
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.analyzers(name, definition, is_default)
VALUES ('fulltext_with_shingles_search', '{
  "type": "custom",
  "tokenizer": "standard",
  "filter": [
    "lowercase",
    "shingle_filter_search"
  ]
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.analyzers(name, definition, is_default)
VALUES ('fulltext', '{
  "type": "standard",
  "filter": [
    "zdb_truncate_to_fit",
    "lowercase"
  ]
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.analyzers(name, definition, is_default)
VALUES ('phrase', '{
  "type": "standard",
  "copy_to": "zdb_all",
  "filter": [
    "zdb_truncate_to_fit",
    "lowercase"
  ]
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;


CREATE DOMAIN zdb.phrase AS text;
CREATE DOMAIN zdb.phrase_array AS text[];
CREATE DOMAIN zdb.fulltext AS text;
CREATE DOMAIN zdb.fulltext_with_shingles AS text;
CREATE DOMAIN zdb.zdb_standard AS text;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('"char"', '{
  "type": "keyword"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('char', '{
  "type": "keyword",
  "copy_to": "zdb_all",
  "ignore_above": 10922,
  "normalizer": "lowercase"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('bytea', '{
  "type": "binary"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('boolean', '{
  "type": "boolean"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('smallint', '{
  "type": "short"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('integer', '{
  "type": "integer"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('bigint', '{
  "type": "long"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('real', '{
  "type": "float"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('double precision', '{
  "type": "double"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('character varying', '{
  "type": "keyword",
  "copy_to": "zdb_all",
  "ignore_above": 10922,
  "normalizer": "lowercase"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('text', '{
  "type": "text",
  "copy_to": "zdb_all",
  "fielddata": true,
  "analyzer": "zdb_standard"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

--INSERT INTO zdb.type_mappings(type_name, definition, is_default) VALUES (
--  'citext', '{
--    "type": "text",
--    "copy_to": "zdb_all",
--    "fielddata": true,
--    "analyzer": "zdb_standard"
--  }', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('time without time zone', '{
  "type": "keyword",
  "copy_to": "zdb_all",
  "fields": {
    "date": {
      "type": "date",
      "format": "HH:mm||HH:mm:ss||HH:mm:ss.S||HH:mm:ss.SS||HH:mm:ss.SSS||HH:mm:ss.SSSS||HH:mm:ss.SSSSS||HH:mm:ss.SSSSSS"
    }
  }
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('time with time zone', '{
  "type": "keyword",
  "copy_to": "zdb_all",
  "fields": {
    "date": {
      "type": "date",
      "format": "HH:mmX||HH:mm:ssX||HH:mm:ss.SX||HH:mm:ss.SSX||HH:mm:ss.SSSX||HH:mm:ss.SSSSX||HH:mm:ss.SSSSSX||HH:mm:ss.SSSSSSX"
    }
  }
}
', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('date', '{
  "type": "keyword",
  "copy_to": "zdb_all",
  "fields": {
    "date": {
      "type": "date"
    }
  }
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('timestamp without time zone', '{
  "type": "keyword",
  "copy_to": "zdb_all",
  "fields": {
    "date": {
      "type": "date"
    }
  }
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('timestamp with time zone', '{
  "type": "keyword",
  "copy_to": "zdb_all",
  "fields": {
    "date": {
      "type": "date"
    }
  }
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('json', '{
  "type": "nested",
  "include_in_parent": true
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('jsonb', '{
  "type": "nested",
  "include_in_parent": true
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('inet', '{
  "type": "ip",
  "copy_to": "zdb_all"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('zdb.phrase', '{
  "type": "text",
  "copy_to": "zdb_all",
  "fielddata": true,
  "analyzer": "phrase"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('zdb.phrase_array', '{
  "type": "text",
  "copy_to": "zdb_all",
  "fielddata": true,
  "analyzer": "phrase"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('zdb.fulltext', '{
  "type": "text",
  "fielddata": true,
  "analyzer": "fulltext"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('zdb.fulltext_with_shingles', '{
  "type": "text",
  "fielddata": true,
  "analyzer": "fulltext_with_shingles",
  "search_analyzer": "fulltext_with_shingles_search"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('point', '{
  "type": "geo_point"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('uuid', '{
  "type": "keyword",
  "copy_to": "zdb_all",
  "ignore_above": 10922,
  "normalizer": "lowercase"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.type_mappings(type_name, definition, is_default)
VALUES ('tsvector', '{
  "type": "text",
  "copy_to": "zdb_all",
  "fielddata": true,
  "analyzer": "zdb_standard"
}', true) ON CONFLICT (type_name) DO UPDATE SET definition = excluded.definition;

CREATE DOMAIN zdb.arabic AS text;
CREATE DOMAIN zdb.armenian AS text;
CREATE DOMAIN zdb.basque AS text;
CREATE DOMAIN zdb.brazilian AS text;
CREATE DOMAIN zdb.bulgarian AS text;
CREATE DOMAIN zdb.catalan AS text;
CREATE DOMAIN zdb.chinese AS text;
CREATE DOMAIN zdb.cjk AS text;
CREATE DOMAIN zdb.czech AS text;
CREATE DOMAIN zdb.danish AS text;
CREATE DOMAIN zdb.dutch AS text;
CREATE DOMAIN zdb.english AS text;
CREATE DOMAIN zdb.fingerprint AS text;
CREATE DOMAIN zdb.finnish AS text;
CREATE DOMAIN zdb.french AS text;
CREATE DOMAIN zdb.galician AS text;
CREATE DOMAIN zdb.german AS text;
CREATE DOMAIN zdb.greek AS text;
CREATE DOMAIN zdb.hindi AS text;
CREATE DOMAIN zdb.hungarian AS text;
CREATE DOMAIN zdb.indonesian AS text;
CREATE DOMAIN zdb.irish AS text;
CREATE DOMAIN zdb.italian AS text;
CREATE DOMAIN zdb.keyword AS character varying;
CREATE DOMAIN zdb.latvian AS text;
CREATE DOMAIN zdb.norwegian AS text;
CREATE DOMAIN zdb.persian AS text;
CREATE DOMAIN zdb.portuguese AS text;
CREATE DOMAIN zdb.romanian AS text;
CREATE DOMAIN zdb.russian AS text;
CREATE DOMAIN zdb.sorani AS text;
CREATE DOMAIN zdb.spanish AS text;
CREATE DOMAIN zdb.simple AS text;
CREATE DOMAIN zdb.standard AS text;
CREATE DOMAIN zdb.swedish AS text;
CREATE DOMAIN zdb.turkish AS text;
CREATE DOMAIN zdb.thai AS text;
CREATE DOMAIN zdb.whitespace AS text;

--
-- emoji analyzer support
--

INSERT INTO zdb.tokenizers(name, definition, is_default)
VALUES ('emoji', '{
  "type": "pattern",
  "pattern": "([\\ud83c\\udf00-\\ud83d\\ude4f]|[\\ud83d\\ude80-\\ud83d\\udeff])",
  "group": 1
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

INSERT INTO zdb.analyzers(name, definition, is_default)
VALUES ('emoji', '{
  "tokenizer": "emoji"
}', true) ON CONFLICT (name) DO UPDATE SET definition = excluded.definition;

CREATE OR REPLACE FUNCTION zdb.define_type_conversion(typeoid regtype, funcoid regproc) RETURNS void
    VOLATILE STRICT
    LANGUAGE sql AS
$$
DELETE
FROM zdb.type_conversions
WHERE typeoid = $1;
INSERT INTO zdb.type_conversions(typeoid, funcoid)
VALUES ($1, $2);
$$;


--
-- permissions to do all the things to the tables defined here
---

GRANT ALL ON zdb.analyzers TO PUBLIC;
GRANT ALL ON zdb.char_filters TO PUBLIC;
GRANT ALL ON zdb.filters TO PUBLIC;
GRANT ALL ON zdb.mappings TO PUBLIC;
GRANT ALL ON zdb.similarities TO PUBLIC;
GRANT ALL ON zdb.tokenizers TO PUBLIC;
GRANT ALL ON zdb.type_mappings TO PUBLIC;
GRANT ALL ON zdb.normalizers TO PUBLIC;
GRANT ALL ON zdb.type_conversions TO PUBLIC;


-- src/query_dsl/geo.rs:104
-- requires:
--   mappings

CREATE OR REPLACE FUNCTION zdb.enable_postgis_support(during_create_extension bool DEFAULT false) RETURNS boolean VOLATILE LANGUAGE plpgsql AS $func$
DECLARE
  postgis_installed boolean := (SELECT count(*) > 0 FROM pg_extension WHERE extname = 'postgis');
  geojson_namespace text := (SELECT (SELECT nspname FROM pg_namespace WHERE oid = pronamespace) FROM pg_proc WHERE proname = 'st_asgeojson' limit 1);
BEGIN

  IF postgis_installed THEN
    RAISE WARNING '[zombodb] Installing support for PostGIS';

    -- casting functions
    EXECUTE format('create or replace function zdb.geometry_to_json(%I.geometry, typmod integer DEFAULT -1) returns json parallel safe immutable strict language sql as $$
          SELECT CASE WHEN %I.postgis_typmod_type($2) = ''Point'' THEN
                    zdb.point_to_json(%I.st_transform($1, 4326)::point)::json
                 ELSE
                    %I.st_asgeojson(%I.st_transform($1, 4326))::json
                 END
          $$;',
      geojson_namespace, geojson_namespace, geojson_namespace, geojson_namespace, geojson_namespace);
    EXECUTE format('create or replace function zdb.geography_to_json(%I.geography, typmod integer DEFAULT -1) returns json parallel safe immutable strict language sql as $$
          select zdb.geometry_to_json($1::%I.geometry, $2);
          $$;',
      geojson_namespace, geojson_namespace);

    EXECUTE format('create or replace function zdb.postgis_type_mapping_func(datatype regtype, typmod integer) returns jsonb parallel safe immutable strict language sql as $$
          SELECT CASE WHEN %I.postgis_typmod_type($2) = ''Point'' THEN
                    ''{"type":"geo_point"}''::jsonb
                 ELSE
                    ''{"type":"geo_shape"}''::jsonb
                 END
          $$;', geojson_namespace);

    -- zdb type mappings
    EXECUTE format($$ SELECT zdb.define_type_mapping('%I.geometry'::regtype,  'zdb.postgis_type_mapping_func'::regproc); $$, geojson_namespace);
    EXECUTE format($$ SELECT zdb.define_type_mapping('%I.geography'::regtype, 'zdb.postgis_type_mapping_func'::regproc); $$, geojson_namespace);

    -- zdb type conversions
    EXECUTE format($$ SELECT zdb.define_type_conversion('%I.geometry'::regtype, 'zdb.geometry_to_json'::regproc); $$, geojson_namespace);
    EXECUTE format($$ SELECT zdb.define_type_conversion('%I.geography'::regtype, 'zdb.geography_to_json'::regproc); $$, geojson_namespace);

    IF during_create_extension = false THEN
      EXECUTE 'ALTER EXTENSION zombodb ADD FUNCTION zdb.geometry_to_json';
      EXECUTE 'ALTER EXTENSION zombodb ADD FUNCTION zdb.geography_to_json';
    END IF;

  END IF;

  RETURN postgis_installed;
END;
$func$;

DO LANGUAGE plpgsql $$
  DECLARE
    postgis_installed boolean := (SELECT count(*) > 0 FROM pg_extension WHERE extname = 'postgis');
  BEGIN
    IF postgis_installed THEN
      PERFORM zdb.enable_postgis_support(true);
    END IF;
  END;
$$;


-- src/lib.rs:35
--
-- _cat/ API support
--
CREATE OR REPLACE FUNCTION zdb.all_es_index_names() RETURNS SETOF text PARALLEL SAFE STABLE STRICT LANGUAGE sql AS $$
SELECT zdb.index_name(oid::regclass) FROM pg_class WHERE relam = (SELECT oid FROM pg_am WHERE amname = 'zombodb');
$$;

CREATE OR REPLACE FUNCTION zdb._all_indices_cat_request(endpoint TEXT) RETURNS TABLE(url TEXT, response JSONB) PARALLEL SAFE IMMUTABLE STRICT LANGUAGE SQL AS $$
WITH clusters AS (SELECT
                      zdb.index_url(idx) url,
                      idx
                  FROM (SELECT DISTINCT ON (zdb.index_url(oid::regclass)) oid::regclass idx
                        FROM pg_class
                        WHERE relam = (SELECT oid
                                       FROM pg_am
                                       WHERE amname = 'zombodb')) x)
SELECT
    url,
    jsonb_array_elements(zdb.cat_request(idx, $1))
FROM clusters
$$;

CREATE OR REPLACE VIEW zdb.cat_aliases AS
SELECT
    url,
    response->>'alias' AS "alias",
    response->>'index' AS "index",
    response->>'filter' AS "filter",
    response->>'routing.index' AS "routing.index",
    response->>'routing.search' AS "routing.search"
FROM zdb._all_indices_cat_request('aliases')
WHERE response->>'index' IN (SELECT index from zdb.all_es_index_names() index);

CREATE OR REPLACE VIEW zdb.cat_allocation AS
SELECT
    url,
    (response->>'shards')::int AS "shards",
    (response->>'disk.indices')::bigint AS "disk.indices",
    (response->>'disk.used')::bigint AS "disk.used",
    (response->>'disk.avail')::bigint AS "disk.avail",
    (response->>'disk.total')::bigint AS "disk.total",
    (response->>'disk.percent')::real AS "disk.percent",
    (response->>'host') AS "host",
    (response->>'ip')::inet AS "ip",
    (response->>'node') AS "node"
FROM zdb._all_indices_cat_request('allocation');

CREATE OR REPLACE VIEW zdb.cat_count AS
SELECT
    url,
    (response->>'epoch')::bigint AS "epoch",
    (response->>'timestamp')::time AS "timestamp",
    (response->>'count')::bigint AS "count"
FROM zdb._all_indices_cat_request('count');

CREATE OR REPLACE VIEW zdb.cat_fielddata AS
SELECT
    url,
    (response->>'id') AS "id",
    (response->>'host') AS "host",
    (response->>'ip')::inet AS "ip",
    (response->>'node') AS "node",
    (response->>'field') AS "field",
    (response->>'size')::bigint AS "size"
FROM zdb._all_indices_cat_request('fielddata');

CREATE OR REPLACE VIEW zdb.cat_health AS
SELECT
    url,
    (response->>'epoch')::bigint AS "epoch",
    (response->>'timestamp')::time AS "timestamp",
    (response->>'cluster')::text AS "cluster",
    (response->>'status') AS "status",
    (response->>'node.total')::bigint AS "node.total",
    (response->>'node.data')::bigint AS "node.data",
    (response->>'shards')::int AS "shards",
    (response->>'pri')::int AS "pri",
    (response->>'relo')::int AS "relo",
    (response->>'init')::int AS "init",
    (response->>'unassign')::int AS "unassign",
    (response->>'pending_tasks')::int AS "pending_tasks",
    case when response->>'max_task_wait_time' <> '-' then ((response->>'max_task_wait_time')||'milliseconds')::interval else null end AS "max_task_wait_time",
    (response->>'active_shards_percent') AS "active_shards_percent"
FROM zdb._all_indices_cat_request('health');

CREATE OR REPLACE VIEW zdb.cat_indices AS
SELECT
    url,
    (response->>'health') AS "health",
    (response->>'status') AS "status",
    (select array_to_string(array_agg(alias), ',') from zdb.cat_aliases where index = response->>'index') as alias,
    (response->>'index') AS "index",
    (response->>'uuid') AS "uuid",
    (response->>'pri')::int AS "pri",
    (response->>'rep')::int AS "rep",
    (response->>'docs.count')::bigint AS "docs.count",
    (response->>'docs.deleted')::bigint AS "docs.deleted",
    (response->>'store.size')::bigint AS "store.size",
    (response->>'pri.store.size')::bigint AS "pri.store.size"
FROM zdb._all_indices_cat_request('indices')
WHERE response->>'index' IN (SELECT index from zdb.all_es_index_names() index);

CREATE OR REPLACE VIEW zdb.cat_master AS
SELECT
    url,
    (response->>'id') AS "id",
    (response->>'host') AS "host",
    (response->>'ip')::inet AS "ip",
    (response->>'node') AS "node"
FROM zdb._all_indices_cat_request('master');

CREATE OR REPLACE VIEW zdb.cat_nodeattrs AS
SELECT
    url,
    (response->>'node') AS "node",
    (response->>'host') AS "host",
    (response->>'ip')::inet AS "ip",
    (response->>'attr') AS "attr",
    (response->>'value') AS "value"
FROM zdb._all_indices_cat_request('nodeattrs');

CREATE OR REPLACE VIEW zdb.cat_nodes AS
SELECT
    url,
    (response->>'id')::text AS "id",
    (response->>'pid')::int AS "pid",
    (response->>'ip')::inet AS "ip",
    (response->>'port')::int AS "port",
    (response->>'http_address')::text AS "http_address",
    (response->>'version')::text AS "version",
    (response->>'build')::text AS "build",
    (response->>'jdk')::text AS "jdk",

    (response->>'disk.total')::text AS "disk.total",
    (response->>'disk.used')::text AS "disk.used",
    (response->>'disk.avail')::text AS "disk.avail",
    (response->>'disk.used_percent')::real AS "disk.used_percent",

    (response->>'heap.current')::text AS "heap.current",
    (response->>'heap.percent')::real AS "heap.percent",
    (response->>'heap.max')::text AS "heap.max",

    (response->>'ram.current')::text AS "ram.current",
    (response->>'ram.percent')::text AS "ram.percent",
    (response->>'ram.max')::text AS "ram.max",

    (response->>'file_desc.current')::int AS "file_desc.current",
    (response->>'file_desc.percent')::real AS "file_desc.percent",
    (response->>'file_desc.max')::int AS "file_desc.max",

    (response->>'cpu')::real AS "cpu",
    (response->>'load.1m')::real AS "load.1m",
    (response->>'load.5m')::real AS "load.5m",
    (response->>'load.15m')::real AS "load.15m",
    (response->>'uptime')::text AS "uptime",

    (response->>'node.role')::text AS "node.role",
    (response->>'master') = '*' AS "master",
    (response->>'name')::text AS "name",
    (response->>'completion.size')::text AS "completion.size",

    (response->>'fielddata.memory_size')::text AS "fielddata.memory_size",
    (response->>'fielddata.evictions')::int AS "fielddata.evictions",

    (response->>'query_cache.memory.size')::text AS "query_cache.memory.size",
    (response->>'query_cache.evictions')::int AS "query_cache.evictions",

    (response->>'request_cache.memory_size')::text AS "request_cache.memory_size",
    (response->>'request_cache.evictions')::int AS "request_cache.evictions",
    (response->>'request_cache.hit_count')::int AS "request_cache.hit_count",
    (response->>'request_cache.miss_count')::int AS "request_cache.miss_count",

    (response->>'flush.total')::int AS "flush.total",
    ((response->>'flush.total_time')::text||' milliseconds')::interval AS "flush.total_time",

    (response->>'get.current')::int AS "get.current",
    ((response->>'get.time')::text::text||' milliseconds')::interval AS "get.time",
    (response->>'get.total')::bigint AS "get.total",
    ((response->>'get.exists_time')::text||' milliseconds')::interval AS "get.exists_time",
    (response->>'get.exists_total')::bigint AS "get.exists_total",
    ((response->>'get.missing_time')::text||' milliseconds')::interval AS "get.missing_time",
    (response->>'get.missing_total')::bigint AS "get.missing_total",

    (response->>'indexing.delete_current')::bigint AS "indexing.delete_current",
    ((response->>'indexing.delete_time')::text||' milliseconds')::interval AS "indexing.delete_time",
    (response->>'indexing.delete_total')::bigint AS "indexing.delete_total",
    (response->>'indexing.index_current')::bigint AS "indexing.index_current",
    ((response->>'indexing.index_time')::text||' milliseconds')::interval AS "indexing.index_time",
    (response->>'indexing.index_total')::bigint AS "indexing.index_total",
    (response->>'indexing.index_failed')::bigint AS "indexing.index_failed",

    (response->>'merges.current')::bigint AS "merges.current",
    (response->>'merges.current.docs')::bigint AS "merges.current.docs",
    (response->>'merges.current.size')::text AS "merges.current.size",
    (response->>'merges.total')::bigint AS "merges.total",
    (response->>'merges.total_docs')::bigint AS "merges.total_docs",
    (response->>'merges.total_size')::text AS "merges.total_size",
    ((response->>'merges.total_time')::text||' milliseconds')::interval AS "merges.total_time",

    (response->>'refresh.total')::bigint AS "refresh.total",
    ((response->>'refresh.time')::text::text||' milliseconds')::interval AS "refresh.time",
    (response->>'refresh.listeners')::text AS "refresh.listeners",

    (response->>'script.compilations')::bigint AS "script.compilations",
    (response->>'script.cache_evictions')::bigint AS "script.cache_evictions",

    (response->>'search.fetch_current')::bigint AS "search.fetch_current",
    ((response->>'search.fetch_time')::text||' milliseconds')::interval AS "search.fetch_time",
    (response->>'search.fetch_total')::bigint AS "search.fetch_total",
    (response->>'search.open_contexts')::bigint AS "search.open_contexts",
    (response->>'search.query_current')::bigint AS "search.query_current",
    ((response->>'search.query_time')::text||' milliseconds')::interval AS "search.query_time",
    (response->>'search.query_total')::text AS "search.query_total",

    (response->>'search.scroll_current')::bigint AS "search.scroll_current",
    ((response->>'search.scroll_time')::bigint/1000 ||' milliseconds')::interval AS "search.scroll_time",
    (response->>'search.scroll_total')::bigint AS "search.scroll_total",

    (response->>'segments.count')::bigint AS "segments.count",
    (response->>'segments.memory')::text AS "segments.memory",
    (response->>'segments.index_writer_memory')::text AS "segments.index_writer_memory",
    (response->>'segments.version_map_memory')::text AS "segments.version_map_memory",
    (response->>'segments.fixed_bitset_memory')::text AS "segments.fixed_bitset_memory",

    (response->>'suggest.current')::bigint AS "suggest.current",
    ((response->>'suggest.time')::text||' milliseconds')::interval AS "suggest.time",
    (response->>'suggest.total')::bigint AS "suggest.total"
FROM zdb._all_indices_cat_request('nodes');

CREATE OR REPLACE VIEW zdb.cat_pending_tasks AS
SELECT
    url,
    (response->>'insertOrder')::int AS "insertOrder",
    ((response->>'timeInQueue')||' milliseconds')::interval AS "timeInQueue",
    (response->>'priority') AS "priority",
    (response->>'source') AS "source"
FROM zdb._all_indices_cat_request('pending_tasks');

CREATE OR REPLACE VIEW zdb.cat_plugins AS
SELECT
    url,
    (response->>'name') AS "name",
    (response->>'component') AS "component",
    (response->>'version') AS "version",
    (response->>'description') AS "description"
FROM zdb._all_indices_cat_request('plugins');

CREATE OR REPLACE VIEW zdb.cat_thread_pool AS
SELECT
    url,
    (response->>'ip')::inet AS "ip",
    (response->>'max')::int AS "max",
    (response->>'min')::int AS "min",
    (response->>'pid')::int AS "pid",
    (response->>'host')::text AS "host",
    (response->>'name')::text AS "name",
    (response->>'port')::int AS "port",
    (response->>'size')::int AS "size",
    (response->>'type')::text AS "type",
    (response->>'queue')::int AS "queue",
    (response->>'active')::int AS "active",
    (response->>'largest')::int AS "largest",
    (response->>'node_id')::text AS "node_id",
    (response->>'rejected')::int AS "rejected",
    (response->>'completed')::bigint AS "completed",
    (response->>'node_name')::text AS "node_name",
    (response->>'keep_alive')::text AS "keep_alive",
    (response->>'queue_size')::int AS "queue_size",
    (response->>'ephemeral_node_id')::text AS "ephemeral_node_id"
FROM zdb._all_indices_cat_request('thread_pool');

CREATE OR REPLACE VIEW zdb.cat_shards AS
SELECT
    url,
    (response->>'id')::text AS "id",
    (response->>'ip')::inet AS "ip",
    (response->>'docs')::bigint AS "docs",
    (response->>'node')::text AS "node",
    (select array_to_string(array_agg(alias), ',') from zdb.cat_aliases where index = response->>'index') as alias,
    (response->>'index')::text AS "index",
    (response->>'shard')::int AS "shard",
    (response->>'state')::text AS "state",
    (response->>'store')::bigint AS "store",
    (response->>'prirep')::text AS "prirep",
    (response->>'sync_id')::text AS "sync_id",
    (response->>'completion.size')::bigint AS "completion.size",
    (response->>'fielddata.evictions')::int AS "fielddata.evictions",
    (response->>'fielddata.memory_size')::bigint AS "fielddata.memory_size",
    (response->>'flush.total')::bigint AS "flush.total",
    ((response->>'flush.total_time')||'milliseconds')::interval AS "flush.total_time",
    (response->>'get.current')::int AS "get.current",
    ((response->>'get.exists_time')||'milliseconds')::interval AS "get.exists_time",
    (response->>'get.exists_total')::bigint AS "get.exists_total",
    ((response->>'get.missing_time')||'milliseconds')::interval AS "get.missing_time",
    (response->>'get.missing_total')::bigint AS "get.missing_total",
    ((response->>'get.time')||'milliseconds')::interval AS "get.time",
    (response->>'get.total')::bigint AS "get.total",
    (response->>'indexing.delete_current')::int AS "indexing.delete_current",
    ((response->>'indexing.delete_time')||'milliseconds')::interval AS "indexing.delete_time",
    (response->>'indexing.delete_total')::bigint AS "indexing.delete_total",
    (response->>'indexing.index_current')::int AS "indexing.index_current",
    (response->>'indexing.index_failed')::bigint AS "indexing.index_failed",
    ((response->>'indexing.index_time')||'milliseconds')::interval AS "indexing.index_time",
    (response->>'indexing.index_total')::bigint AS "indexing.index_total",
    (response->>'merges.current')::int AS "merges.current",
    (response->>'merges.current_docs')::int AS "merges.current_docs",
    (response->>'merges.current_size')::bigint AS "merges.current_size",
    (response->>'merges.total')::bigint AS "merges.total",
    (response->>'merges.total_docs')::bigint AS "merges.total_docs",
    (response->>'merges.total_size')::bigint AS "merges.total_size",
    ((response->>'merges.total_time')||'milliseconds')::interval AS "merges.total_time",
    (response->>'query_cache.evictions')::int AS "query_cache.evictions",
    (response->>'query_cache.memory_size')::bigint AS "query_cache.memory_size",
    (response->>'recoverysource.type')::text AS "recoverysource.type",
    (response->>'refresh.listeners')::int AS "refresh.listeners",
    ((response->>'refresh.time')||'milliseconds')::interval AS "refresh.time",
    (response->>'refresh.total')::bigint AS "refresh.total",
    (response->>'search.fetch_current')::int AS "search.fetch_current",
    ((response->>'search.fetch_time')||'milliseconds')::interval AS "search.fetch_time",
    (response->>'search.fetch_total')::bigint AS "search.fetch_total",
    (response->>'search.open_contexts')::int AS "search.open_contexts",
    (response->>'search.query_current')::int AS "search.query_current",
    ((response->>'search.query_time')||'milliseconds')::interval AS "search.query_time",
    (response->>'search.query_total')::bigint AS "search.query_total",
    (response->>'search.scroll_current')::int AS "search.scroll_current",
    ((response->>'search.scroll_time')::bigint / 1000 ||'milliseconds')::interval AS "search.scroll_time",
    (response->>'search.scroll_total')::bigint AS "search.scroll_total",
    (response->>'segments.count')::int AS "segments.count",
    (response->>'segments.fixed_bitset_memory')::bigint AS "segments.fixed_bitset_memory",
    (response->>'segments.index_writer_memory')::bigint AS "segments.index_writer_memory",
    (response->>'segments.memory')::bigint AS "segments.memory",
    (response->>'segments.version_map_memory')::bigint AS "segments.version_map_memory",
    (response->>'unassigned.at')::text AS "unassigned.at",
    (response->>'unassigned.details')::text AS "unassigned.details",
    (response->>'unassigned.for')::text AS "unassigned.for",
    (response->>'unassigned.reason')::text AS "unassigned.reason",
    (response->>'warmer.current')::int AS "warmer.current",
    (response->>'warmer.total')::bigint AS "warmer.total",
    ((response->>'warmer.total_time')||'milliseconds')::interval AS "warmer.total_time"
FROM zdb._all_indices_cat_request('shards')
WHERE response->>'index' IN (SELECT index from zdb.all_es_index_names() index);

CREATE OR REPLACE VIEW zdb.cat_segments AS
SELECT
    url,
    (response->>'id')::text AS "id",
    (response->>'ip')::inet AS "ip",
    (response->>'size')::bigint AS "size",
    (select array_to_string(array_agg(alias), ',') from zdb.cat_aliases where index = response->>'index') as alias,
    (response->>'index')::text AS "index",
    (response->>'shard')::int AS "shard",
    (response->>'prirep')::text AS "prirep",
    (response->>'segment')::text AS "segment",
    (response->>'version')::text AS "version",
    (response->>'compound')::boolean AS "compound",
    (response->>'committed')::boolean AS "committed",
    (response->>'docs.count')::bigint AS "docs.count",
    (response->>'generation')::int AS "generation",
    (response->>'searchable')::boolean AS "searchable",
    (response->>'size.memory')::bigint AS "size.memory",
    (response->>'docs.deleted')::bigint AS "docs.deleted"
FROM zdb._all_indices_cat_request('segments')
WHERE response->>'index' IN (SELECT index from zdb.all_es_index_names() index);



-- src/lib.rs:36
-- requires:
--   mappings
--   cat_api
--   query_dsl::geo::point_to_json
--   query_dsl::geo::point_array_to_json

--
-- custom type conversions for some built-in postgres types
--

INSERT INTO zdb.type_conversions (typeoid, funcoid, is_default)
VALUES ('point'::regtype, 'zdb.point_to_json'::regproc, true);
INSERT INTO zdb.type_conversions (typeoid, funcoid, is_default)
VALUES ('point[]'::regtype, 'zdb.point_array_to_json'::regproc, true);

CREATE OR REPLACE FUNCTION zdb.bytea_to_json(bytea) RETURNS json
    PARALLEL SAFE IMMUTABLE STRICT
    LANGUAGE sql AS
$$
SELECT to_json(encode($1, 'base64'));
$$;

INSERT INTO zdb.type_conversions (typeoid, funcoid, is_default)
VALUES ('bytea'::regtype, 'zdb.bytea_to_json'::regproc, true);


-- src/lib.rs:29
-- requires:
--   query_dsl::bool::dsl
--   cat_api

--
-- a view to get quick stats about all indexes
--
CREATE OR REPLACE VIEW zdb.index_stats AS
WITH stats AS (
    SELECT indrelid :: REGCLASS                                          table_name,
           indexrelid::regclass                                          pg_index_name,
           zdb.index_name(indexrelid)                                    es_index_name,
           zdb.index_url(indexrelid)                                     url,
           zdb.request(indexrelid, '_stats', 'GET', NULL, true)::json    stats,
           zdb.request(indexrelid, '_settings', 'GET', NULL, true)::json settings
    FROM pg_index,
         pg_class
    where pg_class.oid = pg_index.indexrelid
      and relam = (select oid from pg_am where amname = 'zombodb')
)
SELECT (select array_to_string(array_agg(alias), ',') from zdb.cat_aliases where index = es_index_name) as alias,
       es_index_name,
       url,
       table_name,
       pg_index_name,
       stats -> '_all' -> 'primaries' -> 'docs' -> 'count'                                              AS es_docs,
       pg_size_pretty((stats -> '_all' -> 'primaries' -> 'store' ->> 'size_in_bytes') :: INT8)          AS es_size,
       (stats -> '_all' -> 'primaries' -> 'store' ->> 'size_in_bytes') :: INT8                          AS es_size_bytes,
       (SELECT reltuples::int8 FROM pg_class WHERE oid = table_name)                                    AS pg_docs_estimate,
       pg_size_pretty(pg_total_relation_size(table_name))                                               AS pg_size,
       pg_total_relation_size(table_name)                                                               AS pg_size_bytes,
       stats -> '_shards' -> 'total'                                                                    AS shards,
       settings -> es_index_name -> 'settings' -> 'index' ->> 'number_of_replicas'                      AS replicas,
       (zdb.request(pg_index_name, '_count', 'GET', NULL, true) :: JSON) -> 'count'                     AS doc_count,
       coalesce(json_array_length((zdb.request(pg_index_name, '_doc/zdb_aborted_xids', 'GET', NULL, true) :: JSON) ->
                                  '_source' -> 'zdb_aborted_xids'), 0)                               AS aborted_xids
FROM stats;


-- src/elasticsearch/aggregates/adjacency_matrix.rs:61
  

CREATE OR REPLACE FUNCTION zdb.adjacency_matrix_2x2(index regclass, labels text[], filters zdbquery[]) RETURNS TABLE ("-" text, "1" text, "2" text) STABLE LANGUAGE sql AS $$

WITH matrix AS (SELECT term, doc_count::text FROM zdb.adjacency_matrix(index, labels, filters))
SELECT NULL::text, labels[1], labels[2]
   UNION ALL
SELECT labels[1],
    (SELECT doc_count FROM matrix WHERE term = labels[1]),
    (SELECT doc_count FROM matrix WHERE term in (labels[1]||'&'||labels[2], labels[2]||'&'||labels[1]))
   UNION ALL
SELECT labels[2],
    (SELECT doc_count FROM matrix WHERE term in (labels[2]||'&'||labels[1], labels[1]||'&'||labels[2])),
    (SELECT doc_count FROM matrix WHERE term = labels[2])

$$;

CREATE OR REPLACE FUNCTION zdb.adjacency_matrix_3x3(index regclass, labels text[], filters zdbquery[]) RETURNS TABLE ("-" text, "1" text, "2" text, "3" text) STABLE LANGUAGE sql AS $$

WITH matrix AS (SELECT term, doc_count::text FROM zdb.adjacency_matrix(index, labels, filters))
SELECT NULL::text, labels[1], labels[2], labels[3]
   UNION ALL
SELECT labels[1],
    (SELECT doc_count FROM matrix WHERE term = labels[1]),
    (SELECT doc_count FROM matrix WHERE term in (labels[1]||'&'||labels[2], labels[2]||'&'||labels[1])),
    (SELECT doc_count FROM matrix WHERE term in (labels[1]||'&'||labels[3], labels[3]||'&'||labels[1]))
   UNION ALL
SELECT labels[2],
    (SELECT doc_count FROM matrix WHERE term in (labels[2]||'&'||labels[1], labels[1]||'&'||labels[2])),
    (SELECT doc_count FROM matrix WHERE term = labels[2]),
    (SELECT doc_count FROM matrix WHERE term in (labels[2]||'&'||labels[3], labels[3]||'&'||labels[2]))
   UNION ALL
SELECT labels[3],
    (SELECT doc_count FROM matrix WHERE term in (labels[3]||'&'||labels[1], labels[1]||'&'||labels[3])),
    (SELECT doc_count FROM matrix WHERE term in (labels[3]||'&'||labels[2], labels[2]||'&'||labels[3])),
    (SELECT doc_count FROM matrix WHERE term = labels[3])

$$;

CREATE OR REPLACE FUNCTION zdb.adjacency_matrix_4x4(index regclass, labels text[], filters zdbquery[]) RETURNS TABLE ("-" text, "1" text, "2" text, "3" text, "4" text) STABLE LANGUAGE sql AS $$

WITH matrix AS (SELECT term, doc_count::text FROM zdb.adjacency_matrix(index, labels, filters))
SELECT NULL::text, labels[1], labels[2], labels[3], labels[4]
   UNION ALL
SELECT labels[1],
    (SELECT doc_count FROM matrix WHERE term = labels[1]),
    (SELECT doc_count FROM matrix WHERE term in (labels[1]||'&'||labels[2], labels[2]||'&'||labels[1])),
    (SELECT doc_count FROM matrix WHERE term in (labels[1]||'&'||labels[3], labels[3]||'&'||labels[1])),
    (SELECT doc_count FROM matrix WHERE term in (labels[1]||'&'||labels[4], labels[4]||'&'||labels[1]))
   UNION ALL
SELECT labels[2],
    (SELECT doc_count FROM matrix WHERE term in (labels[2]||'&'||labels[1], labels[1]||'&'||labels[2])),
    (SELECT doc_count FROM matrix WHERE term = labels[2]),
    (SELECT doc_count FROM matrix WHERE term in (labels[2]||'&'||labels[3], labels[3]||'&'||labels[2])),
    (SELECT doc_count FROM matrix WHERE term in (labels[2]||'&'||labels[4], labels[4]||'&'||labels[2]))
   UNION ALL
SELECT labels[3],
    (SELECT doc_count FROM matrix WHERE term in (labels[3]||'&'||labels[1], labels[1]||'&'||labels[3])),
    (SELECT doc_count FROM matrix WHERE term in (labels[3]||'&'||labels[2], labels[2]||'&'||labels[3])),
    (SELECT doc_count FROM matrix WHERE term = labels[3]),
    (SELECT doc_count FROM matrix WHERE term in (labels[3]||'&'||labels[4], labels[4]||'&'||labels[3]))
   UNION ALL
SELECT labels[4],
    (SELECT doc_count FROM matrix WHERE term in (labels[4]||'&'||labels[1], labels[1]||'&'||labels[4])),
    (SELECT doc_count FROM matrix WHERE term in (labels[4]||'&'||labels[2], labels[2]||'&'||labels[4])),
    (SELECT doc_count FROM matrix WHERE term in (labels[4]||'&'||labels[3], labels[3]||'&'||labels[4])),
    (SELECT doc_count FROM matrix WHERE term = labels[4])

$$;

CREATE OR REPLACE FUNCTION zdb.adjacency_matrix_5x5(index regclass, labels text[], filters zdbquery[]) RETURNS TABLE ("-" text, "1" text, "2" text, "3" text, "4" text, "5" text) STABLE LANGUAGE sql AS $$

WITH matrix AS (SELECT term, doc_count::text FROM zdb.adjacency_matrix(index, labels, filters))
SELECT NULL::text, labels[1], labels[2], labels[3], labels[4], labels[5]
   UNION ALL
SELECT labels[1],
    (SELECT doc_count FROM matrix WHERE term = labels[1]),
    (SELECT doc_count FROM matrix WHERE term in (labels[1]||'&'||labels[2], labels[2]||'&'||labels[1])),
    (SELECT doc_count FROM matrix WHERE term in (labels[1]||'&'||labels[3], labels[3]||'&'||labels[1])),
    (SELECT doc_count FROM matrix WHERE term in (labels[1]||'&'||labels[4], labels[4]||'&'||labels[1])),
    (SELECT doc_count FROM matrix WHERE term in (labels[1]||'&'||labels[5], labels[5]||'&'||labels[1]))
   UNION ALL
SELECT labels[2],
    (SELECT doc_count FROM matrix WHERE term in (labels[2]||'&'||labels[1], labels[1]||'&'||labels[2])),
    (SELECT doc_count FROM matrix WHERE term = labels[2]),
    (SELECT doc_count FROM matrix WHERE term in (labels[2]||'&'||labels[3], labels[3]||'&'||labels[2])),
    (SELECT doc_count FROM matrix WHERE term in (labels[2]||'&'||labels[4], labels[4]||'&'||labels[2])),
    (SELECT doc_count FROM matrix WHERE term in (labels[2]||'&'||labels[5], labels[5]||'&'||labels[2]))
   UNION ALL
SELECT labels[3],
    (SELECT doc_count FROM matrix WHERE term in (labels[3]||'&'||labels[1], labels[1]||'&'||labels[3])),
    (SELECT doc_count FROM matrix WHERE term in (labels[3]||'&'||labels[2], labels[2]||'&'||labels[3])),
    (SELECT doc_count FROM matrix WHERE term = labels[3]),
    (SELECT doc_count FROM matrix WHERE term in (labels[3]||'&'||labels[4], labels[4]||'&'||labels[3])),
    (SELECT doc_count FROM matrix WHERE term in (labels[3]||'&'||labels[5], labels[5]||'&'||labels[3]))
   UNION ALL
SELECT labels[4],
    (SELECT doc_count FROM matrix WHERE term in (labels[4]||'&'||labels[1], labels[1]||'&'||labels[4])),
    (SELECT doc_count FROM matrix WHERE term in (labels[4]||'&'||labels[2], labels[2]||'&'||labels[4])),
    (SELECT doc_count FROM matrix WHERE term in (labels[4]||'&'||labels[3], labels[3]||'&'||labels[4])),
    (SELECT doc_count FROM matrix WHERE term = labels[4]),
    (SELECT doc_count FROM matrix WHERE term in (labels[4]||'&'||labels[5], labels[5]||'&'||labels[4]))
   UNION ALL
SELECT labels[5],
    (SELECT doc_count FROM matrix WHERE term in (labels[5]||'&'||labels[1], labels[1]||'&'||labels[5])),
    (SELECT doc_count FROM matrix WHERE term in (labels[5]||'&'||labels[2], labels[2]||'&'||labels[5])),
    (SELECT doc_count FROM matrix WHERE term in (labels[5]||'&'||labels[3], labels[3]||'&'||labels[5])),
    (SELECT doc_count FROM matrix WHERE term in (labels[5]||'&'||labels[4], labels[4]||'&'||labels[5])),
    (SELECT doc_count FROM matrix WHERE term = labels[5])

$$;




-- src/lib.rs:46
-- finalize
CREATE OR REPLACE FUNCTION zdb.get_search_analyzer(index regclass, field text) RETURNS text
    IMMUTABLE STRICT PARALLEL SAFE
    LANGUAGE sql AS
$$
WITH properties AS (
    SELECT zdb.index_mapping(index) -> zdb.index_name(index) -> 'mappings' -> 'properties' ->
           field AS props)
SELECT COALESCE(props ->> 'search_analyzer', props ->> 'analyzer', 'standard')
FROM properties
LIMIT 1;

$$;

CREATE OR REPLACE FUNCTION zdb.get_index_analyzer(index regclass, field text) RETURNS text
    IMMUTABLE STRICT PARALLEL SAFE
    LANGUAGE sql AS
$$
WITH properties AS (
    SELECT zdb.index_mapping(index) -> zdb.index_name(index) -> 'mappings' -> 'properties' ->
           field AS props)
SELECT COALESCE(props ->> 'index_analyzer', props ->> 'analyzer', 'standard')
FROM properties
LIMIT 1;

$$;

CREATE OR REPLACE FUNCTION zdb.get_highlight_analysis_info(index_name regclass, field text)
    RETURNS TABLE
            (
                type             text,
                normalizer       text,
                index_tokenizer  text,
                search_tokenizer text
            )
    LANGUAGE sql
AS
$$
WITH mapping AS (SELECT jsonb_extract_path(
                                zdb.index_mapping(index_name),
                                VARIADIC ARRAY [zdb.index_name(index_name), 'mappings', 'properties'] ||
                                         string_to_array(replace(field, '.', '.properties.'), '.')) AS mapping)
SELECT mapping ->> 'type'                                        AS type,
       mapping ->> 'normalizer'                                  AS normalizer,
       mapping ->> 'analyzer'        AS index_analyzer,
       mapping ->> 'search_analyzer' AS search_analyzer
FROM mapping;
$$;

CREATE OR REPLACE FUNCTION zdb.get_null_copy_to_fields(index regclass) RETURNS TABLE(field_name text, mapping jsonb)
    IMMUTABLE STRICT PARALLEL SAFE
    LANGUAGE sql AS
$$
WITH field_mapping AS (
    with properties as (
        select zdb.index_mapping(index) -> zdb.index_name(index) -> 'mappings' -> 'properties' as properties
    )
    SELECT key, properties.properties -> key as mapping
    FROM (
             SELECT jsonb_object_keys(properties.properties) as key
             FROM properties
         ) x,
         properties
)
SELECT *
FROM field_mapping
WHERE mapping ->> 'type' = 'text'
  and mapping ->> 'copy_to' is null
$$;

CREATE FUNCTION zdb.version() RETURNS TABLE (schema_version text, internal_version text) LANGUAGE sql AS $$
SELECT zdb.schema_version(), zdb.internal_version();
$$;


