<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js zombo">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Type Mapping</title>


        <!-- Custom HTML head -->
<link href="https://fonts.googleapis.com/css?family=Josefin+Slab|Open+Sans|Raleway" rel="stylesheet">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">
        <link rel="stylesheet" href="../zombo-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../zombo.css">
        <link rel="stylesheet" href="../zombo-highlight.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = "zombo";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('zombo')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting-started.html"><strong aria-hidden="true">2.</strong> Getting started tutorial</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="../usage/zql-queries.html"><strong aria-hidden="true">3.</strong> ZQL queries</a></li><li class="chapter-item expanded "><a href="../usage/elasticsearch-dsl-queries.html"><strong aria-hidden="true">4.</strong> ElasticSearch QueryDSL queries</a></li><li class="chapter-item expanded "><a href="../usage/using-sql-functions.html"><strong aria-hidden="true">5.</strong> Using SQL functions</a></li><li class="chapter-item expanded "><a href="../usage/scoring.html"><strong aria-hidden="true">6.</strong> Scoring</a></li><li class="chapter-item expanded "><a href="../usage/highlighting.html"><strong aria-hidden="true">7.</strong> Highlighting</a></li><li class="chapter-item expanded "><a href="../usage/cross-index-joins.html"><strong aria-hidden="true">8.</strong> Cross-index joins</a></li><li class="chapter-item expanded "><a href="../usage/aggregations.html"><strong aria-hidden="true">9.</strong> Aggregations</a></li><li class="chapter-item expanded "><a href="../usage/aggregate-builder-api.html"><strong aria-hidden="true">10.</strong> Aggregate Builder API</a></li><li class="chapter-item expanded "><a href="../usage/_cat-api_.html"><strong aria-hidden="true">11.</strong> ElasticSearch _cat API</a></li><li class="chapter-item expanded "><a href="../usage/postgis-support.html"><strong aria-hidden="true">12.</strong> PostGIS Support</a></li><li class="chapter-item expanded affix "><li class="part-title">Administration</li><li class="chapter-item expanded "><a href="../administration/binary-installation.html"><strong aria-hidden="true">13.</strong> Binary installation</a></li><li class="chapter-item expanded "><a href="../administration/source-installation.html"><strong aria-hidden="true">14.</strong> Source installation</a></li><li class="chapter-item expanded "><a href="../administration/configuration.html"><strong aria-hidden="true">15.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../administration/index-management.html"><strong aria-hidden="true">16.</strong> Index Management</a></li><li class="chapter-item expanded "><a href="../usage/creating-a-zombodb-index.html"><strong aria-hidden="true">17.</strong> Creating a ZomboDB Index in Postgres</a></li><li class="chapter-item expanded affix "><li class="part-title">Internals</li><li class="chapter-item expanded "><a href="../internals/important-things-to-know.html"><strong aria-hidden="true">18.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="../internals/type-mapping.html" class="active"><strong aria-hidden="true">19.</strong> Type Mapping</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="zombo">Zombo (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Cool</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="type-mapping"><a class="header" href="#type-mapping">Type Mapping</a></h1>
<p>ZomboDB provides a set of default mappings between Postgres and Elasticsearch for Postgres’ common data types.  ZomboDB also includes a complete set of custom Postgres DOMAINs that represent all of the foreign languages that Elasticsearch supports.</p>
<p>This document attempts to explain how ZomboDB maps Postgres data types to Elasticsearch data types, how they’re analyzed (if at all), and how these things can be controlled through a combination of Postgres’ type system and ZomboDB-specific functions.</p>
<h2 id="common-data-types"><a class="header" href="#common-data-types">Common Data Types</a></h2>
<p>These are the default mappings:</p>
<table><thead><tr><th>Postgres Type</th><th>Elasticsearch JSON Mapping Definition</th></tr></thead><tbody>
<tr><td><code>bytea</code></td><td><code>{&quot;type&quot;: &quot;binary&quot;}</code></td></tr>
<tr><td><code>boolean</code></td><td><code>{&quot;type&quot;: &quot;boolean&quot;}</code></td></tr>
<tr><td><code>smallint</code></td><td><code>{&quot;type&quot;: &quot;short&quot;}</code></td></tr>
<tr><td><code>integer</code></td><td><code>{&quot;type&quot;: &quot;integer&quot;}</code></td></tr>
<tr><td><code>bigint</code></td><td><code>{&quot;type&quot;: &quot;long&quot;}</code></td></tr>
<tr><td><code>real</code></td><td><code>{&quot;type&quot;: &quot;float&quot;}</code></td></tr>
<tr><td><code>double precision</code></td><td><code>{&quot;type&quot;: &quot;double&quot;}</code></td></tr>
<tr><td><code>character varying</code></td><td><code>{&quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;, &quot;normalizer&quot;: &quot;lowercase&quot;, &quot;ignore_above&quot;: 10922}</code></td></tr>
<tr><td><code>text</code></td><td><code>{&quot;type&quot;: &quot;text&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;, &quot;analyzer&quot;: &quot;zdb_standard&quot;, &quot;fielddata&quot;: true}</code></td></tr>
<tr><td><code>time without time zone</code></td><td><code>{&quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;HH:mm:ss.SSSSSS&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>time with time zone</code></td><td><code>{&quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;HH:mm:ss.SSSSSSZZ&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>date</code></td><td><code>{&quot;type&quot;: &quot;date&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>timestamp without time zone</code></td><td><code>{&quot;type&quot;: &quot;date&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>timestamp with time zone</code></td><td><code>{&quot;type&quot;: &quot;date&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>json</code></td><td><code>{&quot;type&quot;: &quot;nested&quot;, &quot;include_in_parent&quot;: true}</code></td></tr>
<tr><td><code>jsonb</code></td><td><code>{&quot;type&quot;: &quot;nested&quot;, &quot;include_in_parent&quot;: true}</code></td></tr>
<tr><td><code>inet</code></td><td><code>{&quot;type&quot;: &quot;ip&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>point</code></td><td><code>{&quot;type&quot;: &quot;geo_point&quot;}</code></td></tr>
<tr><td><code>zdb.fulltext</code></td><td><code>{&quot;type&quot;: &quot;text&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;, &quot;analyzer&quot;: &quot;zdb_standard&quot;}</code></td></tr>
<tr><td><code>zdb.fulltext_with_shingles</code></td><td><code>{&quot;type&quot;: &quot;text&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;, &quot;analyzer&quot;: &quot;fulltext_with_shingles&quot;, &quot;search_analyzer&quot;: &quot;fulltext_with_shingles_search&quot;}</code></td></tr>
<tr><td><code>geography</code> (from postgis)</td><td><code>{&quot;type&quot;: &quot;geo_shape&quot;}</code></td></tr>
<tr><td><code>geometry</code> (from postgis)</td><td><code>{&quot;type&quot;: &quot;geo_shape&quot;}</code></td></tr>
<tr><td><code>geography(Point, x)</code> (from postgis)</td><td><code>{&quot;type&quot;: &quot;geo_point&quot;}</code></td></tr>
<tr><td><code>geometry(Point, x)</code> (from postgis)</td><td><code>{&quot;type&quot;: &quot;geo_point&quot;}</code></td></tr>
<tr><td>Some things to note from the above:</td><td></td></tr>
</tbody></table>
<ul>
<li>Columns of type <code>bytea</code> are automatically encoded as <code>base64</code> for proper storage by Elasticsearch</li>
<li>Columns of type <code>character varying (varchar)</code> are <strong>not</strong> analyzed by Elasticsearch.  They’re indexed as whole values, but are converted to lowercase</li>
<li>Columns of type <code>text</code> <strong>are</strong> analyzed by Elasticsearch using its <code>standard</code> analyzer, and the individual terms are converted to lowercase</li>
<li>Columns of type <code>json/jsonb</code> are mapped to Elasticsearch’s <code>nested</code> object with a dynamic template that treats “string” properties as if they’re of type <code>character varying</code> (ie, unanalyzed exact, lowercased values), and treats “date” properties as if they’re dates, accepting a wide range of date formats</li>
<li>Columns of type <code>geometry</code> and <code>geography</code> are automatically converted to GeoJson at index time and translated to CRS <code>4326</code>
In all cases above, arrays of Postgres types are fully supported.</li>
</ul>
<h2 id="zombodbs-custom-domain-types"><a class="header" href="#zombodbs-custom-domain-types">ZomboDB’s Custom DOMAIN types</a></h2>
<p>ZomboDB includes a few custom Postgres DOMAIN types which can be used as column types in your tables.</p>
<p><code>zdb.fulltext</code> works exactly the same way as a column of type <code>text</code>, but exists so as to provide an extra hint of metadata to client applications indicating that the column likely contains a large amount of text.</p>
<p><code>zdb.fulltext_with_shingles</code> is akin to <code>zdb.fulltext</code> but uses a 2-gram single filter for high-speed right-truncated wildcard support.</p>
<h2 id="language-specific-domain-types"><a class="header" href="#language-specific-domain-types">Language-specific DOMAIN types</a></h2>
<p>As noted earlier, ZomboDB provide support for all of Elasticsearch’s language analyzers, exposed as Postgres DOMAINs.  This allows you to create tables with columns of type <code>portuguese</code> or <code>thai</code>, for example.  The complete set of language domains is:</p>
<pre><code>arabic, armenian, basque, brazilian, bulgarian, catalan, chinese, cjk, 
czech, danish, dutch, english, finnish, french, galician, german, greek, 
hindi, hungarian, indonesian, irish, italian, latvian, norwegian, persian, 
portuguese, romanian, russian, sorani, spanish, swedish, turkish, thai
</code></pre>
<p>More details on how Elasticsearch analyzes each of these can be found in its <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html">language analyzers</a> documentation.</p>
<h1 id="defining-custom-analyzers-filters-normalizers-type-mappings"><a class="header" href="#defining-custom-analyzers-filters-normalizers-type-mappings">Defining Custom Analyzers, Filters, Normalizers, Type Mappings</a></h1>
<p>ZomboDB provides a set of SQL-level functions that allow you to define custom analyzer chains, filters, normalizers, along with custom type mappings.</p>
<p>These are designed to be used with Postgres’ <code>CREATE DOMAIN</code> command where the domain name exactly matches the analyzer name.</p>
<h2 id="analysis-definition-functions"><a class="header" href="#analysis-definition-functions">Analysis Definition Functions</a></h2>
<pre><code class="language-sql">FUNCTION zdb.define_analyzer(name text, definition json)
</code></pre>
<p>Allows for the definition of Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-custom-analyzer.html">custom analyzers</a>.  Depending on the complexity of the analyzer you need to define, you’ll likely first need to define custom filters or tokenizers, as described below.</p>
<p>In order to use a custom analyzer you must make a custom Postgres DOMAIN with the same name, and then you can use that DOMAIN as column type in your tables.</p>
<p>You can also use the custom analyzer in conjunction with a custom field mapping via the <code>zdb.define_field_mapping()</code> function described below.</p>
<p>Note that making changes to any of the analysis definitions will require a <code>REINDEX</code> of any indices that use the things you changed.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_filter(name text, definition json)
</code></pre>
<p>Allows for the definition of a custom Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenfilters.html">token filter</a>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_char_filter(name text, definition json) 
</code></pre>
<p>Allows for the definition of a custom Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html">character filter</a>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_tokenizer(name text, definition json)
</code></pre>
<p>Allows for the definition of a custom Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html">tokenizer</a>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_normalizer(name text, definition json) 
</code></pre>
<p>Allows for the definition of a custom Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-normalizers.html">normalizer</a>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_type_mapping(type_name regtype, definition json)
</code></pre>
<p>If you need to define a type mapping for a Postgres datatype that isn’t included in ZomboDB’s defaults (<code>citext</code>, for example), this is the function to use.</p>
<pre><code class="language-sql">FUNCTION zdb.define_type_mapping(type_name regtype, funcid regproc)
</code></pre>
<p>If you need to define a type mapping for a Postgres datatype that isn’t included in ZomboDB’s defaults and if doing so
requires looking at the <code>typmod</code> value as it’s defined for the column being indexed, use this function.</p>
<p>The first argument is the type name (as a <code>regtype</code>) and the second argument is the <code>regproc</code> oid of the function ZDB
should call to generate the mapping.</p>
<p>That function should take two arguments, the first being of type <code>regtype</code> and the second being an integer that is the
<code>typmod</code> value.</p>
<h2 id="field-specific-mapping-functions"><a class="header" href="#field-specific-mapping-functions">Field-Specific Mapping Functions</a></h2>
<p>Rather than using DOMAIN types to map Postgres types to an Elasticsearch analyzer, you can also define field-specific mappings per table and field.</p>
<p>This approach can be quite powerful as you can set, per field, all the mapping properties that Elasticsearch allows, and you don’t need to create and manage custom DOMAIN types.</p>
<pre><code class="language-sql">FUNCTION zdb.define_field_mapping(table_name regclass, field_name text, definition json) 
</code></pre>
<p>If you need to define a field mapping for a specific field in a specific table, this is the function to use.  You can specify any <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html">custom mapping definition json</a> that is supported by Elasticsearch.</p>
<p>Creating or changing a field mapping requires a <code>REINDEX</code> of the specified table.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_es_only_field(table_name regclass, field_name text, definition json)
</code></pre>
<p>If you want a custom field that only exists in the Elasticsearch index (perhaps as a target to the mapping <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/copy-to.html"><code>copy_to</code></a> property, you can use this.</p>
<p>Any field you create here can be searched and used with aggregates, but won’t be SELECT-able by Postgres.</p>
<p>Creating or changing an Elasticearch-only field requires a <code>REINDEX</code> of the specified table.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-sql">SELECT zdb.define_tokenizer('example_tokenizer', '{
          &quot;type&quot;: &quot;pattern&quot;,
          &quot;pattern&quot;: &quot;_&quot;
        }');
SELECT zdb.define_analyzer('example', '{
          &quot;tokenizer&quot;: &quot;example_tokenizer&quot;
        }');
CREATE DOMAIN example AS text;
CREATE TABLE foo (
   id serial8,
   some_field example
);
CREATE INDEX idxfoo ON foo USING zombodb ((foo.*));
INSERT INTO foo (some_field) VALUES ('this_is_a_test');
SELECT * FROM foo WHERE foo ==&gt; 'some_field:this';
</code></pre>
<h1 id="testing-analyzers"><a class="header" href="#testing-analyzers">Testing Analyzers</a></h1>
<p>ZomboDB provides a few functions that can be used to evaluate how an analyzer actually tokenizes text.</p>
<pre><code class="language-sql">FUNCTION zdb.analyze_with_field(
	index regclass, 
	field text, 
	text text) 
RETURNS TABLE (
	type text, 
	token text, 
	&quot;position&quot; int, 
	start_offset int, 
	end_offset int)
</code></pre>
<p>This function allows you to evaluate text analysis using the analyzer already defined for a particular field.</p>
<p>Examples:</p>
<pre><code class="language-sql">SELECT * FROM zdb.analyze_with_field('idxproducts', 'keywords', 'this is a test');
 type |     token      | position | start_offset | end_offset 
------+----------------+----------+--------------+------------
 word | this is a test |        0 |            0 |         14
(1 row)
</code></pre>
<pre><code class="language-sql">SELECT * FROM zdb.analyze_with_field('idxproducts', 'long_description', 'this is a test');
    type    | token | position | start_offset | end_offset 
------------+-------+----------+--------------+------------
 &lt;ALPHANUM&gt; | this  |        0 |            0 |          4
 &lt;ALPHANUM&gt; | is    |        1 |            5 |          7
 &lt;ALPHANUM&gt; | a     |        2 |            8 |          9
 &lt;ALPHANUM&gt; | test  |        3 |           10 |         14
(4 rows)
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION zdb.analyze_text(
	index regclass, 
	analyzer text, 
	text text) 
RETURNS TABLE (
	type text, 
	token text, 
	&quot;position&quot; int, 
	start_offset int, 
	end_offset int)
</code></pre>
<p>This function allows you to evaluate analysis using a specific analyzer name, either built-in to Elasticsearch or one of the custom analyzers you may have defined.</p>
<p>Examples:</p>
<pre><code class="language-sql">SELECT * FROM zdb.analyze_text('idxproducts', 'keyword', 'this is a test');
 type |     token      | position | start_offset | end_offset 
------+----------------+----------+--------------+------------
 word | this is a test |        0 |            0 |         14
</code></pre>
<pre><code class="language-sql">SELECT * FROM zdb.analyze_text('idxproducts', 'standard', 'this is a test');
    type    | token | position | start_offset | end_offset 
------------+-------+----------+--------------+------------
 &lt;ALPHANUM&gt; | this  |        0 |            0 |          4
 &lt;ALPHANUM&gt; | is    |        1 |            5 |          7
 &lt;ALPHANUM&gt; | a     |        2 |            8 |          9
 &lt;ALPHANUM&gt; | test  |        3 |           10 |         14
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION zdb.analyze_custom(
	index regclass, 
	text text DEFAULT NULL, 
	tokenizer text DEFAULT NULL, 
	normalizer text DEFAULT NULL, 
	filter text[] DEFAULT NULL, 
	char_filter text[] DEFAULT NULL) 
RETURNS TABLE (
	type text, 
	token text, 
	&quot;position&quot; int, 
	start_offset int, 
	end_offset int)
</code></pre>
<p>This function allows you to dynamically define a custom analyzer and test it in real-time.</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT * FROM zdb.analyze_custom(
	index=&gt;'idxproducts', 
	text=&gt;'This is a test, 42 https://www.zombodb.com', 
	tokenizer=&gt;'whitespace', 
	filter=&gt;ARRAY['lowercase']);
 type |          token          | position | start_offset | end_offset 
------+-------------------------+----------+--------------+------------
 word | this                    |        0 |            0 |          4
 word | is                      |        1 |            5 |          7
 word | a                       |        2 |            8 |          9
 word | test,                   |        3 |           10 |         15
 word | 42                      |        4 |           16 |         18
 word | https://www.zombodb.com |        5 |           19 |         42
(6 rows)
</code></pre>
<h1 id="about-elasticsearchs-_all-field"><a class="header" href="#about-elasticsearchs-_all-field">About Elasticsearch’s <code>_all</code> Field</a></h1>
<p>In short, ZomboDB disables Elasticsearch’s <code>_all</code> field and instead configures its own field named <code>zdb_all</code>.  By default, all non-numeric field types are added to the <code>zdb_all</code> field.</p>
<p>ZomboDB does this to maintain compatability between Elasticsearch 5 and Elasticsearch 6, where <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-all-field.html">ES 6 deprecates the <code>_all</code> field</a>.</p>
<h1 id="custom-json-conversion"><a class="header" href="#custom-json-conversion">Custom JSON Conversion</a></h1>
<p>In general ZomboDB uses the equivalent of Postgres’ <code>to_json()</code> function to convert individual columns to JSON when indexing.<br />
However, ZomboDB does provide the ability to provide custom json conversion functions for any data type, and it installs
custom conversion functions for Postgres’ <code>point</code> type along with PostGIS’ <code>geometry</code> and <code>geography</code> types.</p>
<pre><code class="language-sql">FUNCTION zdb.define_type_conversion(
  typeoid regtype, 
  funcoid regproc) 
RETURNS void
</code></pre>
<p>If you have a custom datatype that you need to convert to json, you need to make a conversion function that takes a
single argument that is the type you wish to convert and returns json.  Then you’ll call this function to associate
your type with your conversion function.</p>
<p>You’ll also need to define a custom type mapping using <code>zdb.define_type_mapping()</code> (see above).</p>
<p>An example might be:</p>
<pre><code class="language-sql">CREATE TYPE example AS (
  title varchar(255),
  description text
);

-- custom json conversion function
CREATE OR REPLACE FUNCTION example_type_to_json(example) RETURNS json IMMUTABLE STRICT LANGUAGE sql AS $$
  SELECT json_build_object('title', $1.title, 'description', $1.description);
$$;

-- associate the type with the custom json conversion function
SELECT zdb.define_type_conversion('example'::regtype, 'example_type_to_json'::regproc);

-- define a type mapping for 'example'
SELECT zdb.define_type_mapping('example'::regtype, '{&quot;type&quot;:&quot;nested&quot;}');
</code></pre>
<p>Now you can create a table using that type and create a ZomboDB index on it:</p>
<pre><code class="language-sql">CREATE TABLE test (
  id serial8 NOT NULL PRIMARY KEY,
  data example
);

CREATE INDEX idxtest ON test USING zombodb ((test.*));

INSERT INTO test (data) VALUES (('this is the title', 'this is the description'));

SELECT * FROM test WHERE test ==&gt; dsl.nested('data', dsl.term('data.title', 'this is the title'));
 id |                      data                       
----+-------------------------------------------------
  1 | (&quot;this is the title&quot;,&quot;this is the description&quot;)
(1 row)

</code></pre>
<h1 id="similarity-module-support"><a class="header" href="#similarity-module-support">Similarity Module Support</a></h1>
<p>ZomboDB supports <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-similarity.html">Elasticsearch’s “Similarity Module”</a>) in a manner similar to the above.</p>
<p>This allows you to define different similarity algorithms and apply them to individual field mappings.</p>
<p>It uses the function</p>
<pre><code class="language-sql">FUNCTION zdb.define_similarity(name text, definition json) 
</code></pre>
<p>An short example of defining <code>LMJelinekMercer</code> algorithm:</p>
<pre><code class="language-sql">SELECT zdb.define_similarity('my_similarity', '
{
    &quot;type&quot;: &quot;LMJelinekMercer&quot;,
    &quot;lambda&quot;: 0.075
}
');
</code></pre>
<p>And then we’d define it for a field in a table.  Note that in doing so, we are required to define the entire
field mapping for this field.</p>
<pre><code class="language-sql">CREATE TABLE test (
  id serial8 NOT NULL PRIMARY KEY,
  data text
);

SELECT zdb.define_field_mapping('test', 'data', '
{
    &quot;type&quot;: &quot;text&quot;,
    &quot;analyzer&quot;: &quot;zdb_standard&quot;,
    &quot;similarity&quot;: &quot;my_similarity&quot;
}
');

CREATE INDEX idxtest ON test USING zombodb ((test.*));
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../internals/important-things-to-know.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../internals/important-things-to-know.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
