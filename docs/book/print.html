<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js zombo">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
<link href="https://fonts.googleapis.com/css?family=Josefin+Slab|Open+Sans|Raleway" rel="stylesheet">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">
        <link rel="stylesheet" href="zombo-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="zombo.css">
        <link rel="stylesheet" href="zombo-highlight.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "zombo";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('zombo')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting started tutorial</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="usage/zql-queries.html"><strong aria-hidden="true">3.</strong> ZQL queries</a></li><li class="chapter-item expanded "><a href="usage/elasticsearch-dsl-queries.html"><strong aria-hidden="true">4.</strong> ElasticSearch QueryDSL queries</a></li><li class="chapter-item expanded "><a href="usage/using-sql-functions.html"><strong aria-hidden="true">5.</strong> Using SQL functions</a></li><li class="chapter-item expanded "><a href="usage/scoring.html"><strong aria-hidden="true">6.</strong> Scoring</a></li><li class="chapter-item expanded "><a href="usage/highlighting.html"><strong aria-hidden="true">7.</strong> Highlighting</a></li><li class="chapter-item expanded "><a href="usage/cross-index-joins.html"><strong aria-hidden="true">8.</strong> Cross-index joins</a></li><li class="chapter-item expanded "><a href="usage/aggregations.html"><strong aria-hidden="true">9.</strong> Aggregations</a></li><li class="chapter-item expanded "><a href="usage/aggregate-builder-api.html"><strong aria-hidden="true">10.</strong> Aggregate Builder API</a></li><li class="chapter-item expanded "><a href="usage/_cat-api_.html"><strong aria-hidden="true">11.</strong> ElasticSearch _cat API</a></li><li class="chapter-item expanded "><a href="usage/postgis-support.html"><strong aria-hidden="true">12.</strong> PostGIS Support</a></li><li class="chapter-item expanded affix "><li class="part-title">Administration</li><li class="chapter-item expanded "><a href="administration/binary-installation.html"><strong aria-hidden="true">13.</strong> Binary installation</a></li><li class="chapter-item expanded "><a href="administration/source-installation.html"><strong aria-hidden="true">14.</strong> Source installation</a></li><li class="chapter-item expanded "><a href="administration/configuration.html"><strong aria-hidden="true">15.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="administration/index-management.html"><strong aria-hidden="true">16.</strong> Index Management</a></li><li class="chapter-item expanded "><a href="usage/creating-a-zombodb-index.html"><strong aria-hidden="true">17.</strong> Creating a ZomboDB Index in Postgres</a></li><li class="chapter-item expanded affix "><li class="part-title">Internals</li><li class="chapter-item expanded "><a href="internals/important-things-to-know.html"><strong aria-hidden="true">18.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="internals/type-mapping.html"><strong aria-hidden="true">19.</strong> Type Mapping</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="zombo">Zombo (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Cool</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>ZomboDB: Integrating ElasticSearch and Postgres </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Assuming you’ve followed the <a href="/administration/binary-installation.html">Installation instructions</a>, using ZomboDB is extremely simple.</p>
<p>Since ZomboDB is an actual Postgres index type, creating and querying its indices is about as simple as any other SQL query you might execute in Postgres.</p>
<p>This guide intends to demonstrate the basics using <code>psql</code>.  A few assumptions I’m making about you are:</p>
<ul>
<li>You have a functional Postgres 10 Server</li>
<li>You have a functional Elasticsearch 7.x cluster (even if just one node)</li>
<li>You’re familiar with Postgres and <code>psql</code></li>
<li>You’re familiar with Elasticsearch on at least a high-level</li>
</ul>
<p>ZomboDB’s intent is to abstract away Elasticsearch such that it appears as any other Postgres index, so the latter assumption isn’t necessarily important.</p>
<h2 id="create-a-database-and-the-zombodb-extension"><a class="header" href="#create-a-database-and-the-zombodb-extension">Create a Database and the ZomboDB Extension</a></h2>
<p>Lets begin with a new database named <code>tutorial</code>.</p>
<pre><code>$ createdb tutorial
$ psql tutorial
psql (10.1)
Type &quot;help&quot; for help.

tutorial=# 
</code></pre>
<p>The first thing you need to do is create the ZomboDB extension in a database.</p>
<p>If you’re unfamiliar with Postgres extensions, spend a few minutes reading <a href="http://www.postgresql.org/docs/10/static/sql-createextension.html">up on them</a>.</p>
<p>Now, lets create the extension:</p>
<pre><code class="language-sql">tutorial=# 
CREATE EXTENSION zombodb;
CREATE EXTENSION
tutorial=#
</code></pre>
<p>ZomboDB installs itself into a new schema named <code>zdb</code>.  It also creates a schema called <code>dsl</code> which we’ll cover in the <a href="/usage/elasticsearch-dsl-queries.html">query syntax</a> documentation.</p>
<p>The idea here is that you would never add the <code>zdb</code> schema to your <code>SEARCH_PATH</code>, but you might want to add the <code>dsl</code> schema for convenience while querying.</p>
<p>To prove to yourself that the extension is really installed, you can double-check the <code>pg_extension</code> system catalog:</p>
<pre><code class="language-sql">tutorial=# 
SELECT * FROM pg_extension;
 extname | extowner | extnamespace | extrelocatable | extversion | extconfig | extcondition 
---------+----------+--------------+----------------+------------+-----------+--------------
 plpgsql |       10 |           11 | f              | 1.0        |           | 
 zombodb |       10 |         2200 | t              | 1.0.0      |           | 
(2 rows)

tutorial=# 
</code></pre>
<p>Here you can see that ZomboDB v1.0.0 is really installed.</p>
<h2 id="create-and-populate-a-table"><a class="header" href="#create-and-populate-a-table">Create and Populate a Table</a></h2>
<p>Nothing too out of the ordinary here.  Lets create a simple table that might represent a product catalog.</p>
<pre><code class="language-sql">tutorial=# 
CREATE TABLE products (
    id SERIAL8 NOT NULL PRIMARY KEY,
    name text NOT NULL,
    keywords varchar(64)[],
    short_summary text,
    long_description zdb.fulltext, 
    price bigint,
    inventory_count integer,
    discontinued boolean default false,
    availability_date date
);
CREATE TABLE
tutorial=#
</code></pre>
<p>Before we populate the table with some data, notice that the <code>long_description</code> field has a datatype of <code>zdb.fulltext</code>.</p>
<p><code>zdb.fulltext</code> is a <a href="http://www.postgresql.org/docs/10.0/static/sql-createdomain.html">DOMAIN type</a> that sits on top of the standard <code>text</code> datatype.  As far as Postgres is concerned, it’s functionally no different than the <code>text</code> datatype, but it has special meaning to ZomboDB when indexing and searching (which we’ll discuss in a bit).</p>
<p>ZomboDB will automatically create an Elasticsearch mapping that will analyze fields of type <code>text</code>, including ZomboDB’s DOMAIN type <code>zdb.fulltext</code>.</p>
<p>Lets COPY some data into this table before we move on to creating a ZomboDB index and querying.  Rather than fill this document with boring data, just COPY it using curl:</p>
<pre><code class="language-sql">tutorial=# 
COPY products FROM PROGRAM 'curl https://raw.githubusercontent.com/zombodb/zombodb/master/TUTORIAL-data.dmp';
COPY 4
tutorial=#
</code></pre>
<p>Which should give you 4 rows that look a lot like:</p>
<pre><code> id |      name      |                     keywords                      |                  short_summary                  |                                              long_description                                              | price | inventory_count | discontinued | availability_date 
----+----------------+---------------------------------------------------+-------------------------------------------------+------------------------------------------------------------------------------------------------------------+-------+-----------------+--------------+-------------------
  1 | Magical Widget | {magical,widget,round}                            | A widget that is quite magical                  | Magical Widgets come from the land of Magicville and are capable of things you can't imagine               |  9900 |              42 | f            | 2015-08-31
  2 | Baseball       | {baseball,sports,round}                           | It's a baseball                                 | Throw it at a person with a big wooden stick and hope they don't hit it                                    |  1249 |               2 | f            | 2015-08-21
  3 | Telephone      | {communication,primitive,&quot;alexander graham bell&quot;} | A device to enable long-distance communications | Use this to call your friends and family and be annoyed by telemarketers.  Long-distance charges may apply |  1899 |             200 | f            | 2015-08-11
  4 | Box            | {wooden,box,&quot;negative space&quot;,square}              | Just an empty box made of wood                  | A wooden container that will eventually rot away.  Put stuff it in (but not a cat).                        | 17000 |               0 | t            | 2015-07-01
(4 rows)
</code></pre>
<h2 id="creating-an-index"><a class="header" href="#creating-an-index">Creating an Index</a></h2>
<p>In its basic form, a ZomboDB index is essentially a “covering index” that includes all the columns.</p>
<p>Behind the scenes, ZomboDB automatically coverts the row being indexed into JSON because JSON is the format Elasticsearch requires.</p>
<p>Knowing this, lets create an index on our <code>products</code> table:</p>
<pre><code class="language-sql">tutorial=# 
           CREATE INDEX idxproducts 
                     ON products 
                  USING zombodb ((products.*))
                   WITH (url='http://localhost:9200/');
CREATE INDEX
tutorial=# 
</code></pre>
<p>So what we’ve done is create an index named <code>idxproducts</code> on the <code>products</code> table, we’ve indicated that we want the index to be of type <code>zombodb</code> (via <code>USING zombodb</code>) as opposed to say “btree” or “gin” or “gist”, and that it should index all columns in from the table (via, <code>(products.*)</code>).</p>
<p>We’ve also specified the URL to our Elasticsearch cluster (<code>WITH (url='...')</code>).</p>
<p>(a few other index options exist to control the number of Elasticsearch <code>shards</code> and <code>replicas</code> (among other things), but we’ll consider those advanced-use features and outside the scope of this document.)</p>
<p>When we ran <code>CREATE INDEX</code> not only did we create an index within Postgres, we also created one within Elasticsearch.</p>
<p>An Elasticsearch type mapping was automatically generated based on the structure of the <code>products</code> table as well.</p>
<p>Lets move on to querying...</p>
<h2 id="full-text-queries"><a class="header" href="#full-text-queries">Full-text Queries</a></h2>
<p>In order to ensure the ZomboDB index is used, we’ll be making use of a custom operator: </p>
<ul>
<li><code>==&gt;</code> is defined as taking <code>::anyelement</code> on the left and <code>::zdbquery</code> on the right.</li>
</ul>
<p><code>::zdbquery</code> is a custom data type that ZomboDB installs which represents an Elasticsearch query in its QueryDSL JSON form.</p>
<p>If the query isn’t valid json (as shown below), then it is automatically considered to be an Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax">Query String Syntax</a> query.</p>
<p>Building Elasticsearch QueryDSL can be complicated, but ZomboDB provides an entire set of <a href="/usage/elasticsearch-dsl-queries.html">SQL-based builder functions</a> to make this process simple and type-safe.</p>
<p>A typical query might be:</p>
<pre><code class="language-sql">tutorial=# 
SELECT * FROM products WHERE products ==&gt; 'sports, box';
 id |   name   |           keywords            |         short_summary          |                                  long_description                                   | price | inventory_count | discontinued 
----+----------+-------------------------------+--------------------------------+-------------------------------------------------------------------------------------+-------+-----------------+--------------
  4 | Box      | {wooden,box,&quot;negative space&quot;} | Just an empty box made of wood | A wooden container that will eventually rot away.  Put stuff it in (but not a cat). | 17000 |               0 | t
  2 | Baseball | {baseball,sports}             | It's a baseball                | Throw it at a person with a big wooden stick and hope they don't hit it             |  1249 |               2 | f
(2 rows)

tutorial=# 
</code></pre>
<p>And its query plan is:</p>
<pre><code class="language-sql">tutorial=# 
 EXPLAIN SELECT * FROM products WHERE products ==&gt; 'sports, box';
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Index Scan using idxproducts on products  (cost=0.00..4.06 rows=4 width=153)
   Index Cond: (products.* ==&gt; 'sports or box'::zdbquery)
(2 rows)

tutorial=# 
</code></pre>
<p>From here, it’s just a matter of coming up with a full-text query to answer your question.  See the <a href="./usage/zql-queries.html">Query Syntax documentation</a> or the <a href="./usage/generating-queries.html">DSL Query Builder documentation</a> for details on what the full-text query syntax can do.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In summary, the process of getting up and running is simply:</p>
<pre><code class="language-sql">CREATE EXTENSION zombodb;
CREATE TABLE foo ...;
&lt;load data&gt;
CREATE INDEX ON foo USING zombodb ((foo.*) WITH (...);
SELECT FROM foo WHERE foo ==&gt; '...';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zql-queries"><a class="header" href="#zql-queries">ZQL queries</a></h1>
<p>ZQL (Zombo Query Language) is designed with many conveniences for text-search operations.</p>
<p>An example query might look like:</p>
<pre><code>    beer wine cheese w/3 food
</code></pre>
<p>Which would find all documents that contain the words <code>beer</code> <strong>and</strong> <code>wine</code> <strong>and</strong> occurrences of <code>cheese</code> within 3 words of <code>food</code>, regardless of the field (or fields) that contain each word.</p>
<p>The ZomboDB query syntax provides support for searching (in no particular order):</p>
<ul>
<li>full boolean operators (WITH, AND, OR, NOT),</li>
<li>words,</li>
<li>phrases,</li>
<li>fielded searching,</li>
<li>value lists</li>
<li>fuzzy words and phrases,</li>
<li>value ranges,</li>
<li>wildcards (left, middle, and right truncation),</li>
<li>term boosting</li>
<li>proximity (of word or phrase or combinations),</li>
<li>scripted searching,</li>
<li>Elasticsearch “bool” queries</li>
<li>Direct access to any Elasticsearch query via JSON</li>
<li>query expansion,</li>
<li>“more like this”,</li>
<li>limit/offset with sorting, and</li>
<li>more!</li>
</ul>
<h2 id="boolean-expressions-and-operator-precedence"><a class="header" href="#boolean-expressions-and-operator-precedence">Boolean Expressions and Operator Precedence</a></h2>
<p>The supported set of boolean operators are the standard <strong>NOT</strong>, <strong>WITH</strong> (for searching nested objects), <strong>AND</strong>, and <strong>OR</strong> operators along with proximity (<strong>W/n</strong> or <strong>WO/n</strong>).</p>
<p>If no operator is declared between terms, <strong>AND</strong> is assumed.  Additionally, parenthetical groupings are allowed to form complex boolean expressions.</p>
<p>The <strong>PROXIMITY</strong> operators take the highest priority, followed by <strong>NOT</strong>, <strong>WITH</strong>, <strong>AND</strong>, then finally <strong>OR</strong>.</p>
<p>For example, this query finds all documents which contain both <code>beer</code> <strong>AND</strong> <code>cheese</code> plus any documents that contain <code>wine</code>:</p>
<pre><code>    wine or beer and cheese
</code></pre>
<p>It is functionally equivalent to this query:</p>
<pre><code>    wine or (beer and cheese)
</code></pre>
<p>Whereas, this query finds all documents which contain both <code>beer</code> <strong>AND</strong> <code>cheese</code> but <strong>NOT</strong> <code>food</code>, plus any documents that contain <code>wine</code>:</p>
<pre><code>    wine or beer and cheese not food
</code></pre>
<p>It is functionally equivalent to this query:</p>
<pre><code>    wine or (beer and (cheese not food))
</code></pre>
<p>For convenience, each boolean operator has a single-character abbreviation:</p>
<ul>
<li>WITH: <strong>%</strong></li>
<li>AND:  <strong>&amp;</strong></li>
<li>OR:  <strong>,</strong></li>
<li>NOT:  <strong>!</strong></li>
</ul>
<p>So taking the example above, it could be rewritten as:</p>
<pre><code>    wine, beer &amp; cheese !food
</code></pre>
<p>And since the <strong>AND</strong> operator is the default, it could also be written as:</p>
<pre><code>    wine, beer cheese !food
</code></pre>
<h2 id="tokenization-escaping-case-sensitivity-and-term-analysis"><a class="header" href="#tokenization-escaping-case-sensitivity-and-term-analysis">Tokenization, Escaping, Case-Sensitivity, and Term Analysis</a></h2>
<p>During query parsing, tokens are formed whenever a character in this set is encountered:</p>
<pre><code>[  
   &quot;'&quot;, &quot;\&quot;&quot;,  &quot;:&quot;,  &quot;*&quot;,  &quot;~&quot;, &quot;?&quot;, 
   &quot;!&quot;,  &quot;%&quot;,  &quot;&amp;&quot;,  &quot;(&quot;,  &quot;)&quot;, &quot;,&quot;,
   &quot;&lt;&quot;,  &quot;=&quot;,  &quot;&gt;&quot;,  &quot;[&quot;,  &quot;]&quot;, &quot;^&quot;,
   &quot;{&quot;,  &quot;}&quot;,  &quot;`&quot;,  &quot; &quot;,  &quot;\r&quot;, &quot;\n&quot;, 
   &quot;\t&quot;, &quot;\f&quot; 
]
</code></pre>
<p>All other characters a valid token characters.</p>
<p>To use one of the above characters it must be escaped using a backslash, <em>or</em> the term must be quoted.  Any character is allowed within a quoted phrase.</p>
<p><code>foo#bar</code>, for example, would parse as a single term.</p>
<p>Terms and phrases are sub-parsed (analyzed) using the Elasticsearch-defined search analyzer for the field being searched.  Typically, analysis only happens on fields of type <code>phrase</code>, <code>phrase_array</code>, and <code>fulltext</code>.  Additionally, fields of custom <code>DOMAIN</code> types (such as <code>thai</code>, <code>english</code>, <code>cjk</code>) are also analyzed.</p>
<p>Token case is preserved, but may or may not be significant depending on how the underlying analyzer is defined.  All the default-supported analyzers are case-insensitive (including searching fields of type <code>text</code> and <code>varchar</code>), but a custom analyzer might decide to preserve case.</p>
<h2 id="term-and-phrase-searching"><a class="header" href="#term-and-phrase-searching">Term and Phrase Searching</a></h2>
<p>Terms and phrases are the basic search constructs for ZomboDB and are exactly what they sound like.</p>
<p>A term query:  <code>food</code><br />
A phrase query: <code>&quot;Now is the time&quot;</code></p>
<p>Phrases can be quoted using either single or double-quotes.</p>
<p>A unique feature of ZomboDB is that wildcards (<code>?</code>, <code>*</code>, and <code>~</code>) are allowed in “quoted phrases”.  Phrases that contain wildcards are transparently rewritten as proximity queries.</p>
<h2 id="fields-operators-keywords"><a class="header" href="#fields-operators-keywords">Fields, Operators, Keywords</a></h2>
<h3 id="fields"><a class="header" href="#fields">Fields</a></h3>
<p>If a term (or phrase) is prefixed with a field name and operator, searching will be limited to that field.  For convenience, entire parenthetical groups can be prefixed with a field name.</p>
<p>For example: </p>
<pre><code>name:&quot;John Doe&quot; and location:unknown 
  and crime:(shoplifting, &quot;grand-theft auto&quot;, jaywalking)
</code></pre>
<p>Fieldnames can also be quoted using backticks (`).  For example:</p>
<pre><code>`some:weird:Fieldname$`: &quot;the value to find&quot;
</code></pre>
<p>Typically, this is useful for searching property names within <code>json</code>/<code>jsonb</code> fields.</p>
<p>Without a field name, ZomboDB’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.6/mapping-all-field.html">zdb_all</a> field is searched.</p>
<p>Most of the examples that follow elide field names for (my) convenience, but know that they can be used in almost any situation a bare term or phrase is used.</p>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<p>Combined with a field name, these operators allow more sophisticated searching options.</p>
<table><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody>
<tr><td><code>:</code></td><td>field contains term</td></tr>
<tr><td><code>=</code></td><td>field contains term (same as : )</td></tr>
<tr><td><code>&lt;</code></td><td>field contains terms less than value</td></tr>
<tr><td><code>&lt;=</code></td><td>field contains terms less than or equal to value</td></tr>
<tr><td><code>&gt;</code></td><td>field contains terms greater than value</td></tr>
<tr><td><code>&gt;=</code></td><td>field contains terms greater than or equal to value</td></tr>
<tr><td><code>!=</code></td><td>field does not contain term</td></tr>
<tr><td><code>&lt;&gt;</code></td><td>field does not contain term (same as != )</td></tr>
<tr><td><code>/to/</code></td><td>range query, in form of field:START /to/ END</td></tr>
<tr><td><code>:~</code></td><td>field contains terms matching a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html#regexp-syntax">regular expression</a>.  Note that regular expression searches are always <strong>case sensitive</strong>.</td></tr>
<tr><td><code>:@</code></td><td><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html">“more like this”</a></td></tr>
<tr><td><code>:@~</code></td><td><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-flt-field-query.html">“fuzzy like this”</a></td></tr>
<tr><td><code>==&gt;</code></td><td>field “matches” the term, using Elasticsearch’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html">“match query”</a></td></tr>
</tbody></table>
<h3 id="keywords"><a class="header" href="#keywords">Keywords</a></h3>
<p>The list of keywords is very short: <code>with</code>, <code>and</code>, <code>or</code>, <code>not</code>, <code>null</code>, <code>true</code>, and <code>false</code>.<br />
To use one of these as a search term, simply quote it.</p>
<h2 id="value-lists--and-"><a class="header" href="#value-lists--and-">Value Lists (<code>[]</code> and <code>[[]]</code>)</a></h2>
<p>ZomboDB supports searching for lists of values using an array-like syntax.  For example:</p>
<p><code>field = [1,2,3,4,5]</code> or <code>field = [a,b,c,d]</code></p>
<p>Each element of the array is parsed as a token and run through analysis.  The underlying search is as if you OR’d those terms together, as in <code>field = 1 or field = 2 or field = 3 or field = 4 or field = 5</code></p>
<p>If you plan on searching for a large list of terms, as in 1,000 or even 10,000, you should use a slightly different syntax:</p>
<p><code>field = [[1,2,3...10000]]</code></p>
<ul>
<li>Note the double brackets</li>
</ul>
<p>This syntax is a “fast-pass” parsing that also doesn’t run each individual term through analysis.  With lots of terms, this is significantly faster than the other form that uses single brackets.</p>
<p>In either case, the only supported operators are equals and not equals, ie:
<code>:</code>, <code>=</code>, <code>!=</code>, <code>&lt;&gt;</code></p>
<h2 id="wildcards"><a class="header" href="#wildcards">Wildcards</a></h2>
<p>There are three types of wildcards.</p>
<table><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody>
<tr><td><code>?</code></td><td>any character</td></tr>
<tr><td><code>*</code></td><td>zero or more characters</td></tr>
<tr><td><code>~</code></td><td>post-fix only <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html">“fuzzy”</a> match with default fuzz of 3</td></tr>
</tbody></table>
<p>The <code>?</code> and <code>*</code> wildcards can be applied anywhere within a term.  Left, middle, and right truncation is supported.  The <code>~</code> wildcard is post-fix only and its fuzziness factor can be adjusted.</p>
<p>Examples:</p>
<p><code>be?r</code>:  would match beer, bear, etc<br />
<code>b*r</code>:  would match beer, bar, barber, etc<br />
<code>beer~</code>: would match beer, been, beep, etc<br />
<code>beer~2</code>: would match beer, bear, beep, bean, bell, etc</p>
<p>Special consideration is taken for criteria in the form of: <code>field:*</code> or <code>field:?</code>.  They are re-written using Elasticsearch’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-filter.html">“exists filter”</a>.</p>
<p>Note that phrases can also contain wildcarded terms, such as: <code>field:&quot;phrase~ w?th wild*rd&quot;</code>.  In this case, the phrase is rewritten as a proximity chain such as: <code>field:(phrase~ w/0 w?th w/0 wild*rd)</code>.  See below for details on proximity searching.</p>
<p>Additionally, entire phrases can “fuzzy”.  For example:</p>
<p><code>&quot;this phrase is fuzzy&quot;~3</code></p>
<p>This means that the words “this”, “phrase”, “is”, and “fuzzy” must appear within three tokens of each other, but order is not important.  So it could match <code>&quot;this phrase is a neat fuzzy feature&quot;</code>.</p>
<h2 id="termphrase-boosting"><a class="header" href="#termphrase-boosting">Term/Phrase Boosting</a></h2>
<p>Individual terms in a query can be “boosted” in order to increase the relevancy of matching documents.  Examples for term/phrase boosting are:</p>
<p><code>beer^2.0</code> or <code>&quot;this is a boosted phrase&quot;^2.0</code> or <code>apple w/2 cider^2.0 w/3 vinegar</code>.</p>
<p>A boost can also be applied to fielded searches, such as <code>author:Hemmingway^5.2 or author:Fitzgerald</code>.  This would rank documents whose author is Hemmingway higher, by an arbitrary amount.</p>
<p>The boost value is a floating point number and can either be between 0 and 1 (to decrease the boosting), or greater than 1 to increase the boosting.</p>
<p>From the Elasticsearch documentation:</p>
<pre><code>The boost parameter is used to increase the relative weight 
of a clause (with a boost greater than 1) or decrease the 
relative weight (with a boost between 0 and 1), but the increase 
or decrease is not linear. In other words, a boost of 2 does not 
result in double the score.

Instead, the new score is normalized after the boost is applied. 
Each type of query has its own normalization algorithm, and the 
details are beyond the scope of this book. Suffice to say that 
a higher boost value results in a higher score.
</code></pre>
<h2 id="proximity-searching"><a class="header" href="#proximity-searching">Proximity Searching</a></h2>
<p>Proximity searching allows to indicate that terms (or phrases) should be within a certain number of tokens of each other.</p>
<p>The operators are <strong>W/n</strong> and <strong>WO/n</strong>, where “n” indicates the distance.  <strong>W/n</strong> means <em>any order</em> and <strong>WO/n</strong> means <em>in order</em>.</p>
<p>Given the phrase:  <code>The quick brown fox jumped over the lazy dog's back</code></p>
<p>A proximity search in the form of: <code>jumped w/2 quick</code> would match the above because </p>
<ul>
<li>there are no more than two tokens between quick and jumped; and</li>
<li>order was not required</li>
</ul>
<p>Whereas <code>jumped wo/2 quick</code> would <em>not</em> match because order was required.</p>
<p>Proximity clauses can be chained together and are evaluated right-to-left.  For example:</p>
<p><code>quick w/2 jumped w/4 back</code> is evaluated as if it were written as <code>quick w/2 (jumped w/4 back)</code>.</p>
<p>Additionally, phrase proximity is supported.  For example:</p>
<p><code>&quot;quick brown fox&quot; w/3 &quot;lazy dog's back&quot;</code></p>
<p>Proximity operators take the highest precedence, so when combined with other boolean operators they are evaluated first.  For example:</p>
<p><code>quick and &quot;brown fox&quot; w/3 &quot;lazy dog's&quot; and back</code> is evaluated as if it were written as: <code>quick and (&quot;brown fox&quot; w/3 &quot;lazy dog's&quot;) and back</code></p>
<p>Proximity clauses can be limited to specific fields as well:  <code>title:catcher w/2 title:rye</code>.  Note that mixed fieldnames in a proximity chain is non-sensical and will produce a parse error.</p>
<p>It’s also possible to search for groups within some distance of another group.  This feature relates to Elasticsearch’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.7/query-dsl-span-or-query.html">span_or</a> clause. For example:</p>
<p><code>description:((cat OR dog) w/5 (pet wo/3 (sale OR &quot;free to good home&quot; OR free*)))</code></p>
<h2 id="subselects"><a class="header" href="#subselects">Subselects</a></h2>
<p>ZomboDB supports subselects which are akin to SQL <code>IN()</code> clauses.  The query clause is named <code>#subselect</code> and is an 
unary operator that can be used in conjunction with any of ZomboDB’s other query clauses, and can also be nested indefinitely.</p>
<p>An example query:</p>
<pre><code>   title:food AND #subselect&lt;id=&lt;schema.other_table.index_name&gt;join_id&gt;(other_field = 'other value') 
</code></pre>
<p>This is akin to an SQL statement such as:</p>
<pre><code class="language-sql">    SELECT * 
      FROM table 
     WHERE title LIKE 'food' 
       AND id IN (SELECT join_id FROM other_table WHERE other_field = 'other value');
</code></pre>
<p>You can do a subselect from any table/index pair that has an existing ZomboDB index, and if you wish to do a subselect
against the primary index you’re querying, simply specify <code>outer_field=&lt;this.index&gt;inner_field</code>, where <code>this.index</code> is
a literal value.  For example:</p>
<pre><code>    #subselect&lt;parent_id=&lt;this.index&gt;id&gt;(food, beer, wine)
</code></pre>
<p>The above will do a self-join and match all docs with a <code>parent_id</code> that’s equivalent to any doc <code>id</code> that contains
any of <code>food</code>, <code>beer</code>, or <code>wine</code>.</p>
<p>In the case where the table/index you’re subselecting from has the same fieldnames as the outer index, you may want
to use a “named index link” to help ZomboDB disambiguate field names.  Example:</p>
<pre><code>    #subselect&lt;my_name:(id=&lt;schema.other_table.index_name&gt;join_id)&gt;(my_name.common_field = value)
</code></pre>
<p><code>#subselect</code> is different from <code>#expand</code> (described below) in that <code>#expand</code> is intended to add more rows to the results,
whereas <code>#subselect</code> is intended to limit the results.</p>
<p><code>#subselect</code> requires a commercial license to ZomboDB’s companion Elasticsearch plugin.  Please contact zombodb@gmail.com for details.</p>
<h2 id="query-expansion"><a class="header" href="#query-expansion">Query Expansion</a></h2>
<p>Query expansion is a way for a single query to “pull in” additional records from the same index that are related to the records that match your fulltext query.</p>
<p>Say you have a table that holds emails:</p>
<pre><code class="language-sql">CREATE TABLE emails (
   id serial8 not null primary key,
   subject phrase,
   body fulltext,
   from text,
   to text[],
   cc text[],
   thread_id text,
   is_parent boolean
);
</code></pre>
<p>Now say you want to find all the emails that mention <code>beer</code> in the subject, but want to return the entire thread for each matching email.  Your query would be:</p>
<p><code>#expand&lt;thread_id=&lt;this.index&gt;thread_id&gt;(subject:beer)</code></p>
<p><code>this.index</code> is a literal (ie, not to be substituted with your actual index name).</p>
<p>What happens is that ZomboDB first finds all the emails that match <code>subject:beer</code> and internally “joins” back to the index on <code>thread_id = thread_id</code>.</p>
<p>What’s returned are all original matching records plus their thread members.  If an original record doesn’t have a <code>thread_id</code> (ie, <code>thread_id</code> is null), the record is still returned.</p>
<p>The left and right field names can be whatever “join condition” makes sense for the type of expansion you’re trying to perform -- the fields need not be the same.</p>
<p><code>#expand&lt;&gt;()</code> also supports an optional <code>#filter()</code> clause, that filters the expanded results before the final set is applied.  Using the same example, lets say we only want to expand to the “parent” email in all threads that discuss beer:</p>
<p><code>#expand&lt;thread_id=&lt;this.index&gt;thread_id&gt;(subject:beer #filter(is_parent:true))</code></p>
<p>This says “find all emails with ‘beer’ in the subject, expand to their parent emails, by <code>thread_id</code>, and return the combined set of records”.</p>
<p>Note that <code>#expand&lt;&gt;()</code> always add records to the results (it never removes records), so the results in the above example will be every email whose subject contains beer plus the parent email from their respective thread.</p>
<p>If you only want parent emails returned you’d add a boolean clause outside of the expansion:</p>
<p><code>#expand&lt;thread_id=&lt;this.index&gt;thread_id&gt;(subject:beer) and is_parent:true</code></p>
<p>In terms of ZomboDB’s query parser, <code>#expand&lt;&gt;()</code> is an unary operator and as such can be intermixed with boolean expressions (shown above) and infinitely nested as well.  An implementation note is that ZomboDB solves nested expansions from the bottom-up.</p>
<p><code>#expand</code> requires a commercial license to ZomboDB’s companion Elasticsearch plugin.  Please contact zombodb@gmail.com for details.</p>
<h2 id="elasticsearch-json-queries"><a class="header" href="#elasticsearch-json-queries">Elasticsearch JSON Queries</a></h2>
<p>While ZomboDB provides a fairly robust query language, it doesn’t expose every query construct (and parameter) that Elasticsearch supports.</p>
<p>As such, ZomboDB allows you to query using direct Elasticsearch-compatible JSON queries as well.  In fact, this feature operates as a unary operator within ZomboDB’s query language so you can mix-n-match Elasticsearch JSON queries with ZomboDB query constructs.</p>
<p>To use a direct JSON query, simply wrap your Elasticsearch-compatible JSON in <code>({</code> and <code>})</code>.</p>
<p>For example:</p>
<pre><code>beer OR wine OR cheese AND ({ &quot;term&quot;: &quot;subject&quot;: &quot;food&quot; }) NOT pickles

</code></pre>
<p>The JSON query structure you provide can be as complex as you need, and you can include as many <code>({ })</code> constructs within the query as you want.</p>
<h2 id="nested-object-searching-using-with"><a class="header" href="#nested-object-searching-using-with">Nested Object Searching using WITH</a></h2>
<p>ZomboDB automatically indexes fields of type <code>json</code> as “nested objects”.  The boolean operator <strong>WITH</strong> allows forming queries that match on individual nested objects.</p>
<p>For example, if you have a field named <code>contributor_data</code> with a few values such as:</p>
<pre><code>row #1: [ 
   { &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 42, &quot;location&quot;: &quot;TX&quot;, &quot;tags&quot;: [&quot;active&quot;] },
   { &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 36, &quot;location&quot;: &quot;TX&quot;, &quot;tags&quot;: [&quot;nice&quot;] }
]

row #2: [ 
   { &quot;name&quot;: &quot;Bob Dole&quot;, &quot;age&quot;: 92, &quot;location&quot;: &quot;KS&quot;, &quot;tags&quot;: [&quot;nice&quot;, &quot;politician&quot;] },
   { &quot;name&quot;: &quot;Elizabth Dole&quot;, &quot;age&quot;: 79, &quot;location&quot;: &quot;KS&quot;, &quot;tags&quot;: [&quot;nice&quot;] }
]

</code></pre>
<p>To find all top-level documents whose contributors are in TX and are nice:</p>
<pre><code>contributor_data.location:TX AND contributor_data.tags:nice
</code></pre>
<p>The above finds row #1 because row #1’s contributor_data structure contains elements that have a location of TX along with tags of nice.  Essentially, it found row #1 because “John Doe” matched “TX” and “Jane Doe” matched “nice”.</p>
<p>To limit the matching to only evaluate individual elements (rather than across the entire set of elements), use the <strong>WITH</strong> operator:</p>
<pre><code>contributor_data.location:TX WITH contributor_data.tags:nice
</code></pre>
<p>The above also finds row #1, but behind the scenes it only matched the “Jane Doe” subelement, because it’s the only element with a location of “TX” and a tag of “nice”.</p>
<p>The <strong>WITH</strong> operator has the same semantics as <strong>AND</strong> but requires both its left and right sides to be a nested object field reference or a parenthetical boolean expression, and all field references must be against the same nested object.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elasticsearch-querydsl"><a class="header" href="#elasticsearch-querydsl">ElasticSearch QueryDSL</a></h1>
<p>ZomboDB supports a few different ways to generate Elasticsearch-compatible queries.  You can use Elasticsearch’s query string syntax, directly generate its QueryDSL in JSON form, or use ZomboDB’s SQL builder API which closely mirrors Elasticsearch’s QueryDSL.</p>
<p>Wherever ZomboDB wants to you specify a query, which is typically <code>SELECT</code> statements and aggregate functions, you can interchangeably use any of the below query forms.</p>
<p>To use a <code>SELECT</code> statement as an example, lets suppose we want to select all the rows that contain the terms “cats and dogs” regardless of field.  The basic query template looks like:</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; &lt;cats and dogs query here&gt;
</code></pre>
<p>Note that regardless of the way you query, know that essentially you’re generating <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Elasticsearch QueryDSL</a> in JSON.</p>
<p>ZomboDB tries to abstract this fact away by using a custom Postgres type called <code>zdbquery</code> that can be cast to/from <code>text</code>, <code>json</code>, and <code>jsonb</code>.  As such, the right-hand-side of ZomboDB’s <code>==&gt;</code> operator is of type <code>zdbquery</code>.</p>
<p>The goal of this document is not to teach the ins-and-outs of Elasticsearch’s query capabilities.  It is recommented you reference its documentation when the information here is not sufficient.  Where approrpiate, links to specific Elasticsearch Query DSL clauses are provided below.</p>
<p>That said, lets discuss how to write our example query using ZomboDB’s supported query forms.</p>
<h3 id="query-string-syntax"><a class="header" href="#query-string-syntax">Query String Syntax</a></h3>
<p>The Query String Syntax is a plain-text query language <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html">implemented by Elasticsearch</a>.  It’s “google”-like in that you can simply specify free-form, unqualified words and “quoted phrases” and Elasticsearch figures out the matching documents.  Additionally, it supports a fairly sophsicated boolean syntax that includes field qualification, proximity, ranges, wildcards, etc.</p>
<p>Using the query string syntax, searching for “cats and dogs” could be any of the following:</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; '+cats +dogs';
SELECT * FROM table WHERE table ==&gt; 'cats AND dogs';
</code></pre>
<p>To show what’s happening behind the scenes, ZomboDB is actually generating Elasticsearch QueryDSL JSON for the above queries:</p>
<pre><code class="language-sql">SELECT '+cats +dogs'::zdbquery::json;
                   json                   
------------------------------------------
 {&quot;query_string&quot;:{&quot;query&quot;:&quot;+cats +dogs&quot;}}

SELECT 'cats AND dogs'::zdbquery::json;
                    json                    
--------------------------------------------
 {&quot;query_string&quot;:{&quot;query&quot;:&quot;cats AND dogs&quot;}}

</code></pre>
<p>So you can see that ZomboDB is directly using Elasticsearch’s Query String query.</p>
<h3 id="direct-json"><a class="header" href="#direct-json">Direct JSON</a></h3>
<p>While the above Query String Syntax is easy for humans to read and type, it doesn’t expose every feature of Elasticsearch’s QueryDSL.  Enter direct json.</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; '{&quot;bool&quot;:{&quot;must&quot;:[{&quot;term&quot;:{&quot;zdb_all&quot;:{&quot;value&quot;:&quot;cats&quot;}}},{&quot;term&quot;:{&quot;zdb_all&quot;:{&quot;value&quot;:&quot;dogs&quot;}}}]}}';
</code></pre>
<p>You have the full gamut of the Elasticsearch QueryDSL available to you with this form.  This is likely best used when you’re programatically generating queries.</p>
<blockquote>
<p>Note that the field <code>zdb_all</code> is ZomboDB’s version of Elasticsearch’s “_all” field, except <code>zdb_all</code> is enabled for all versions of Elasticsearch.  It is also configured as the default search field for every ZomboDB index, which is why it wasn’t specified in the Query String Syntax examples, but is here.</p>
</blockquote>
<h3 id="sql-builder-api"><a class="header" href="#sql-builder-api">SQL Builder API</a></h3>
<p>ZomboDB also exposes nearly all of Elasticsearch’s QueryDSL queries as SQL functions, located in a schema named <code>dsl</code>.  These functions all return a <code>zdbquery</code>, and can be composed together to build complex queries.  The primary advantages of this API are that these functions are syntax- and type-checked by Postgres, so you’ll catch malformed queries sooner.</p>
<p>In general, each function models its corresponding Elasticsearch query exactly.  Default values are used for arguments in all places where Elasticsearch provides defaults for properties, and arguments are required where Elasticsearch requires the corresponding property.  Postgres VARIADIC function arguments are used in most cases where Elasticsearch expects an array of queries or values.</p>
<p>They’re designed to be used with defaults in the common cases, and then otherwise should be used using Postgres’ “named arguments” function call syntax to improve readability.</p>
<p>All of the functions are briefly described below, but here’s some examples for our “cats and dogs” queries, plus a few more examples.</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; dsl.and('cats', 'dogs');
SELECT * FROM table WHERE table ==&gt; dsl.and(dsl.term('zdb_all', 'cats'), dsl.term('zdb_all', 'dogs'));
</code></pre>
<p>Behind the scenes, ZomboDB is just generating the QueryDSL JSON for you:</p>
<pre><code class="language-sql">SELECT dsl.and('cats', 'dogs')::json;
                                          must                                           
-----------------------------------------------------------------------------------------
 {&quot;bool&quot;:{&quot;must&quot;:[{&quot;query_string&quot;:{&quot;query&quot;:&quot;cats&quot;}},{&quot;query_string&quot;:{&quot;query&quot;:&quot;dogs&quot;}}]}}
 
SELECT dsl.and(dsl.term('zdb_all', 'cats'), dsl.term('zdb_all', 'dogs'))::json;
                                              must                                               
-------------------------------------------------------------------------------------------------
 {&quot;bool&quot;:{&quot;must&quot;:[{&quot;term&quot;:{&quot;zdb_all&quot;:{&quot;value&quot;:&quot;cats&quot;}}},{&quot;term&quot;:{&quot;zdb_all&quot;:{&quot;value&quot;:&quot;dogs&quot;}}}]}}
</code></pre>
<p>Lets say you want to find all rows that contain cats with an age greater than 3 years.  This example shows, with the <code>range()</code> function, using Postgres “named arugments” function call syntax so that you can specifiy only the bounds of the range you need.  We’re also mix-and-matching between the plain text Query String Syntax (<code>'cats'</code>) and the builder API (<code>must()</code> and <code>range()</code>):</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; dsl.and('cats', dsl.range(field=&gt;'age', gt=&gt;3));
</code></pre>
<p>Which rewrites to:</p>
<pre><code class="language-sql">SELECT dsl.and('cats', dsl.range(field=&gt;'age', gt=&gt;3))::json;
                                        must                                        
------------------------------------------------------------------------------------
 {&quot;bool&quot;:{&quot;must&quot;:[{&quot;query_string&quot;:{&quot;query&quot;:&quot;cats&quot;}},{&quot;range&quot;:{&quot;age&quot;:{&quot;gt&quot;:&quot;3&quot;}}}]}}
</code></pre>
<p>One of the more powerful benefits of the Builder API is that it allows you to generate Postgres prepared statements for your text-search queries.  For example:</p>
<pre><code class="language-sql">PREPARE example AS SELECT * FROM table WHERE table ==&gt; dsl.and($1, dsl.range(field=&gt;'age', gt=&gt;$2));
</code></pre>
<p>Now we can execute that query using a different search term and age range:</p>
<pre><code class="language-sql">EXECUTE exampe('cats', 3);
EXECUTE exampe('dogs', 7);
EXECUTE exampe('elephants', 23);
</code></pre>
<p>Using prepared statements is extremely important to avoid SQL-injection attacks.  ZomboDB makes this possible for your Elasticsearch QueryDSL query clauses too.  Any argument to any of the functions can become a prepared statement arugment that you can change at EXECUTE time.</p>
<h3 id="sorting-and-limiting-results"><a class="header" href="#sorting-and-limiting-results">Sorting and Limiting Results</a></h3>
<p>ZomboDB allows you to limit the number of rows returned, and their sort order, similar to the SQL <code>LIMIT</code> and <code>ORDER BY</code> clauses, except they’re specified as part of the Elasticsearch query, and the sorting/limiting happens within Elasticsearch.  In general, this is significantly faster than having Postgres do it.</p>
<p>The following functions are designed to wrap the query you want to execute, on the outer levels.  For example, to return only 10 rows:</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; dsl.limit(10, dsl.term('title', 'cat'));
</code></pre>
<p>Or to return 10 rows sorted by <code>id</code>:</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; dsl.sort('id', 'asc', dsl.limit(10, dsl.term('title', 'cat')));
</code></pre>
<h2 id="sort-and-limit-functions"><a class="header" href="#sort-and-limit-functions">Sort and Limit Functions</a></h2>
<h4 id="dsllimit"><a class="header" href="#dsllimit"><code>dsl.limit()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.limit(
	limit bigint, 
	query zdbquery
) RETURNS zdbquery
</code></pre>
<p>Limits the number of rows returned to the specified <code>limit</code> limit.  If the query doesn’t otherwise contain a <code>dsl.sort()</code> (see below), then the results returned are first sorted by <code>_score</code> in <code>desc</code>ending order.  This ensures that ZomboDB returns the top scoring documents. </p>
<hr />
<h4 id="dsloffset"><a class="header" href="#dsloffset"><code>dsl.offset()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.offset(
	offset bigint, 
	query zdbquery
) RETURNS zdbquery
</code></pre>
<p>Similar to the SQL <code>OFFSET</code> clause, allows you to start returning results from a point other than the start.</p>
<hr />
<h4 id="dslsort"><a class="header" href="#dslsort"><code>dsl.sort()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.sort(
	sort_field text, 
	sort_direction dsl.es_sort_directions, -- one of 'asc' or 'desc'
	query zdbquery
) RETURNS zdbquery
</code></pre>
<p>Sort the results returned from Elasticsearch by an arbitrary field.</p>
<p>Because the SQL standard doesn’t guarantee result ordering unless the query contains an <code>ORDER BY</code> clause, you should use <code>ORDER BY</code> in conjunction with this function.  For example:</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; dsl.sort('id', 'asc', 'cats AND dogs') ORDER BY id asc;
</code></pre>
<p>In practice, using <code>dsl.sort()</code> only makes sense when combined with <code>dsl.limit()</code>.</p>
<p>There’s an overloaded version of <code>dsl.sort()</code> (described below) that allows for more complex sorting descriptors.</p>
<hr />
<h4 id="dslsd"><a class="header" href="#dslsd"><code>dsl.sd()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.sd(
	field text, 
	&quot;order&quot; dsl.es_sort_directions, 
	mode dsl.es_sort_modes DEFAULT NULL
) RETURNS dsl.es_sort_descriptor
</code></pre>
<p><code>dsl.sd()</code> (which is short for “sort descriptor”) allows you to contruct an object that represents sorting.  It is designed to be used as the arguments to <code>dsl.sort_many(zdbquery, VARIADIC dsl.es_sort_descriptor[])</code> (defined below).</p>
<p>The possible values for the <code>mode</code> argument are <code>min</code>, <code>max</code>, <code>sum</code>, <code>avg</code>,  and <code>median</code>.  These are documented here:  https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-sort.html#_sort_mode_option</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; dsl.sort_many(dsl.match_all(), dsl.sd('field', 'asc'), dsl.sd('price', 'desc', 'avg'));
</code></pre>
<hr />
<h4 id="dslsd_nested"><a class="header" href="#dslsd_nested"><code>dsl.sd_nested()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.sd_nested(
	field text, &quot;order&quot; 
	dsl.es_sort_directions, 
	nested_path text, 
	nested_filter zdbquery DEFAULT NULL, 
	mode dsl.es_sort_modes DEFAULT NULL
) RETURNS dsl.es_sort_descriptor
</code></pre>
<p><code>dsl.sd_nested()</code> (which is short for “nested field sort descriptor”) allows you to contruct an object that represents sorting for a nested field.  It is designed to be used as an argument to <code>dsl.sort_many(zdbquery, VARIADIC dsl.es_sort_descriptor[])</code> (defined below).</p>
<p>The possible values for the <code>mode</code> argument are <code>min</code>, <code>max</code>, <code>sum</code>, <code>avg</code>,  and <code>median</code>.  These are documented here:  https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-sort.html#_sort_mode_option</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; dsl.sort_many(dsl.match_all(), dsl.sd_nested('offer.price', 'asc', 'offer', dsl.match_all(), 'avg'), dsl.sd('id', 'desc', 'avg'));
</code></pre>
<p>The above would first sort the results by the average value from the nested field <code>offer.price</code> in ascending order, and then by <code>id</code> in descending order.</p>
<hr />
<h4 id="dslsort_many"><a class="header" href="#dslsort_many"><code>dsl.sort_many()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.sort_many(
	query zdbquery, 
	VARIADIC descriptors dsl.es_sort_descriptor[]
) RETURNS zdbquery
</code></pre>
<p>This is similar to the <code>dsl.sort()</code> function described above, however it requires the query be the first argument and allows for a variable list of sort descriptors, that should be generated using the <code>dsl.sd()</code> or <code>dsl.sd_nested()</code> functions.</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; dsl.sort_many(dsl.match_all(), dsl.sd('field', 'asc'), dsl.sd('price', 'desc', 'avg'));
</code></pre>
<hr />
<h4 id="dslsort_direct"><a class="header" href="#dslsort_direct"><code>dsl.sort_direct()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.sort_direct(
	sort_json json, 
	query zdbquery
) RETURNS zdbquery
</code></pre>
<p>This function allows you to specify direct json to describe how Elasticsearch should sort the results.</p>
<p>In the Elasticearch <code>_search</code> request body, this is the top-level <code>&quot;sort&quot;</code> property (https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-request-sort.html#nested-sorting).</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT * FROM table WHERE table ==&gt; dsl.sort_direct('{
        &quot;_script&quot; : {
            &quot;type&quot; : &quot;number&quot;,
            &quot;script&quot; : {
                &quot;lang&quot;: &quot;painless&quot;,
                &quot;source&quot;: &quot;doc[''field_name''].value * params.factor&quot;,
                &quot;params&quot; : {
                    &quot;factor&quot; : 1.1
                }
            },
            &quot;order&quot; : &quot;asc&quot;
        }
    }', dsl.match_all());
</code></pre>
<hr />
<h4 id="dslmin_score"><a class="header" href="#dslmin_score"><code>dsl.min_score()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.min_score(
	min_score real, 
	query zdbquery
) RETURNS zdbquery
</code></pre>
<p>This allows you to specify Elastisearch’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-min-score.html"><code>min_score</code></a> search property to ensure documents with a score less than the specified value are excluded from the results.</p>
<h2 id="sql-builder-api-functions"><a class="header" href="#sql-builder-api-functions">SQL Builder API Functions</a></h2>
<h3 id="simple-boolean-functions"><a class="header" href="#simple-boolean-functions">Simple Boolean Functions</a></h3>
<h4 id="dsland"><a class="header" href="#dsland"><code>dsl.and()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.and(
	VARIADIC queries zdbquery[]
) RETURNS zdbquery
</code></pre>
<p>Generates an Elasticsearch <code>bool</code> query where all the arguments are part of the <code>must</code> clause.</p>
<hr />
<h4 id="dslor"><a class="header" href="#dslor"><code>dsl.or()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.or(
	VARIADIC queries zdbquery[]
) RETURNS zdbquery
</code></pre>
<p>Generates an Elasticsearch <code>bool</code> query where all the arguments are part of the <code>should</code> clause.</p>
<hr />
<h4 id="dslnot"><a class="header" href="#dslnot"><code>dsl.not()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.not(
	VARIADIC queries zdbquery[]
) RETURNS zdbquery
</code></pre>
<p>Generates an Elasticsearch <code>bool</code> query where all the arguments are part of the <code>must_not</code> clause.</p>
<h3 id="elasticsearch-bool-query-support"><a class="header" href="#elasticsearch-bool-query-support">Elasticsearch “bool” Query Support</a></h3>
<h4 id="dslbool"><a class="header" href="#dslbool"><code>dsl.bool()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.bool(
	VARIADIC queries dsl.esqdsl_bool_part
) RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html</p>
<p>This function represents the Elasticsearch <code>bool</code> query.  It takes one or more “boolean part” queries, which are generated using the SQL functions named <code>dsl.must()</code>, <code>dsl.must_not()</code>, <code>dsl.should()</code>, and <code>dsl.filter()</code>.</p>
<p>Multiple usages of the same boolean part will be merged together automatically.</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT dsl.bool(
        dsl.must('beer', 'wine', 'cheese'),
        dsl.must_not('beer', 'wine', 'cheese'),
        dsl.should('beer', 'wine', 'cheese'),
        dsl.filter('beer', 'wine', 'cheese'),
        dsl.must('lettuce', 'tomato', 'bread') -- we used dsl.must() above too!
    );
</code></pre>
<p>Which ultimately generates the following Elasticsearch QueryDSL:</p>
<pre><code class="language-json">{
  &quot;bool&quot;: {
    &quot;filter&quot;: [
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;beer&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;wine&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;cheese&quot;
        }
      }
    ],
    &quot;must&quot;: [
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;beer&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;wine&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;cheese&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;lettuce&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;tomato&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;bread&quot;
        }
      }
    ],
    &quot;must_not&quot;: [
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;beer&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;wine&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;cheese&quot;
        }
      }
    ],
    &quot;should&quot;: [
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;beer&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;wine&quot;
        }
      },
      {
        &quot;query_string&quot;: {
          &quot;query&quot;: &quot;cheese&quot;
        }
      }
    ]
  }
}
</code></pre>
<hr />
<h4 id="dslmust"><a class="header" href="#dslmust"><code>dsl.must()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.must (
	VARIADIC queries zdbquery[])
RETURNS dsl.esqdsl_must
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html</p>
<p>This is the <code>must</code> clause of the Elasticsearch QueryDSL <code>bool</code> query.  The queries must appear in matching documents and will contribute to the score.</p>
<p>This function is designed to be used with the <code>must</code> argument of <code>dsl.bool()</code>.  Its arguments can be or or more of any of ZomboDB’s <code>dsl</code> functions that return a type of <code>zdbquery</code>.</p>
<hr />
<h4 id="dslmust_not"><a class="header" href="#dslmust_not"><code>dsl.must_not()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.must_not (
	VARIADIC queries zdbquery[])
RETURNS dsl.esqdsl_must_not
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html</p>
<p>This is the <code>must_not</code> clause of the Elasticsearch QueryDSL <code>bool</code> query.  The queries must not appear in the matching documents. Clauses are executed in filter context meaning that scoring is ignored and clauses are considered for caching. Because scoring is ignored, a score of 0 for all documents is returned.</p>
<p>This function is designed to be used with the <code>must_not</code> argument of <code>dsl.bool()</code>.  Its arguments can be or or more of any of ZomboDB’s <code>dsl</code> functions that return a type of <code>zdbquery</code>.</p>
<hr />
<h4 id="dslshould"><a class="header" href="#dslshould"><code>dsl.should()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.should (
	VARIADIC queries zdbquery[])
RETURNS dsl.esqdsl_should
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html</p>
<p>This is the <code>should</code> clause of the Elasticsearch QueryDSL <code>bool</code> query.  The queries should appear in matching documents and will contribute to the score.</p>
<p>This function is designed to be used with the <code>should</code> argument of <code>dsl.bool()</code>.  Its arguments can be or or more of any of ZomboDB’s <code>dsl</code> functions that return a type of <code>zdbquery</code>.</p>
<hr />
<h4 id="dslfilter"><a class="header" href="#dslfilter"><code>dsl.filter()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.filter (
	VARIADIC queries zdbquery[])
RETURNS dsl.esqdsl_filter
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html</p>
<p>This is the <code>filter</code> object of an Elasticsearch QueryDSL <code>bool</code>.</p>
<p>The clause (query) must appear in matching documents. However unlike must the score of the query will be ignored. Filter clauses are executed in filter context, meaning that scoring is ignored and clauses are considered for caching.</p>
<p>This function is designed to be used with the <code>filter</code> argument of <code>dsl.bool()</code>.  Its arguments can be or or more of any of ZomboDB’s <code>dsl</code> functions that return a type of <code>zdbquery</code>.</p>
<h3 id="elasticsearch-query-dsl-support"><a class="header" href="#elasticsearch-query-dsl-support">Elasticsearch Query DSL Support</a></h3>
<h4 id="dslboosting"><a class="header" href="#dslboosting"><code>dsl.boosting()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.boosting (
	positive zdbquery,
	negative zdbquery,
	negative_boost real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-boosting-query.html</p>
<p>The boosting query can be used to effectively demote results that match a given query. Unlike the “NOT” clause in bool query, this still selects documents that contain undesirable terms, but reduces their overall score.</p>
<hr />
<h4 id="dslcommon"><a class="header" href="#dslcommon"><code>dsl.common()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.common (
	field text,
	query text,
	boost real DEFAULT NULL,
	cutoff_frequency real DEFAULT NULL,
	analyzer text DEFAULT NULL,
	minimum_should_match integer DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-common-terms-query.html</p>
<p>The common terms query is a modern alternative to stopwords which improves the precision and recall of search results (by taking stopwords into account), without sacrificing performance.</p>
<hr />
<h4 id="dslconstant_score"><a class="header" href="#dslconstant_score"><code>dsl.constant_score()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.constant_score (
	boost real,
	query zdbquery)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-constant-score-query.html</p>
<p>A query that wraps another query and simply returns a constant score equal to the query boost for every document in the filter. Maps to Lucene ConstantScoreQuery.</p>
<hr />
<h4 id="dsldatetime_range"><a class="header" href="#dsldatetime_range"><code>dsl.datetime_range()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.datetime_range (
	field text,
	lt timestamp with time zone DEFAULT NULL,
	gt timestamp with time zone DEFAULT NULL,
	lte timestamp with time zone DEFAULT NULL,
	gte timestamp with time zone DEFAULT NULL,
	boost real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html</p>
<p>Matches documents with fields that have terms within a certain range.  This form is for timestamp values.</p>
<p>ZomboDB will automatically convert the specified time to <code>UTC</code> (to be compatible with Elasticsearch) however, if
you don’t specify the time zone the timestamp represents then Postgres will first assume it belongs to whatever
time zone the server is running in (via the <code>TimeZone</code> GUC).  Read here for more about how Postgres handles time zones:
https://www.postgresql.org/docs/11/datatype-datetime.html#DATATYPE-TIMEZONES</p>
<hr />
<h4 id="dsldis_max"><a class="header" href="#dsldis_max"><code>dsl.dis_max()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.dis_max (
	queries zdbquery[],
	boost real DEFAULT NULL,
	tie_breaker real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-dis-max-query.html</p>
<p>A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.</p>
<hr />
<h4 id="dslfield_exists"><a class="header" href="#dslfield_exists"><code>dsl.field_exists()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.field_exists (
	field text)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html</p>
<p>Returns documents that have at least one non-null value in the specified field</p>
<hr />
<h4 id="dslfield_missing"><a class="header" href="#dslfield_missing"><code>dsl.field_missing()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.field_missing (
	field text)
RETURNS zdbquery
</code></pre>
<p>The inverse of <code>dsl.field_exists()</code>.  Returns documents that have no value in the specified field</p>
<hr />
<h4 id="dslfuzzy"><a class="header" href="#dslfuzzy"><code>dsl.fuzzy()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.fuzzy (
	field text,
	value text,
	boost real DEFAULT NULL,
	fuzziness integer DEFAULT NULL,
	prefix_length integer DEFAULT NULL,
	max_expansions integer DEFAULT NULL,
	transpositions boolean DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html</p>
<p>The fuzzy query uses similarity based on Levenshtein edit distance.</p>
<hr />
<h4 id="dslmatch"><a class="header" href="#dslmatch"><code>dsl.match()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.match (
	field text,
	query text,
	boost real DEFAULT NULL,
	analyzer text DEFAULT NULL,
	minimum_should_match integer DEFAULT NULL,
	lenient boolean DEFAULT NULL,
	fuzziness integer DEFAULT NULL,
	fuzzy_rewrite text DEFAULT NULL,
	fuzzy_transpositions boolean DEFAULT NULL,
	prefix_length integer DEFAULT NULL,
	zero_terms_query dsl.es_match_zero_terms_query DEFAULT NULL,
	cutoff_frequency real DEFAULT NULL,
	operator dsl.es_match_operator DEFAULT NULL,
	auto_generate_synonyms_phrase_query boolean DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html</p>
<p><code>match</code> queries accept text/numerics/dates, analyzes them, and constructs a query. </p>
<hr />
<h4 id="dslmatch_all"><a class="header" href="#dslmatch_all"><code>dsl.match_all()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.match_all (
	boost real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html</p>
<p>The most simple query, which matches all documents, giving them all a _score of 1.0.</p>
<hr />
<h4 id="dslmatch_none"><a class="header" href="#dslmatch_none"><code>dsl.match_none()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.match_none ()
RETURNS zdbquery
</code></pre>
<p>The inverse of <code>dsl.match_all()</code>.  Matches no documents.</p>
<hr />
<h4 id="dslmatch_phrase"><a class="header" href="#dslmatch_phrase"><code>dsl.match_phrase()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.match_phrase (
	field text,
	query text,
	boost real DEFAULT NULL,
	slop integer DEFAULT NULL,
	analyzer text DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html</p>
<p>The <code>match_phrase</code> query analyzes the text and creates a phrase query out of the analyzed text. </p>
<hr />
<h4 id="dslmatch_phrase_prefix"><a class="header" href="#dslmatch_phrase_prefix"><code>dsl.match_phrase_prefix()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.match_phrase_prefix (
	field text,
	query text,
	boost real DEFAULT NULL,
	slop integer DEFAULT NULL,
	analyzer text DEFAULT NULL,
	max_expansions integer DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html</p>
<p><code>ds.match_phrase_prefix()</code> is the same as <code>dsl.match_phrase()</code>, except that it allows for prefix matches on the last term in the text.</p>
<hr />
<h4 id="dslmore_like_this"><a class="header" href="#dslmore_like_this"><code>dsl.more_like_this()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.more_like_this (
	&quot;like&quot; text,
	fields text[] DEFAULT NULL,
	stop_words text[] DEFAULT ARRAY[...],
	boost real DEFAULT NULL,
	unlike text DEFAULT NULL,
	analyzer text DEFAULT NULL,
	minimum_should_match integer DEFAULT NULL,
	boost_terms real DEFAULT NULL,
	include boolean DEFAULT NULL,
	min_term_freq integer DEFAULT NULL,
	max_query_terms integer DEFAULT NULL,
	min_doc_freq integer DEFAULT NULL,
	max_doc_freq integer DEFAULT NULL,
	min_word_length integer DEFAULT NULL,
	max_word_length integer DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html</p>
<p>The More Like This Query finds documents that are “like” a given set of documents. In order to do so, MLT selects a set of representative terms of these input documents, forms a query using these terms, executes the query and returns the results.</p>
<p>This form takes a single blob of text as the source document. </p>
<hr />
<h4 id="dslmore_like_this-1"><a class="header" href="#dslmore_like_this-1"><code>dsl.more_like_this()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.more_like_this (
	&quot;like&quot; text[],
	fields text[] DEFAULT NULL,
	stop_words text[] DEFAULT ARRAY[...],
	boost real DEFAULT NULL,
	unlike text DEFAULT NULL,
	analyzer text DEFAULT NULL,
	minimum_should_match integer DEFAULT NULL,
	boost_terms real DEFAULT NULL,
	include boolean DEFAULT NULL,
	min_term_freq integer DEFAULT NULL,
	max_query_terms integer DEFAULT NULL,
	min_doc_freq integer DEFAULT NULL,
	max_doc_freq integer DEFAULT NULL,
	min_word_length integer DEFAULT NULL,
	max_word_length integer DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html</p>
<p>The More Like This Query finds documents that are “like” a given set of documents. In order to do so, MLT selects a set of representative terms of these input documents, forms a query using these terms, executes the query and returns the results.</p>
<p>This form takes multiple snippets of text as the source documents. </p>
<hr />
<h4 id="dslmulti_match"><a class="header" href="#dslmulti_match"><code>dsl.multi_match()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.multi_match (
	fields text[],
	query text,
	boost real DEFAULT NULL,
	type dsl.es_multi_match_type DEFAULT NULL,
	analyzer text DEFAULT NULL,
	minimum_should_match integer DEFAULT NULL,
	lenient boolean DEFAULT NULL,
	fuzziness integer DEFAULT NULL,
	fuzzy_rewrite text DEFAULT NULL,
	fuzzy_transpositions boolean DEFAULT NULL,
	prefix_length integer DEFAULT NULL,
	zero_terms_query dsl.es_match_zero_terms_query DEFAULT NULL,
	cutoff_frequency real DEFAULT NULL,
	operator dsl.es_match_operator DEFAULT NULL,
	auto_generate_synonyms_phrase_query boolean DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html</p>
<p>The <code>multi_match</code> query builds on the match query to allow multi-field queries.</p>
<hr />
<h4 id="dslquery_string"><a class="header" href="#dslquery_string"><code>dsl.query_string()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.query_string(
	query text,
	default_operator dsl.esqdsl_default_operators DEFAULT NULL,
	default_field text DEFAULT NULL,
	analyzer text DEFAULT NULL,
	quote_analyzer text DEFAULT NULL,
	allow_leading_wildcard boolean DEFAULT NULL,
	enable_position_increments boolean DEFAULT NULL,
	fuzzy_max_expansions integer DEFAULT NULL,
	fuzziness text DEFAULT NULL,
	fuzzy_prefix_length integer DEFAULT NULL,
	fuzzy_transpositions boolean DEFAULT NULL,
	phrase_slop integer DEFAULT NULL,
	boost real DEFAULT NULL,
	auto_generate_phrase_queries boolean DEFAULT NULL,
	analyze_wildcard boolean DEFAULT NULL,
	max_determinized_states integer DEFAULT NULL,
	minimum_should_match integer DEFAULT NULL,
	lenient boolean DEFAULT NULL,
	time_zone text DEFAULT NULL,
	quote_field_suffix text DEFAULT NULL,
	auto_generate_synonyms_phrase_query boolean DEFAULT NULL,
	all_fields boolean DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html</p>
<p>A query that uses a query parser in order to parse its content.  The query_string query parses the input and splits text around operators. Each textual part is analyzed independently of each other.</p>
<hr />
<h4 id="dslnested"><a class="header" href="#dslnested"><code>dsl.nested()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.nested (
	path text,
	query zdbquery,
	score_mode dsl.es_nested_score_mode DEFAULT 'avg'::dsl.es_nested_score_mode)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html</p>
<p>Nested query allows to query nested objects / docs (see nested mapping). The query is executed against the nested objects / docs as if they were indexed as separate docs (they are, internally) and resulting in the root parent doc (or parent nested mapping).</p>
<hr />
<h4 id="dslnoteq"><a class="header" href="#dslnoteq"><code>dsl.noteq()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.noteq (
	query zdbquery)
RETURNS zdbquery
</code></pre>
<p>Generates a <code>bool</code> query where the argument is the only member of the <code>bool</code> query’s <code>must_not</code> clause.</p>
<hr />
<h4 id="dslphrase"><a class="header" href="#dslphrase"><code>dsl.phrase()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.phrase (
	field text,
	query text,
	boost real DEFAULT NULL,
	slop integer DEFAULT NULL,
	analyzer text DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>Short-hand form of <code>dsl.match_phrase()</code>.</p>
<hr />
<h4 id="dslprefix"><a class="header" href="#dslprefix"><code>dsl.prefix()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.prefix (
	field text,
	prefix text,
	boost real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html</p>
<p>Matches documents that have fields containing terms with a specified prefix (not analyzed).</p>
<hr />
<h4 id="dslrange"><a class="header" href="#dslrange"><code>dsl.range()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.range (
	field text,
	lt numeric DEFAULT NULL,
	gt numeric DEFAULT NULL,
	lte numeric DEFAULT NULL,
	gte numeric DEFAULT NULL,
	boost real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html</p>
<p>Matches documents with fields that have terms within a certain range.  This form is for numeric values.</p>
<hr />
<h4 id="dslrange-1"><a class="header" href="#dslrange-1"><code>dsl.range()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.range (
	field text,
	lt text DEFAULT NULL,
	gt text DEFAULT NULL,
	lte text DEFAULT NULL,
	gte text DEFAULT NULL,
	boost real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html</p>
<p>Matches documents with fields that have terms within a certain range.  This form is for text values.</p>
<hr />
<h4 id="dslregexp"><a class="header" href="#dslregexp"><code>dsl.regexp()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.regexp (
	field text,
	regexp text,
	boost real DEFAULT NULL,
	flags dsl.es_regexp_flags[] DEFAULT NULL,
	max_determinized_states integer DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html</p>
<p>The regexp query allows you to use regular expression term queries.</p>
<hr />
<h4 id="dslscript"><a class="header" href="#dslscript"><code>dsl.script()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.script (
	source_code text,
	params json DEFAULT NULL,
	lang text DEFAULT 'painless'::text)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-script-query.html</p>
<p>A query allowing to define scripts as queries. They are typically used in a filter context.</p>
<hr />
<h4 id="dslspan_containing"><a class="header" href="#dslspan_containing"><code>dsl.span_containing()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.span_containing (
	little zdbquery,
	big zdbquery)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-containing-query.html</p>
<p>Returns matches which enclose another span query.</p>
<hr />
<h4 id="dslspan_first"><a class="header" href="#dslspan_first"><code>dsl.span_first()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.span_first (
	query zdbquery,
	&quot;end&quot; integer)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-first-query.html</p>
<p>Matches spans near the beginning of a field.</p>
<hr />
<h4 id="dslspan_masking"><a class="header" href="#dslspan_masking"><code>dsl.span_masking()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.span_masking (
	field text,
	query zdbquery)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-field-masking-query.html</p>
<p>Wrapper to allow span queries to participate in composite single-field span queries by lying about their search field.</p>
<hr />
<h4 id="dslspan_multi"><a class="header" href="#dslspan_multi"><code>dsl.span_multi()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.span_multi (
	query zdbquery)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-multi-term-query.html</p>
<p>Allows you to wrap a multi term query (one of <code>dsl.wildcard()</code>, <code>dsl.fuzzy()</code>, <code>dsl.prefix()</code>, <code>dsl.range()</code> or <code>dsl.regexp()</code> query) as a span query, so it can be nested. </p>
<hr />
<h4 id="dslspan_near"><a class="header" href="#dslspan_near"><code>dsl.span_near()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.span_near (
	in_order boolean,
	slop integer,
	VARIADIC clauses zdbquery[])
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-near-query.html</p>
<p>Matches spans which are near one another. One can specify slop, the maximum number of intervening unmatched positions, as well as whether matches are required to be in-order.</p>
<hr />
<h4 id="dslspan_not"><a class="header" href="#dslspan_not"><code>dsl.span_not()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.span_not (
	include zdbquery,
	exclude zdbquery,
	pre integer DEFAULT NULL,
	post integer DEFAULT NULL,
	dist integer DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-not-query.html</p>
<p>Removes matches which overlap with another span query or which are within x tokens before (controlled by the parameter pre) or y tokens after (controled by the parameter post) another SpanQuery.</p>
<hr />
<h4 id="dslspan_or"><a class="header" href="#dslspan_or"><code>dsl.span_or()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.span_or (
	VARIADIC clauses zdbquery[])
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-or-query.html</p>
<p>Matches the union of its span clauses.</p>
<hr />
<h4 id="dslspan_term"><a class="header" href="#dslspan_term"><code>dsl.span_term()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.span_term (
	field text,
	value text,
	boost real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-term-query.html</p>
<p>Matches spans containing a term. </p>
<hr />
<h4 id="dslspan_within"><a class="header" href="#dslspan_within"><code>dsl.span_within()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.span_within (
	little zdbquery,
	big zdbquery)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-within-query.html</p>
<p>Returns matches which are enclosed inside another span query.</p>
<hr />
<h4 id="dslterm"><a class="header" href="#dslterm"><code>dsl.term()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.term (
	field text,
	value numeric,
	boost real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html</p>
<p>The term query finds documents that contain the <strong>exact</strong> term specified in the inverted index.  This form is for numeric terms. </p>
<hr />
<h4 id="dslterm-1"><a class="header" href="#dslterm-1"><code>dsl.term()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.term (
	field text,
	value text,
	boost real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html</p>
<p>The term query finds documents that contain the <strong>exact</strong> term specified in the inverted index.  This form is for text terms. </p>
<hr />
<h4 id="dslterms"><a class="header" href="#dslterms"><code>dsl.terms()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.terms (
	field text,
	VARIADIC &quot;values&quot; numeric[])
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html</p>
<p>Filters documents that have fields that match any of the provided terms (not analyzed).  This form is for numeric terms.</p>
<hr />
<h4 id="dslterms-1"><a class="header" href="#dslterms-1"><code>dsl.terms()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.terms (
	field text,
	VARIADIC &quot;values&quot; text[])
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html</p>
<p>Filters documents that have fields that match any of the provided terms (not analyzed).  This form is for text terms.</p>
<hr />
<h4 id="dslterms_array"><a class="header" href="#dslterms_array"><code>dsl.terms_array()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.terms_array (
	field text,
	&quot;values&quot; anyarray)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html</p>
<p>Filters documents that have fields that match any of the provided terms (not analyzed).  This form is for an array of any kind of Postgres datatype.</p>
<hr />
<h4 id="dslterms_lookup"><a class="header" href="#dslterms_lookup"><code>dsl.terms_lookup()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.terms_lookup (
	field text,
	index text,
	type text,
	path text,
	id text)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html#query-dsl-terms-lookup</p>
<p>When it’s needed to specify a terms filter with a lot of terms it can be beneficial to fetch those term values from a document in an index.</p>
<hr />
<h4 id="dslwildcard"><a class="header" href="#dslwildcard"><code>dsl.wildcard()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.wildcard (
	field text,
	wildcard text,
	boost real DEFAULT NULL)
RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html</p>
<p>Matches documents that have fields matching a wildcard expression (not analyzed). Supported wildcards are *, which matches any character sequence (including the empty one), and ?, which matches any single character. Note that this query can be slow, as it needs to iterate over many terms. In order to prevent extremely slow wildcard queries, a wildcard term should not start with one of the wildcards * or ?.</p>
<h2 id="postgis-support"><a class="header" href="#postgis-support">Postgis Support</a></h2>
<p>ZomboDB provides basic support for Postgis.  It automatically maps columns of type <code>geometry</code> and <code>geography</code> to
Elasticsearch’s <code>geo_shape</code> type, and <code>geometry(Point, 2276)</code> is instead indexed as an Elasticsearch <code>geo_point</code>.</p>
<p>Additionally, it exposes a few functions for querying <code>geo_shape</code>s and polygons and bounding boxes.</p>
<hr />
<h4 id="dslgeo_shape"><a class="header" href="#dslgeo_shape"><code>dsl.geo_shape()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.geo_shape(
    field text,
    geojson_shape json,
    relation dsl.es_geo_shape_relation
) RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-shape-query.html</p>
<p>The geo_shape query uses the same grid square representation as the geo_shape mapping to find documents that have a shape that intersects with the query shape. It will also use the same PrefixTree configuration as defined for the field mapping.</p>
<p>The query supports one way of defining the query shape:  by providing a whole shape definition.</p>
<hr />
<h4 id="dslgeo_polygon"><a class="header" href="#dslgeo_polygon"><code>dsl.geo_polygon()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.geo_polygon(
    field text, 
    VARIADIC points point[]
) RETURNS zdbquery
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-polygon-query.html</p>
<p>Given an array of Postgres <code>point</code> objects, generates an Elasticsearch <code>geo_polygon()</code> query</p>
<hr />
<h4 id="dslgeo_bounding_box"><a class="header" href="#dslgeo_bounding_box"><code>dsl.geo_bounding_box()</code></a></h4>
<pre><code class="language-sql">FUNCTION dsl.geo_bounding_box(
    field text, 
    box box, 
    type dsl.es_geo_bounding_box_type DEFAULT 'memory'  -- one of 'memory' or 'indexed'
)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-bounding-box-query.html</p>
<p>Given a Postgres <code>box</code> object, generates an Elasticsearch <code>geo_bounding_box()</code> query</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-sql-functions"><a class="header" href="#using-sql-functions">Using SQL Functions</a></h1>
<p>ZomboDB provides a number of utility and helper SQL functions.</p>
<pre><code class="language-sql">FUNCTION zdb.internal_version() RETURNS text
</code></pre>
<p>Returns the version of the currently-installed ZomboDB shared library.</p>
<p>If this doesn’t match <code>SELECT zdb.schema_version()</code> there will be problems.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.schema_version() RETURNS text
</code></pre>
<p>Returns the schema version of the ZomboDB extension installed in the current database</p>
<p>If this doesn’t match <code>SELECT zdb.internal_version()</code> there will be problems.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.request(
	index regclass, 
	endpoint text, 
	method text DEFAULT 'GET', 
	post_data text DEFAULT NULL) 
RETURNS text
</code></pre>
<p>Make an arbitrary REST request to the Elasticsearch cluster hosting the specified index.</p>
<p>If the <code>endpoint</code> argument begins with a forward slash (<code>/</code>) the request is executed at the root of the Elasticsearch cluster.  Otherwise, the request is executed relative to the specified index.</p>
<p>For example, this returns the Elasticsearch cluster information:</p>
<pre><code class="language-sql">SELECT zdb.request('idxproducts', '/');
                            request                             
----------------------------------------------------------------
 {                                                             +
   &quot;name&quot; : &quot;emac16.lan&quot;,                                      +
   &quot;cluster_name&quot; : &quot;elasticsearch&quot;,                           +
   &quot;cluster_uuid&quot; : &quot;HPxSF2doQy-KHFfFKFPEZQ&quot;,                  +
   &quot;version&quot; : {                                               +
     &quot;number&quot; : &quot;7.9.0&quot;,                                       +
     &quot;build_flavor&quot; : &quot;default&quot;,                               +
     &quot;build_type&quot; : &quot;tar&quot;,                                     +
     &quot;build_hash&quot; : &quot;a479a2a7fce0389512d6a9361301708b92dff667&quot;,+
     &quot;build_date&quot; : &quot;2020-08-11T21:36:48.204330Z&quot;,             +
     &quot;build_snapshot&quot; : false,                                 +
     &quot;lucene_version&quot; : &quot;8.6.0&quot;,                               +
     &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,           +
     &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;     +
   },                                                          +
   &quot;tagline&quot; : &quot;You Know, for Search&quot;                          +
 }                                                             +
 
(1 row)
</code></pre>
<p>Whereas this returns the settings for the specified index:</p>
<pre><code class="language-sql"> SELECT zdb.request('idxproducts', '_settings');
                                    request                                    
-------------------------------------------------------------------------------
 {                                                                            +
     &quot;19524866.2200.19540060.19540070-882296036&quot;: {                           +
         &quot;settings&quot;: {                                                        +
             &quot;index&quot;: {                                                       +
                 &quot;uuid&quot;: &quot;Nw8D3ymUT9mbTCLTgBgMLA&quot;,                            +
                 &quot;query&quot;: {                                                   +
                     &quot;default_field&quot;: &quot;zdb_all&quot;                               +
                 },                                                           +
                 &quot;version&quot;: {                                                 +
                     &quot;created&quot;: &quot;5060499&quot;                                     +
                 },                                                           +
                 &quot;analysis&quot;: {                                                +
                     &quot;filter&quot;: {                                              +
...
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION profile_query(index regclass, query zdbquery) RETURNS json
</code></pre>
<p>Uses Elasticsearch’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-profile.html">Profile API</a> to provide detailed timing and execution information about a query.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.determine_index(relation regclass) RETURNS regclass
</code></pre>
<p>Given a relation oid (either an actual index, a table, or a view) return the <code>USING zombodb</code> index that will be used when
querying that relation.</p>
<p>If no index can be determined, <code>NULL</code> is returned.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.index_name(index regclass) RETURNS text
</code></pre>
<p>Returns the ZomboDB-generated Elasticsearch index name for the specified Postgres index.</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT zdb.index_name('idxproducts');
                index_name                 
-------------------------------------------
 19524866.2200.19540060.19540070-882296036
(1 row)
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION zdb.index_url(index regclass) RETURNS text
</code></pre>
<p>Returns the url to the Elasticsearch cluster which contains the specified Postgres index.</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT zdb.index_url('idxproducts');
       index_url        
------------------------
 http://localhost:9200/
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION zdb.index_type_name(index regclass) RETURNS text
</code></pre>
<p>Returns the Elasticsearch index type name being used.  Unless explicitly set during <code>CREATE INDEX</code> this will always return the string <code>doc</code>.</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT zdb.index_type_name('idxproducts');
 index_type_name 
-----------------
 doc
(1 row)
</code></pre>
<hr />
<p>FUNCTION zdb.index_field_lists(index_relation regclass) RETURNS TABLE (”fieldname” text, “fields” text[])</p>
<p>Returns a resultset describing all the field lists that are defined for the specified index.</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT * FROM zdb_get_index_field_lists('idxsome_index');
    fieldname     |           fields
------------------+----------------------------
 title_and_author | {title,author}
 hashes           | {sha1,md5}
(2 rows)
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION zdb.index_mapping(index regclass) RETURNS jsonb
</code></pre>
<p>Returns the full Elasticsearch mapping that ZomboDB generated for the specified Postgres index.  This can be useful for ensuring your custom analyzers and field mappings are properly defined.</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT * FROM zdb.index_mapping('idxproducts');
                                                      index_mapping                                                       
--------------------------------------------------------------------------------------------------------------------------
 {                                                                                                                       +
         &quot;mappings&quot;: {                                                                                                   +
             &quot;doc&quot;: {                                                                                                    +
                 &quot;_all&quot;: {                                                                                               +
                     &quot;enabled&quot;: false                                                                                    +
                 },                                                                                                      +
                 &quot;properties&quot;: {                                                                                         +
                     &quot;id&quot;: {                                                                                             +
                         &quot;type&quot;: &quot;long&quot;                                                                                  +
                     },                                                                                                  +
                     &quot;name&quot;: {                                                                                           +
                         &quot;type&quot;: &quot;text&quot;,                                                                                 +
                         &quot;copy_to&quot;: [                                                                                    +
                             &quot;zdb_all&quot;                                                                                   +
                         ],                                                                                              +
                         &quot;analyzer&quot;: &quot;zdb_standard&quot;,                                                                     +
                         &quot;fielddata&quot;: true                                                                               +
                     },                                                                                                  +
                     &quot;price&quot;: {                                                                                          +
                         &quot;type&quot;: &quot;long&quot;                                                                                  +
                     },                                                                                                  +
                     &quot;zdb_all&quot;: {                                                                                        +
                         &quot;type&quot;: &quot;text&quot;,                                                                                 +
                         &quot;analyzer&quot;: &quot;zdb_all_analyzer&quot;                                                                  +
                     },                                                                                                  +
                     &quot;keywords&quot;: {                                                                                       +
                         &quot;type&quot;: &quot;keyword&quot;,                                                                              +
                         &quot;copy_to&quot;: [                                                                                    +
                             &quot;zdb_all&quot;                                                                                   +
                         ],                                                                                              +
                         &quot;normalizer&quot;: &quot;lowercase&quot;,                                                                      +
                         &quot;ignore_above&quot;: 10922                                                                           +
                     },                                                                                                  +
                     &quot;zdb_cmax&quot;: {                                                                                       +
                         &quot;type&quot;: &quot;integer&quot;                                                                               +
                     },                                                                                                  +
                     &quot;zdb_cmin&quot;: {                                                                                       +
                         &quot;type&quot;: &quot;integer&quot;                                                                               +
                     },                                                                                                  +
                     &quot;zdb_ctid&quot;: {                                                                                       +
                         &quot;type&quot;: &quot;long&quot;                                                                                  +
                     },                                                                                                  +
                     &quot;zdb_xmax&quot;: {                                                                                       +
                         &quot;type&quot;: &quot;long&quot;                                                                                  +
                     },                                                                                                  +
                     &quot;zdb_xmin&quot;: {                                                                                       +
                         &quot;type&quot;: &quot;long&quot;                                                                                  +
                     },                                                                                                  +
                     &quot;discontinued&quot;: {                                                                                   +
                         &quot;type&quot;: &quot;boolean&quot;                                                                               +
                     },                                                                                                  +
                     &quot;short_summary&quot;: {                                                                                  +
                         &quot;type&quot;: &quot;text&quot;,                                                                                 +
                         &quot;copy_to&quot;: [                                                                                    +
                             &quot;zdb_all&quot;                                                                                   +
                         ],                                                                                              +
                         &quot;analyzer&quot;: &quot;zdb_standard&quot;,                                                                     +
                         &quot;fielddata&quot;: true                                                                               +
                     },                                                                                                  +
                     &quot;inventory_count&quot;: {                                                                                +
                         &quot;type&quot;: &quot;integer&quot;                                                                               +
                     },                                                                                                  +
                     &quot;long_description&quot;: {                                                                               +
                         &quot;type&quot;: &quot;text&quot;,                                                                                 +
                         &quot;copy_to&quot;: [                                                                                    +
                             &quot;zdb_all&quot;                                                                                   +
                         ],                                                                                              +
                         &quot;analyzer&quot;: &quot;zdb_standard&quot;                                                                      +
                     },                                                                                                  +
                     &quot;zdb_aborted_xids&quot;: {                                                                               +
                         &quot;type&quot;: &quot;long&quot;                                                                                  +
                     },                                                                                                  +
                     &quot;availability_date&quot;: {                                                                              +
                         &quot;type&quot;: &quot;date&quot;,                                                                                 +
                         &quot;copy_to&quot;: [                                                                                    +
                             &quot;zdb_all&quot;                                                                                   +
                         ]                                                                                               +
                     }                                                                                                   +
                 },                                                                                                      +
                 &quot;dynamic_templates&quot;: [                                                                                  +
                     {                                                                                                   +
                         &quot;strings&quot;: {                                                                                    +
                             &quot;mapping&quot;: {                                                                                +
                                 &quot;type&quot;: &quot;keyword&quot;,                                                                      +
                                 &quot;copy_to&quot;: &quot;zdb_all&quot;,                                                                   +
                                 &quot;normalizer&quot;: &quot;lowercase&quot;,                                                              +
                                 &quot;ignore_above&quot;: 10922                                                                   +
                             },                                                                                          +
                             &quot;match_mapping_type&quot;: &quot;string&quot;                                                              +
                         }                                                                                               +
                     },                                                                                                  +
                     {                                                                                                   +
                         &quot;dates_times&quot;: {                                                                                +
                             &quot;mapping&quot;: {                                                                                +
                                 &quot;type&quot;: &quot;date&quot;,                                                                         +
                                 &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis||HH:mm:ss.SSSSSS||HH:mm:ss.SSSSSSZZ&quot;,+
                                 &quot;copy_to&quot;: &quot;zdb_all&quot;                                                                    +
                             },                                                                                          +
                             &quot;match_mapping_type&quot;: &quot;date&quot;                                                                +
                         }                                                                                               +
                     }                                                                                                   +
                 ]                                                                                                       +
             }                                                                                                           +
         }                                                                                                               +
     }
(1 row)
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION zdb.field_mapping(index_relation regclass, field_name text) RETURNS json
</code></pre>
<p>Returns the Elasticsearch field mapping definition for the specified field.  In the event the specified index has
index links defined this will traverse those links to find the specified field.</p>
<p>Example:</p>
<pre><code class="language-sql">select zdb.field_mapping('idxevents', 'event_type');
                                         field_mapping                                         
-----------------------------------------------------------------------------------------------
 {&quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: [&quot;zdb_all&quot;], &quot;normalizer&quot;: &quot;lowercase&quot;, &quot;ignore_above&quot;: 10922}
(1 row)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoring"><a class="header" href="#scoring">Scoring</a></h1>
<p>ZomboDB provides a function named <code>zdb.score(tid) RETURNS real</code> that returns the score for the current matching row.  You can use it in the target list of your query and can also sort by it.</p>
<p>Without an <code>ORDER BY</code> clause, SQL doesn’t guarantee any kind of ordering, so it’s always important to also order by the score if you want the top-ranked documents first in your results.</p>
<p>Using the <a href="usage/TUTORIAL.html">tutorial</a> database, an example of using scores is:</p>
<pre><code class="language-sql">tutorial=# 
   SELECT zdb.score(ctid), * 
     FROM products 
    WHERE products ==&gt; 'sports box' 
 ORDER BY score desc;
  score   | id |   name   |               keywords               |         short_summary          |                                  long_description                                   | price | 
----------+----+----------+--------------------------------------+--------------------------------+-------------------------------------------------------------------------------------+-------+-
  1.00079 |  4 | Box      | {wooden,box,&quot;negative space&quot;,square} | Just an empty box made of wood | A wooden container that will eventually rot away.  Put stuff it in (but not a cat). | 17000 | 
 0.698622 |  2 | Baseball | {baseball,sports,round}              | It's a baseball                | Throw it at a person with a big wooden stick and hope they don't hit it             |  1249 | 
(2 rows)
</code></pre>
<p>Note that the argument provided to <code>zdb.score()</code> is the hidden Postgres system column called <code>ctid</code>.  Internally, ZomboDB uses ctids to identify matching rows, and this is how you tell <code>zdb.score()</code> the row you want.</p>
<p>Also, <code>zdb.score()</code> is <strong>not</strong> allowed in the <code>WHERE</code> clause of queries.  It is only allowed in <code>ORDER BY</code> clauses and what Postgres calls the “target list” -- the list of columns the query should return.</p>
<p>If you need to limit the results of a query by score you can use ZomboDB’s <a href="usage/QUERY-DSL.html"><code>dsl.min_score()</code></a> function, or you can use a subselect of some kind, such as:</p>
<pre><code class="language-sql">SELECT * FROM (SELECT zdb.score(ctid), * FROM products WHERE products ==&gt; 'sports box') x WHERE x.score &gt; 1.0;
</code></pre>
<p>But, this won’t work:</p>
<pre><code class="language-sql"># SELECT zdb.score(ctid), * FROM products WHERE products ==&gt; 'sports box' AND zdb.score(ctid) &gt; 1.0;
ERROR:  zdb.score() can only be used as a target entry or as a sort
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="highlighting"><a class="header" href="#highlighting">Highlighting</a></h1>
<p>Similar to <a href="usage/./scoring.html">scoring support</a>, ZomboDB can returning highlighted fragments from fields that support it (typically text fields that use an analyzer).  The function is called <code>zdb.highlight(tid, fieldname [, json_highlight_descriptor]) RETURNS text[]</code>.</p>
<p>Using the <a href="usage/TUTORIAL.html">tutorial</a> database, an example of highlighting is:</p>
<pre><code class="language-sql">tutorial=# 
     SELECT zdb.score(ctid), zdb.highlight(ctid, 'long_description'), long_description 
      FROM products 
     WHERE products ==&gt; 'wooden person' 
  ORDER BY score desc;
  score   |                                            highlight                                             |                                  long_description                                  
----------+--------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------
 0.882384 | {&quot;Throw it at a &lt;em&gt;person&lt;/em&gt; with a big &lt;em&gt;wooden&lt;/em&gt; stick and hope they don't hit it&quot;}    | Throw it at a person with a big wooden stick and hope they don't hit it
 0.224636 | {&quot;A &lt;em&gt;wooden&lt;/em&gt; container that will eventually rot away.  Put stuff it in (but not a cat).&quot;} | A wooden container that will eventually rot away.  Put stuff it in (but not a cat).
(2 rows)
</code></pre>
<p>Similarly to <code>zdb.score()</code>, the first argument to <code>zdb.highlight()</code> is the Postgres hidden system column <code>ctid</code> that identifies the row for which you want highlights.</p>
<p>As Elasticsearch can return multiple highlight fragments for any given field, <code>zdb.highlight()</code> returns a <code>text[]</code> which allows you to address each fragment individually.</p>
<p>ZomboDB uses Elasticsearch’s defaults for highlighting, but if these are not sufficient for your needs, the third argument to <code>zdb.highlight()</code> allows you to set a per-field highlight definition as decribed in <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html">Elasticsearch’s highlighting documentation</a>.</p>
<p>ZomboDB provides a type-checked helper function (also named <code>zdb.highlight()</code>) that allows you to build up a highlight definition using SQL.</p>
<pre><code class="language-sql">CREATE TYPE esqdsl_highlight_type AS ENUM ('unified', 'plain', 'fvh');
CREATE TYPE esqdsl_fragmenter_type AS ENUM ('simple', 'span');
CREATE TYPE esqdsl_encoder_type AS ENUM ('default', 'html');
CREATE TYPE esqdsl_boundary_scanner_type AS ENUM ('chars', 'sentence', 'word');

FUNCTION highlight(
    type zdb.esqdsl_highlight_type DEFAULT NULL,
    require_field_match boolean DEFAULT false,
    number_of_fragments int DEFAULT NULL,
    highlight_query zdbquery DEFAULT NULL,
    pre_tags text[] DEFAULT NULL,
    post_tags text[] DEFAULT NULL,
    tags_schema text DEFAULT NULL,
    no_match_size int DEFAULT NULL,

    fragmenter zdb.esqdsl_fragmenter_type DEFAULT NULL,
    fragment_size int DEFAULT NULL,
    fragment_offset int DEFAULT NULL,
    force_source boolean DEFAULT true,
    encoder zdb.esqdsl_encoder_type DEFAULT NULL,
    boundary_scanner_locale text DEFAULT NULL,
    boundary_scan_max int DEFAULT NULL,
    boundary_chars text DEFAULT NULL,
    phrase_limit int DEFAULT NULL,

    matched_fields boolean DEFAULT NULL,
    &quot;order&quot; text DEFAULT NULL) 
RETURNS json
</code></pre>
<p>An example usage of this function, where we change the pre/post highlight tags is:</p>
<pre><code class="language-sql">SELECT zdb.score(ctid), 
       zdb.highlight(ctid, 
                     'long_description', 
                     zdb.highlight(pre_tags=&gt;'{&lt;b&gt;}', post_tags=&gt;'{&lt;/b&gt;}')
                    ),
       long_description                                             
 FROM products
WHERE products ==&gt; 'wooden person'
ORDER BY score desc;
</code></pre>
<p>Which results in:</p>
<pre><code class="language-sql">  score   |                                           highlight                                            |                                  long_description                                   
----------+------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------
 0.882384 | {&quot;Throw it at a &lt;b&gt;person&lt;/b&gt; with a big &lt;b&gt;wooden&lt;/b&gt; stick and hope they don't hit it&quot;}      | Throw it at a person with a big wooden stick and hope they don't hit it
 0.224636 | {&quot;A &lt;b&gt;wooden&lt;/b&gt; container that will eventually rot away.  Put stuff it in (but not a cat).&quot;} | A wooden container that will eventually rot away.  Put stuff it in (but not a cat).
(2 rows)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-options"><a class="header" href="#index-options">Index Options</a></h1>
<p>As the <a href="usage//administration/index-management.html">Index Management</a> documentation indicates, ZomboDB supports a set of custom advanced-use options for defining how an index relates to other indexes.</p>
<h2 id="index-links"><a class="header" href="#index-links">Index Links</a></h2>
<p>Consider that you have two tables, each with a ZomboDB index, and that your typical use case is to join the tables together in a view:</p>
<pre><code class="language-sql">CREATE TABLE book (
   id bigserial not null primary key,
   title zdb.phrase,
   author varchar(64),
   publication_date date
);

CREATE TABLE book_content (
   book_id bigint not null primary key references book(id),
   content zdb.fulltext
);

CREATE INDEX idxbook ON book USING zombodb ((book.*));
CREATE INDEX idxcontent ON book_content USING zombodb ((book_content.*));

CREATE VIEW books_with_content AS 
   SELECT book.*, 
          book_content.content,
          book AS zdb
     FROM book
LEFT JOIN book_content ON book.id = book_content.book_id;

</code></pre>
<p>Suppose you want to do a full-text query against the <code>books_with_content</code> view.  The query would be:</p>
<pre><code class="language-sql">SELECT * FROM books_with_content WHERE zdb ==&gt; 'author:foo and content:(beer w/3 wine w/30 cheese and food)';
</code></pre>
<p>Unfortunately, the above query will return zero rows because the index on <code>book</code> (which will be the chosen index due to the <code>book AS zdb</code> column in the VIEW) doesn’t have a column named <code>content</code> -- that data lives in the <code>book_content</code> table.</p>
<p>We need to tell the index on <code>book</code> how to find corresponding <code>book_content</code> using an “index link”.  This is done through ZomboDB’s index <code>options</code>:</p>
<pre><code class="language-sql">ALTER INDEX idxbook SET (options='id=&lt;public.book_content.idxcontent&gt;book_id');
</code></pre>
<p>Now, when you run the above query, it’ll be able to transparently search <strong>both</strong> indexes and “join” the matching data while searching.</p>
<p>The <code>options</code> string is a comma-separated list in the form of <code>local_field=&lt;schema.other_table.other_index&gt;other_field</code>.</p>
<p>A maximum of 1024 comma-separated index links can be set (in the <code>options</code> property), and the relationship types (one-to-one, one-to-many, many-to-many) don’t matter.</p>
<p>This is a powerful feature because it allows you to keep your data as normalized as you want while still providing the ability to perform full text queries across all of it.</p>
<h2 id="naming-index-links"><a class="header" href="#naming-index-links">Naming Index Links</a></h2>
<p>Index links can also be named, such that the fields behind the link appear to be part of another “object”.</p>
<p>Taking the example from above:</p>
<pre><code class="language-sql">ALTER INDEX idxbook SET (options='id=&lt;public.book_content.idxcontent&gt;book_id');
</code></pre>
<p>We could have, for example, named the index link <code>book_content</code>:</p>
<pre><code class="language-sql">ALTER INDEX idxbook SET (options='book_content:(id=&lt;public.book_content.idxcontent&gt;book_id)');
</code></pre>
<p>And then the query would be:</p>
<pre><code class="language-sql">SELECT * FROM books_with_content WHERE zdb ==&gt; 'author:foo and book_content.content:(beer w/3 wine w/30 cheese and food)';
</code></pre>
<p>In general, this is a convenience feature for logically separating linked indexes by their domain, however it becomes more important when defining and searching <code>shadow</code> indexes.</p>
<h2 id="further-discussion"><a class="header" href="#further-discussion">Further Discussion</a></h2>
<p>What you’re doing in the <code>options='...'</code> string is telling ZomboDB how to get from one index to another.  You’re not technically describing “join conditions”.  You’re describing how to lookup data in a different index and relate it to another index.</p>
<p>A more complex example might be:</p>
<pre><code>options='content:(id=&lt;public.book_content.idxcontent&gt;book_id), 
        checkout_history:(id=&lt;public.checkout_history.idxcheckout_history&gt;book_id), 
        users:(checkout_history.user_id=&lt;public.users.idxusers&gt;id)'
</code></pre>
<p>So imagine two more tables named <code>checkout_history</code> and <code>users</code> with schemas as you might expect, both of which have ZomboDB indexes.</p>
<p>Behind the scenes, ZomboDB builds a graph of the relationships you define, and dynamically solves how to answer your query.  It’s even able to see through multiple-levels of indirection.</p>
<p>With the above definition, you’d be able to find all the books checked out by a particular user:</p>
<pre><code class="language-sql">SELECT * 
  FROM book 
 WHERE book ==&gt; 'author:shakespeare and users.full_name:&quot;John Doe&quot;'
</code></pre>
<p>The relationships need not be relative to the <code>book</code> table, as shown by the <code>users:(checkout_history.user_id=&lt;public.users.idxusers&gt;id)</code> link.  ZomboDB understands that in order to get to the <code>users</code> index, it first has to go through <code>checkout_history</code>, and it knows that <code>checkout_history</code> links to <code>book</code> via the <code>checkout_history:(id=&lt;public.checkout_history.idxcheckout_history&gt;book_id)</code> link.</p>
<p>If you were to write the query as SQL, it would look like:</p>
<pre><code class="language-sql">SELECT * 
 FROM book 
WHERE author ILIKE '%shakespeare%' 
  AND id IN (SELECT book_id 
               FROM checkout_history 
              WHERE user_id IN (SELECT id 
                                 FROM users 
                                WHERE full_name = 'John Doe'
                               )
             );
</code></pre>
<p>Rather than setting <code>options='...'</code> on the index, ZomboDB also provides the ability to specify them at runtime.  To do that you want to make sure there’s no <code>options='...'</code> property on the index, and then instead specify the link options using the <code>zdb.link_options()</code> function:</p>
<pre><code class="language-sql">SELECT * 
  FROM book 
 WHERE book ==&gt; zdb.index_options(
        ARRAY[
                'content:(id=&lt;public.book_content.idxcontent&gt;book_id)', 
                'checkout_history:(id=&lt;public.checkout_history.idxcheckout_history&gt;book_id)', 
                'users:(public.checkout_history.user_id=&lt;users.idxusers&gt;id)'
        ],
        'author:shakespeare and user.full_name:&quot;John Doe&quot;'
    );
</code></pre>
<h1 id="shadow-indexes"><a class="header" href="#shadow-indexes">Shadow Indexes</a></h1>
<p>Shadow indexes are indexes that use an existing ZomboDB index, but let you specify different <code>options</code>.  This is useful if an index is 
used in many different SQL-level views (or JOIN) situations where different linking <code>options='...'</code> are desired.</p>
<p>Shadow indexes do not consume additional disk resources, so they’re “free” to create as needed.</p>
<p>In order to create a shadow index, you first need to make a custom UDF to use as the first column of the <code>CREATE INDEX</code> statement, and 
as the left-hand-side of the <code>==&gt;</code> operator.  This is necessary so that Postgres will decide to use the shadow index instead of the real
index.</p>
<p>You also need to define a new index (via <code>CREATE INDEX</code>) that specifies a <code>WITH</code> parameter named <code>shadow</code> instead of using 
the <code>url</code> parameter.  The <code>shadow</code> argument is simply a boolean, whose value should be <code>true</code>.</p>
<h2 id="custom-shadow-function-udf"><a class="header" href="#custom-shadow-function-udf">Custom “shadow function” UDF</a></h2>
<p>First, make a function that is defined exactly as below.  You can change the name of the function:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION my_shadow_func(anyelement)
    RETURNS anyelement
    IMMUTABLE STRICT
    LANGUAGE c AS '$libdir/zombodb.so', 'shadow_wrapper';
</code></pre>
<p>Again, this function will be used for <code>CREATE INDEX</code> and queries.</p>
<h2 id="the-shadow-index"><a class="header" href="#the-shadow-index">The <code>shadow</code> Index</a></h2>
<p>Next, create a shadow index:</p>
<pre><code class="language-sql">CREATE INDEX idxshadow ON (book) 
       USING zombodb(my_shadow_func((book.*))) 
        WITH (shadow=true, options='&lt;custom set of options&gt;');
</code></pre>
<p>This index is set to use the existing index named <code>idxbook</code> and doesn’t consume additional disk space or overhead when updating.<br />
Think of it as a “view” on top of another index.</p>
<h2 id="query"><a class="header" href="#query">Query</a></h2>
<pre><code class="language-sql">SELECT * 
  FROM book 
 WHERE my_shadow_func(book) ==&gt; 'shakespeare';
</code></pre>
<p>Using the custom function you made above will allow Postgres to choose the shadow index that also uses that 
function (<code>idxshadow</code>) and then ZomboDB will apply the <code>options='...'</code> from the shadow index rather than the base
<code>idxbook</code> index.</p>
<h2 id="usage-with-views"><a class="header" href="#usage-with-views">Usage with Views</a></h2>
<p>If you want to use this in a view, it is <strong>required</strong> that you include <code>my_shadow_func()</code> in the output list and that it 
be aliased <code>AS zdb</code>.  For example:</p>
<pre><code class="language-sql">CREATE VIEW test AS 
   SELECT *, my_shadow_func(bool) AS zdb FROM book;
</code></pre>
<p>Then you can query it as:</p>
<pre><code class="language-sql">SELECT * FROM test WHERE zdb ==&gt; 'shakespeare';
</code></pre>
<p>And of course, the view can be as complex as you need and can include whatever other tables you might want.</p>
<p>It’s important to remember that ZomboDB is only going to return matching rows from the base table (the table specified 
as the argument to <code>my_shadow_func()</code>), so you’ll need to structure your view accordingly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregate-functions"><a class="header" href="#aggregate-functions">Aggregate Functions</a></h1>
<p>ZomboDB exposes nearly all of Elasticsearch’s aggregates as type-checked SQL functions that return tables and discreet values, as opposed to json blobs.</p>
<p>In all cases, unless explicitly otherwise noted, the results returned from all of the below aggregate functions are MVCC-correct.  This means that the functions only operate against records that are considered visible to the current transaction.</p>
<h2 id="arbitrary-aggregate-support"><a class="header" href="#arbitrary-aggregate-support">Arbitrary Aggregate Support</a></h2>
<pre><code class="language-sql">FUNCTION zdb.arbitrary_agg(
	index regclass,
	query zdbquery,
	agg_json json) 
RETURNS json
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html</p>
<p>This function is a direct-path for executing any arbitrary aggregate search request that Elasticsearch supports.</p>
<p>The result is a json blob that can be processed in your application code or otherwise manipulated using Postgres json support functions.</p>
<h2 id="single-value-aggregates"><a class="header" href="#single-value-aggregates">Single-Value Aggregates</a></h2>
<pre><code class="language-sql">FUNCTION zdb.avg(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-avg-aggregation.html</p>
<p>A single-value metrics aggregation that computes the average of numeric values that are extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.cardinality(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-cardinality-aggregation.html</p>
<p>A single-value metrics aggregation that calculates an approximate count of distinct values. Values can be extracted either from specific fields in the document.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.count(
	index regclass,
	query zdbquery) 
RETURNS bigint
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html</p>
<p>Not an aggregate per se, this function is mapped to Elasticsearch’s <code>_count</code> endpoint and simply returns the number of documents that match the provided query.  The result is MVCC-correct.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.raw_count(
	index regclass,
	query zdbquery) 
RETURNS bigint SET zdb.ignore_visibility = true
</code></pre>
<p>Similar to <code>zdb.count()</code> above, but it ignores MVCC visibility rules, and the result is the actual count of documents matching the query, including deleted documents, documents from aborted transactions, old versions of documents from an UPDATE statement, and new/updated docs from in-flight transactions.</p>
<p>Generally you’ll want to use <code>zdb.count()</code> instead.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.max(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-max-aggregation.html</p>
<p>A single-value metrics aggregation that keeps track and returns the maximum value among the numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.min(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-min-aggregation.html</p>
<p>A single-value metrics aggregation that keeps track and returns the minimum value among numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.missing(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-missing-aggregation.html</p>
<p>A field data based single bucket aggregation, that creates a bucket of all documents in the current document set context that are missing a field value (effectively, missing a field or having the configured NULL value set).</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.sum(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-sum-aggregation.html</p>
<p>A single-value metrics aggregation that sums up numeric values that are extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.value_count(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-valuecount-aggregation.html</p>
<p>A single-value metrics aggregation that counts the number of values that are extracted from the aggregated documents. These values can be extracted either from specific fields in the documents.</p>
<hr />
<h2 id="multi-rowcolumn-aggregates"><a class="header" href="#multi-rowcolumn-aggregates">Multi-Row/Column Aggregates</a></h2>
<p>The following aggregates transform the results from Elasticsearch into “tables”, and should all be queried as such.  For example:</p>
<pre><code class="language-sql">SELECT * FROM zdb.terms('idxproducts', 'tags', dsl.match_all());
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	key text,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-adjacency-matrix-aggregation.html</p>
<p>A bucket aggregation returning a form of adjacency matrix. The request provides a collection of named filter expressions, similar to the filters aggregation request. Each bucket in the response represents a non-empty cell in the matrix of intersecting filters.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix_2x2(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	&quot;-&quot; text,
	&quot;1&quot; text,
	&quot;2&quot; text)
</code></pre>
<p>This is a table-based version of <code>zdb.adjacency_matrix()</code> that outputs a 2x2 matrix.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix_3x3(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	&quot;-&quot; text,
	&quot;1&quot; text,
	&quot;2&quot; text,
	&quot;3&quot; text)
</code></pre>
<p>This is a table-based version of <code>zdb.adjacency_matrix()</code> that outputs a 3x3 matrix.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix_4x4(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	&quot;-&quot; text,
	&quot;1&quot; text,
	&quot;2&quot; text,
	&quot;3&quot; text,
	&quot;4&quot; text)
</code></pre>
<p>This is a table-based version of <code>zdb.adjacency_matrix()</code> that outputs a 4x4 matrix.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix_5x5(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	&quot;-&quot; text,
	&quot;1&quot; text,
	&quot;2&quot; text,
	&quot;3&quot; text,
	&quot;4&quot; text,
	&quot;5&quot; text)
</code></pre>
<p>This is a table-based version of <code>zdb.adjacency_matrix()</code> that outputs a 5x5 matrix.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.date_histogram(
	index regclass,
	field text,
	query zdbquery,
	&quot;interval&quot; text,
	format text DEFAULT 'yyyy-MM-dd') 
RETURNS TABLE (
	key numeric,
	key_as_string text,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-datehistogram-aggregation.html</p>
<p>A multi-bucket aggregation similar to the histogram except it can only be applied on date values. Since dates are represented in Elasticsearch internally as long values, it is possible to use the normal histogram on dates as well, though accuracy will be compromised. The reason for this is in the fact that time based intervals are not fixed (think of leap years and on the number of days in a month). For this reason, we need special support for time based data. From a functionality perspective, this histogram supports the same features as the normal histogram. The main difference is that the interval can be specified by date/time expressions.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.date_range(
	index regclass,
	field text,
	query zdbquery,
	date_ranges_array json) 
RETURNS TABLE (
	key text,
	&quot;from&quot; numeric,
	from_as_string timestamp with time zone,
	&quot;to&quot; numeric,
	to_as_string timestamp with time zone,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html</p>
<p>A range aggregation that is dedicated for date values. The main difference between this aggregation and the normal range aggregation is that the from and to values can be expressed in Date Math expressions, and it is also possible to specify a date format by which the from and to response fields will be returned. Note that this aggregation includes the from value and excludes the to value for each range.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.extended_stats(
	index regclass,
	field text,
	query zdbquery,
	sigma int DEFAULT 0) 
RETURNS TABLE (
	count bigint,
	min numeric,
	max numeric,
	avg numeric,
	sum numeric,
	sum_of_squares numeric,
	variance numeric,
	stddev numeric,
	stddev_upper numeric,
	stddev_lower numeric)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-extendedstats-aggregation.html</p>
<p>A multi-value metrics aggregation that computes stats over numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.filters(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	label text,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filters-aggregation.html</p>
<p>Similar to <code>zdb.count()</code> except multiple queries (filters) are supported.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.histogram(
	index regclass,
	field text,
	query zdbquery,
	&quot;interval&quot; float8) 
RETURNS TABLE (
	key numeric,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-histogram-aggregation.html</p>
<p>A multi-bucket values source based aggregation that can be applied on numeric values extracted from the documents. It dynamically builds fixed size (a.k.a. interval) buckets over the values. For example, if the documents have a field that holds a price (numeric), we can configure this aggregation to dynamically build buckets with interval 5 (in case of price it may represent $5).</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.ip_range(
	index regclass,
	field text,
	query zdbquery,
	ip_ranges_array json) 
RETURNS TABLE (
	key text,
	&quot;from&quot; inet,
	&quot;to&quot; inet,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-iprange-aggregation.html</p>
<p>Just like the dedicated date range aggregation, there is also a dedicated range aggregation for IP typed fields.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.matrix_stats(
	index regclass,
	fields text[],
	query zdbquery) 
RETURNS TABLE (
	name text,
	count bigint,
	mean numeric,
	variance numeric,
	skewness numeric,
	kurtosis numeric,
	covariance json,
	correlation json)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-matrix-stats-aggregation.html</p>
<p>The matrix_stats aggregation is a numeric aggregation that computes various statistics over a set of document fields.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.percentile_ranks(
	index regclass,
	field text,
	query zdbquery,
	&quot;values&quot; text DEFAULT '') 
RETURNS TABLE (
	percentile numeric,
	value numeric)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-rank-aggregation.html</p>
<p>A multi-value metrics aggregation that calculates one or more percentile ranks over numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.percentiles(
	index regclass,
	field text,
	query zdbquery,
	percents text DEFAULT '') 
RETURNS TABLE (
	percentile numeric,
	value numeric)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-aggregation.html</p>
<p>A multi-value metrics aggregation that calculates one or more percentiles over numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.range(
	index regclass,
	field text,
	query zdbquery,
	ranges_array json) 
RETURNS TABLE (
	key text,
	&quot;from&quot; numeric,
	&quot;to&quot; numeric,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-range-aggregation.html</p>
<p>A multi-bucket value source based aggregation that enables the user to define a set of ranges - each representing a bucket. During the aggregation process, the values extracted from each document will be checked against each bucket range and “bucket” the relevant/matching document. Note that this aggregation includes the from value and excludes the to value for each range.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.significant_terms(
	index regclass,
	field text,
	query zdbquery) 
RETURNS TABLE (
	term text,
	doc_count bigint,
	score numeric,
	bg_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significantterms-aggregation.html</p>
<p>An aggregation that returns interesting or unusual occurrences of terms in a set.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.significant_terms_two_level(
	index regclass,
	first_field text,
	second_field text,
	query zdbquery,
	size bigint DEFAULT 0) 
RETURNS TABLE (
	first_term text,
	second_term text,
	doc_count bigint,
	score numeric,
	bg_count bigint,
	doc_count_error_upper_bound bigint,
	sum_other_doc_count bigint)
</code></pre>
<p>An adaption of <code>zdb.significant_terms()</code> where it uses <code>zdb.terms()</code> for the terms from <code>first_field</code> and <code>zdb.significant_terms()</code> for the terms for <code>second_field</code>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.significant_text(
	index regclass,
	field text,
	query zdbquery,
	sample_size int DEFAULT 0,
	filter_duplicate_text boolean DEFAULT true) 
RETURNS TABLE (
	term text,
	doc_count bigint,
	score numeric,
	bg_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significanttext-aggregation.html</p>
<p>An aggregation that returns interesting or unusual occurrences of free-text terms in a set. It is like the significant terms aggregation but differs in that:</p>
<ul>
<li>It is specifically designed for use on type text fields</li>
<li>It does not require field data or doc-values</li>
<li>It re-analyzes text content on-the-fly meaning it can also filter duplicate sections of noisy text that otherwise tend to skew statistics.</li>
</ul>
<p>This aggregate is only supported by Elasticsearch 6+ clusters.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.suggest_terms(
    index regclass,
    field_name text,
    suggest test,
    query zdbquery,
) RETURNS TABLE (
        term text,
        offset bigint,
        length bigint,
        suggestion text,
        score double precision,
        frequency bigint,

)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html</p>
<p>While not necessarily an aggregate, <code>zdb.terms_suggester</code> will tokenize an input textual suggestion string
and provide suggestions for each token that contains suggestions.</p>
<p>Useful for correcting misspellings -- ie, “Did you mean?”-style queries</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.stats(
	index regclass,
	field text,
	query zdbquery) 
RETURNS TABLE (
	count bigint,
	min numeric,
	max numeric,
	avg numeric,
	sum numeric)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-stats-aggregation.html</p>
<p>A multi-value metrics aggregation that computes stats over numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-FUNCTION zdb_tally(">    index_name regclass, 
    fieldname text 
    [, is_nested boolean], 
    stem text, 
    query zdbquery, 
    max_terms bigint, 
    sort_order zdb_tally_order 
    [, shard_size int DEFAULT 0]) 
RETURNS SET OF zdb_tally_response
</code></pre>
<p><code>index_name</code>:  The name of the a ZomboDB index to query<br />
<code>fieldname</code>: The name of a field from which to derive terms<br />
<code>is_nested</code>: Optional argument to indicate that the terms should only come from matching nested object sub-elements.  Default is <code>false</code><br />
<code>stem</code>:  a Regular expression by which to filter returned terms, or a date interval if the specified <code>fieldname</code> is a date or timestamp<br />
<code>query</code>: a ZomboDB query<br />
<code>max_terms</code>: maximum number of terms to return.  A value of zero means “all terms”.
<code>sort_order</code>: how to sort the terms.  one of <code>'count'</code>, <code>'term'</code>, <code>'reverse_count'</code>, <code>'reverse_term'</code><br />
<code>shard_size</code>: optional parameter that tells Elasticsearch how many terms to return from each shard.  Default is zero, which means all terms</p>
<p>This function provides direct access to Elasticsearch’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html">terms aggregate</a> and cannot
be used with fields of type <code>fulltext</code>.  The results are MVCC-safe.  Returned terms are forced to upper-case.</p>
<p>If a stem is not specified, no results will be returned.</p>
<p>To match all terms: <code>^.*</code></p>
<p>If the specifield <code>fieldname</code> is a date/timestamp, then one of the following values are allowed for aggregating values 
into histogram buckets of the specified interval: <code>year, quarter, month, week, day, hour, minute, second</code>.  In all cases, 
an optional offset value can be specified.  For example:  <code>week:-1d</code> will offset the dates by one day so that the first 
day of the week will be considered to be Sunday (instead of the default of Monday).</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT * FROM zdb_tally('products', 'keywords', '^.*', 'base* or distance', 5000, 'term');

    term      | count 
&gt;---------------+-------
BASEBALL      |     1
COMMUNICATION |     1
PRIMITIVE     |     1
SPORTS        |     1
THOMAS EDISON |     1
</code></pre>
<p>Regarding the <code>is_nested</code> argument, consider data like this:</p>
<pre><code>row #1: contributor_data=[ 
  { &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 42, &quot;location&quot;: &quot;TX&quot;, &quot;tags&quot;: [&quot;active&quot;] },
  { &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 36, &quot;location&quot;: &quot;TX&quot;, &quot;tags&quot;: [&quot;nice&quot;] }
&gt;]
&gt;
&gt;row #2: contributor_data=[ 
  { &quot;name&quot;: &quot;Bob Dole&quot;, &quot;age&quot;: 92, &quot;location&quot;: &quot;KS&quot;, &quot;tags&quot;: [&quot;nice&quot;, &quot;politician&quot;] },
  { &quot;name&quot;: &quot;Elizabth Dole&quot;, &quot;age&quot;: 79, &quot;location&quot;: &quot;KS&quot;, &quot;tags&quot;: [&quot;nice&quot;] }
&gt;]
</code></pre>
<p>And a query where <code>is_nested</code> is false:</p>
<pre><code class="language-sql">SELECT * FROM zdb.tally('idxproducts', 'contributor_data.name', false, '^.*', 'contributor_data.location:TX AND contributor_data.tags:nice', 5000, 'term');
</code></pre>
<p>returns:</p>
<pre><code>    term   | count 
----------+-------
  JANE DOE |     1
  JOHN DOE |     1
(2 rows)
</code></pre>
<blockquote>
<p>Whereas, if <code>is_nested</code> is true, only “JANE DOE” is returned because it’s the only subelement of <code>contributor_data</code> that matched the query:</p>
</blockquote>
<pre><code class="language-sql">SELECT * FROM zdb.tally('idxproducts', 'contributor_data.name', true, '^.*', 'contributor_data.location:TX WITH contributor_data.tags:nice', 5000, 'term');
</code></pre>
<p>returns:</p>
<pre><code>    term   | count 
----------+-------
  JANE DOE |     1
(1 row)
</code></pre>
<pre><code class="language-sql">CREATE TYPE terms_order AS ENUM (
	'count',
	'term',
	'reverse_count',
	'reverse_term');
FUNCTION zdb.terms(
	index regclass,
	field text,
	query zdbquery,
	size_limit bigint DEFAULT 0,
	order_by terms_order DEFAULT 'count') 
RETURNS TABLE (
	term text,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html</p>
<p>A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.terms_array(
	index regclass,
	field text,
	query zdbquery,
	size_limit bigint DEFAULT 0,
	order_by terms_order DEFAULT 'count') 
RETURNS text[]
</code></pre>
<p>A version of <code>zdb.terms()</code> that instead returns only the terms as a <code>text[]</code>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.terms_two_level(
	index regclass,
	first_field text,
	second_field text,
	query zdbquery,
	order_by terms_order DEFAULT 'count',
	size bigint DEFAULT 0) 
RETURNS TABLE (
	first_term text,
	second_term text,
	doc_count bigint)
</code></pre>
<p>Similar to <code>zdb.significant_terms_two_level()</code>, this is an adaption of <code>zdb.terms()</code> to provide a two-level nested hierarchy of terms from two different fields.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.top_hits(
	index regclass,
	fields text[],
	query zdbquery,
	size int) 
RETURNS TABLE (
	ctid tid,
	score float4,
	source json)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-top-hits-aggregation.html</p>
<p>A top_hits metric aggregator keeps track of the most relevant document being aggregated. This aggregator is intended to be used as a sub aggregator, so that the top matching documents can be aggregated per bucket.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.top_hits_with_id(
	index regclass,
	fields text[],
	query zdbquery,
	size int) 
RETURNS TABLE (
	_id text,
	score float4,
	source json)
</code></pre>
<p>Similar to <code>zdb.top_hits()</code> above, but returns the Elasticsearch document <code>_id</code> value for each hit rather than the corresponding Postgres <code>ctid</code> value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregate-builder-api"><a class="header" href="#aggregate-builder-api">Aggregate Builder API</a></h1>
<p>The ZDB Aggregate build API is a tool used to build complex aggregate Json that can be used with the Arbitrary Agg function.</p>
<p>Currently we support the following aggregations: 
Metric: Sum, Avg, Min, Max, Stats, Cardinality, Extended Stats, Matrix stats, Geo_Bound, Box_plot, Geo_Centroid, Median_Absolute_Deviation, Percentiles, String_Stats, Weighted_Avg, Top_Metric, T_Test, Value_Count
Buckets: Date_Histogram, Histogram, Filter, Filters, Range, Terms </p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>If you want perform a <code>sum</code> aggregation it would look something like this: </p>
<pre><code>SELECT * FROM zdb.sum_agg('example_agg', 'fieldname');
</code></pre>
<p>Which will return</p>
<pre><code>                    sum_agg                    
-----------------------------------------------
 {&quot;test_agg&quot;: {&quot;sum&quot;: {&quot;field&quot;: &quot;fieldname&quot;}}}
(1 row)

Time: 18.449 ms
</code></pre>
<p>If you do <code>\df zdb.*_agg</code> you will notice many of the “metric aggregations” have multiple function 
signatures. This is to accommodate different forms of the Aggregates.</p>
<p>To Continue the Example from above:</p>
<pre><code>SELECT * FROM zdb.sum_agg('example_agg', 'field_name', 10);
</code></pre>
<p>This will use 10 as the “missing” value producing</p>
<pre><code class="language-sum_agg">   ----------------------------------------------------------------
    {&quot;test_agg&quot;: {&quot;sum&quot;: {&quot;field&quot;: &quot;fieldname&quot;, &quot;missing&quot;: 10.0}}}
   (1 row)
</code></pre>
<h2 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h2>
<h3 id="sum_agg"><a class="header" href="#sum_agg"><code>sum_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.sum_agg (
    aggregate_name: text, 
    field: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.sum_agg (
    aggregate_name: text, 
    field: text, 
    missing: bigint,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.sum_agg (
    aggregate_name: text, 
    field: text,  
    missing: double precision
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-sum-aggregation.html
A single-value metrics aggregation that sums up numeric values that are extracted from the aggregated documents. </p>
<hr />
<h3 id="avg_agg"><a class="header" href="#avg_agg"><code>avg_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.avg_agg (
    aggregate_name: text, 
    field: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.avg_agg (
    aggregate_name: text, 
    field: text, 
    missing: bigint,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.avg_agg (
    aggregate_name: text, 
    field: text,  
    missing: double precision
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-avg-aggregation.html
A single-value metrics aggregation that computes the average of numeric values that are extracted from the aggregated documents. </p>
<hr />
<h3 id="min_agg"><a class="header" href="#min_agg"><code>min_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.min_agg (
    aggregate_name: text, 
    field: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.min_agg (
    aggregate_name: text, 
    field: text, 
    missing: bigint,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.min_agg (
    aggregate_name: text, 
    field: text,  
    missing: double precision
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-min-aggregation.html
A single-value metrics aggregation that keeps track and returns the minimum value among numeric values extracted from the aggregated documents. </p>
<hr />
<h3 id="max_agg"><a class="header" href="#max_agg"><code>max_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.max_agg (
    aggregate_name: text, 
    field: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.max_agg (
    aggregate_name: text, 
    field: text, 
    missing: bigint,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.max_agg (
    aggregate_name: text, 
    field: text,  
    missing: double precision
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-max-aggregation.html
A single-value metrics aggregation that keeps track and returns the maximum value among the numeric values extracted from the aggregated documents.</p>
<hr />
<h3 id="stats_agg"><a class="header" href="#stats_agg"><code>stats_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.stats_agg (
    aggregate_name: text, 
    field: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.stats_agg (
    aggregate_name: text, 
    field: text,
    missing: bigint,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.stats_agg (
    aggregate_name: text, 
    field: text,  
    missing: double precision
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-stats-aggregation.html
A multi-value metrics aggregation that computes stats over numeric values extracted from the aggregated documents. </p>
<hr />
<h3 id="cardinality_agg"><a class="header" href="#cardinality_agg"><code>cardinality_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.cardinality_agg (
    aggregate_name: text, 
    field: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.cardinality_agg (
    aggregate_name: text, 
    field: text, 
    missing: bigint,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.cardinality_agg (
    aggregate_name: text, 
    field: text,  
    missing: double precision
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-cardinality-aggregation.html
A single-value metrics aggregation that calculates an approximate count of distinct values.</p>
<hr />
<h3 id="extended_stats_agg"><a class="header" href="#extended_stats_agg"><code>extended_stats_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.extended_stats_agg (
    aggregate_name: text, 
    field: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.extended_stats_agg (
    aggregate_name: text, 
    field: text, 
    missing: bigint,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.extended_stats_agg (
    aggregate_name: text, 
    field: text,  
    missing: double precision
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-extendedstats-aggregation.html
A multi-value metrics aggregation that computes stats over numeric values extracted from the aggregated documents.</p>
<hr />
<h3 id="matrix_stats_agg"><a class="header" href="#matrix_stats_agg"><code>matrix_stats_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.matrix_stats_agg (
    aggregate_name: text, 
    field: text[]
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.matrix_stats_agg (
    aggregate_name: text, 
    field: text[], 
    missing_field: text, 
    missing_value: bigint,
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-matrix-stats-aggregation.html
The matrix_stats aggregation is a numeric aggregation that computes the following statistics over a set of document fields:
count, mean, variance, skewness, kurtosis, covariance, correlation</p>
<hr />
<h3 id="geo_bounds_agg"><a class="header" href="#geo_bounds_agg"><code>geo_bounds_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.geo_bounds_agg (
    aggregate_name: text, 
    field: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.geo_bounds_agg (
    aggregate_name: text, 
    field: text,  
    wrap_longitude: boolean,
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-geobounds-aggregation.html
A metric aggregation that computes the bounding box containing all geo values for a field.</p>
<hr />
<h3 id="box_plot_agg"><a class="header" href="#box_plot_agg"><code>box_plot_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.box_plot_agg (
	aggregate_name: text, 
    field: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.box_plot_agg (
	aggregate_name: text, 
    field: text,  
    compression: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.box_plot_agg (
	aggregate_name: text, 
    field: text,  
    missing: bigint
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.box_plot_agg (
	aggregate_name: text, 
    field: text,  
    compression: text,
    missing: bigint
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-boxplot-aggregation.html
A boxplot metrics aggregation that computes boxplot of numeric values extracted from the aggregated documents.</p>
<hr />
<h3 id="geo_centroid_agg"><a class="header" href="#geo_centroid_agg"><code>geo_centroid_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.geo_centroid_agg (
	aggregate_name: text, 
    field: text,
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-geocentroid-aggregation.html
A metric aggregation that computes the weighted centroid from all coordinate values for geo fields.</p>
<hr />
<h3 id="median_absolute_deviation_agg"><a class="header" href="#median_absolute_deviation_agg"><code>median_absolute_deviation_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.median_absolute_deviation_agg (
	aggregate_name: text, 
    field: text,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.median_absolute_deviation_agg (
	aggregate_name: text, 
    field: text,  
    compression: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.median_absolute_deviation_agg (
	aggregate_name: text, 
    field: text,  
    missing: bigint
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.median_absolute_deviation_agg (
	aggregate_name: text, 
    field: text,  
    compression: text,
    missing: bigint
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-median-absolute-deviation-aggregation.html
This single-value aggregation approximates the median absolute deviation of its search results.</p>
<hr />
<h3 id="percentiles_agg"><a class="header" href="#percentiles_agg"><code>percentiles_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.percentiles_agg (
	aggregate_name: text, 
    field: text,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.percentiles_agg (
	aggregate_name: text, 
    field: text,
    percents: double precision[],
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.percentiles_agg (
	aggregate_name: text, 
    field: text,
    missing: bigint
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.percentiles_agg (
	aggregate_name: text, 
    field: text,
    keyed: boolean
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.percentiles_agg (
	aggregate_name: text, 
    field: text,
    percents: double precision[],
    keyed: boolean
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.percentiles_agg (
	aggregate_name: text, 
    field: text,
    percents: double precision[],
    missing: bigint
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.percentiles_agg (
	aggregate_name: text, 
    field: text,
    keyed: boolean,
    missing: bigint
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.percentiles_agg (
	aggregate_name: text, 
    field: text,
    percents: double precision[],
    keyed: boolean,
    missing: bigint
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-percentile-aggregation.html#search-aggregations-metrics-percentile-aggregation
A multi-value metrics aggregation that calculates one or more percentiles over numeric values extracted from the aggregated documents.
By default, the percentile metric will generate a range of percentiles: [ 1, 5, 25, 50, 75, 95, 99 ].</p>
<hr />
<h3 id="string_stats_agg"><a class="header" href="#string_stats_agg"><code>string_stats_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.string_stats_agg (
	aggregate_name: text, 
    field: text,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.string_stats_agg (
	aggregate_name: text, 
    field: text,
    show_distribution: boolean
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.string_stats_agg (
	aggregate_name: text, 
    field: text,
    missing: bigint
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.string_stats_agg (
	aggregate_name: text, 
    field: text,
    show_distribution: boolean,
    missing: bigint
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-string-stats-aggregation.html
A multi-value metrics aggregation that computes statistics over string values extracted from the aggregated documents.</p>
<hr />
<h3 id="weighted_avg_agg"><a class="header" href="#weighted_avg_agg"><code>weighted_avg_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.weighted_avg_agg (
	aggregate_name: text,
    field_value: text,
    field_weight: text
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.weighted_avg_agg (
	aggregate_name: text, 
    field_value: text,
    field_weight: text,
    weight_missing: bigint,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.weighted_avg_agg (
	aggregate_name: text, 
    field_value: text,
    field_weight: text,
    value_missing: bigint,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.weighted_avg_agg (
	aggregate_name: text, 
    field_value: text,
    field_weight: text,
    value_missing: bigint,
    weight_missing: bigint,
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-weight-avg-aggregation.html
A single-value metrics aggregation that computes the weighted average of numeric values that are extracted from the aggregated documents.</p>
<hr />
<h3 id="top_metrics_agg"><a class="header" href="#top_metrics_agg"><code>top_metrics_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.top_metrics_agg (
	aggregate_name: text,
    metric_field: text,
    sort_type: SortDescriptor
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.top_metrics_agg (
	aggregate_name: text, 
    metric_field: text,
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.top_metrics_agg (
	aggregate_name: text, 
    metric_field: text,
    sort_type_lat_long: double precision[]
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-top-metrics.html
The top_metrics aggregation selects metrics from the document with the largest or smallest “sort” value.</p>
<hr />
<h3 id="t_test_agg"><a class="header" href="#t_test_agg"><code>t_test_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.t_test_agg (
	aggregate_name: text,
    field: text[],
    t_type: TTestType
)
RETURNS jsonb
</code></pre>
<pre><code class="language-sql">FUNCTION zdb.t_test_agg (
	aggregate_name: text, 
    field: text[],
    queries: ZDBQuery[],
    t_type: TTestType
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-metrics-ttest-aggregation.html
A t_test metrics aggregation that performs a statistical hypothesis test in which the test statistic follows a Student’s t-distribution under the null hypothesis on numeric values extracted from the aggregated documents or generated by provided scripts. 
In practice, this will tell you if the difference between two population means are statistically significant and did not occur by chance alone.</p>
<hr />
<h2 id="date_histogram_agg"><a class="header" href="#date_histogram_agg"><code>date_histogram_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.date_histogram_agg (
    aggregate_name: text, 
    field: text, 
    calendar_interval: calendarinterval DEFAULT NULL::calendarinterval, 
    fixed_interval: text DEFAULT NULL::text, 
    time_zone: text DEFAULT '+00:00'::text, 
    format: text DEFAULT 'yyyy-MM-dd'::text,
    children: jsonb[] DEFAULT NULL::jsonb[]
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-datehistogram-aggregation.html
This multi-bucket aggregation is similar to the normal histogram, but it can only be used with date or date range values.</p>
<hr />
<h3 id="histogram_agg"><a class="header" href="#histogram_agg"><code>histogram_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.histogram_agg (
    aggregate_name: text,
    field: text, 
    &quot;interval&quot;: bigint, 
    min_count bigint DEFAULT NULL::bigint, 
    keyed boolean DEFAULT NULL::boolean, 
    missing bigint DEFAULT NULL::bigint, 
    children: jsonb[] DEFAULT NULL::jsonb[]
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-histogram-aggregation.html
A multi-bucket values source based aggregation that can be applied on numeric values or numeric range values extracted from the documents.</p>
<hr />
<h3 id="filter_agg"><a class="header" href="#filter_agg"><code>filter_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.filter_agg (
    index: regclass,
    aggregate_name: text,
    field: text,    
    filter: zdbquery, 
    children: jsonb[] DEFAULT NULL::jsonb[]
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-filter-aggregation.htmlA multi-bucket values source based aggregation that can be applied on numeric values or numeric range values extracted from the documents.
Defines a single bucket of all the documents in the current document set context that match a specified filter.</p>
<hr />
<h3 id="filters_agg"><a class="header" href="#filters_agg"><code>filters_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.filters_agg (
    index: regclass, 
    aggregate_name: text, 
    labels: text[], 
    filters: zdbquery[]
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-filters-aggregation.html
Defines a multi bucket aggregation where each bucket is associated with a filter.</p>
<hr />
<h3 id="range_agg"><a class="header" href="#range_agg"><code>range_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.filters_agg (
    aggregate_name: text, 
    field: text, 
    ranges: json[], 
    children: jsonb[] DEFAULT NULL::jsonb[]
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-range-aggregation.html
A multi-bucket value source based aggregation that enables the user to define a set of ranges - each representing a bucket.</p>
<hr />
<h3 id="terms_agg"><a class="header" href="#terms_agg"><code>terms_agg</code></a></h3>
<pre><code class="language-sql">FUNCTION zdb.terms_agg (
    aggregate_name: text, 
    field: text, 
    size_limit: integer, 
    order_by: termsorderby 
    children: jsonb[] DEFAULT NULL::jsonb[]
)
RETURNS jsonb
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-terms-aggregation.html
A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value.</p>
<hr />
<h2 id="adjacency_matrix_agg"><a class="header" href="#adjacency_matrix_agg"><code>adjacency_matrix_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix_agg (
    index: regclass, 
    aggregate_name: text,
    labels: text[], 
    filters: zdbquery[]
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-adjacency-matrix-aggregation.html#search-aggregations-bucket-adjacency-matrix-aggregation
A bucket aggregation returning a form of adjacency matrix. The request provides a collection of named filter expressions, similar to the filters aggregation request. </p>
<hr />
<h2 id="adjacency_matrix_agg-1"><a class="header" href="#adjacency_matrix_agg-1"><code>adjacency_matrix_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.auto_date_histogram_agg (
    aggregate_name: text,
    buckets: bigint, 
    format: text DEFAULT NULL::text,
    minimum_interval: Interval DEFAULT NULL::Interval,
    missing: text DEFAULT NULL::text,
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-autodatehistogram-aggregation.html
A multi-bucket aggregation similar to the Date histogram except instead of providing an interval to use as the width of each bucket, a target number of buckets is provided indicating the number of buckets needed and the interval of the buckets is automatically chosen to best achieve that target.</p>
<hr />
<h2 id="children_agg"><a class="header" href="#children_agg"><code>children_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.children_agg (
    aggregate_name: text,
    join_type: text, 
    children: jsonb[] DEFAULT NULL::jsonb[],
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-children-aggregation.html
A special single bucket aggregation that selects child documents that have the specified type, as defined in a join field.</p>
<hr />
<h2 id="sampler_agg"><a class="header" href="#sampler_agg"><code>sampler_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.sampler_agg (
    aggregate_name: text,
    shard_size: bigint, 
    children: jsonb[] DEFAULT NULL::jsonb[],
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-sampler-aggregation.html
A filtering aggregation used to limit any sub aggregations’ processing to a sample of the top-scoring documents.</p>
<hr />
<h2 id="diversified_sampler_agg"><a class="header" href="#diversified_sampler_agg"><code>diversified_sampler_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.diversified_sampler_agg (
    aggregate_name: text,
    shard_size: bigint,
    max_docs_per_value bigint DEFAULT NULL::bigint,
    execution_hint zdb.executionhint DEFAULT NULL::zdb.executionhint,
    children: jsonb[] DEFAULT NULL::jsonb[],
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-diversified-sampler-aggregation.html#_max_docs_per_value
Like the sampler aggregation this is a filtering aggregation used to limit any sub aggregations’ processing to a sample of the top-scoring documents. The diversified_sampler aggregation adds the ability to limit the number of matches that share a common value such as an “author”.</p>
<hr />
<h2 id="date_range_agg"><a class="header" href="#date_range_agg"><code>date_range_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.date_range_agg (
    aggregate_name: text,
    field: text,
    format: text,
    range json[], 
    missing text DEFAULT NULL::text, 
    keyed boolean DEFAULT NULL::boolean, 
    time_zone text DEFAULT NULL::text
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-daterange-aggregation.html
A range aggregation that is dedicated for date values. The main difference between this aggregation and the normal range aggregation is that the from and to values can be expressed in Date Math expressions, and it is also possible to specify a date format by which the from and to response fields will be returned.</p>
<hr />
<h2 id="geo_distance_agg"><a class="header" href="#geo_distance_agg"><code>geo_distance_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.geo_distance_agg (
    aggregate_name: text,
    field: bigint,
    origin text, 
    range json[],
    unit text DEFAULT NULL::text,
    keyed boolean DEFAULT NULL::boolean
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-geodistance-aggregation.html
A multi-bucket aggregation that works on geo_point fields and conceptually works very similar to the range aggregation.</p>
<hr />
<h2 id="geohash_grid_agg"><a class="header" href="#geohash_grid_agg"><code>geohash_grid_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.geohash_grid_agg (
    aggregate_name: text,
    field: bigint,
    &quot;precision&quot; smallint DEFAULT NULL::smallint,
    bounds text DEFAULT NULL::text,
    size bigint DEFAULT NULL::bigint,
    shard_size bigint DEFAULT NULL::bigint
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-geohashgrid-aggregation.html
A multi-bucket aggregation that works on geo_point fields and groups points into buckets that represent cells in a grid.</p>
<hr />
<h2 id="geotile_grid_agg"><a class="header" href="#geotile_grid_agg"><code>geotile_grid_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.geohash_grid_agg (
    aggregate_name: text,
    field: bigint,
    &quot;precision&quot; smallint DEFAULT NULL::smallint,
    bounds text DEFAULT NULL::text,
    size bigint DEFAULT NULL::bigint,
    shard_size bigint DEFAULT NULL::bigint
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-geotilegrid-aggregation.html
A multi-bucket aggregation that works on geo_point fields and groups points into buckets that represent cells in a grid. </p>
<hr />
<h2 id="global_agg"><a class="header" href="#global_agg"><code>global_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.global_agg (
    aggregate_name: text,
    children: jsonb[] DEFAULT NULL::jsonb[],
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-global-aggregation.html
Defines a single bucket of all the documents within the search execution context. This context is defined by the indices and the document types you’re searching on, but is not influenced by the search query itself.</p>
<hr />
<h2 id="ip_range_agg"><a class="header" href="#ip_range_agg"><code>ip_range_agg</code></a></h2>
<pre><code class="language-sql">FUNCTION zdb.ip_range_agg (
    aggregate_name: text,
    field: text,
    format: text,
    range json[], 
    missing text DEFAULT NULL::text, 
    keyed boolean DEFAULT NULL::boolean, 
    time_zone text DEFAULT NULL::text
)
RETURNS JsonB
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.9/search-aggregations-bucket-iprange-aggregation.html
Just like the dedicated date range aggregation, there is also a dedicated range aggregation for IP typed fields.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elasticsearch-_cat-api"><a class="header" href="#elasticsearch-_cat-api">ElasticSearch _cat API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postgis-support-in-zombodb"><a class="header" href="#postgis-support-in-zombodb">PostGIS Support in ZomboDB</a></h1>
<p>As of version <strong>10-1.0.5</strong> of ZomboDB, the <code>postgis</code> datatypes of <code>geometry</code> and <code>geography</code> are supported.</p>
<h5 id="postgis-requirement"><a class="header" href="#postgis-requirement">PostGIS Requirement</a></h5>
<p>PostGIS must already be installed prior to enabling PostGIS support in ZomboDB, but can also be installed after ZomboDB as noted below.</p>
<h5 id="installation-of-postgis-prior-to-zombodb"><a class="header" href="#installation-of-postgis-prior-to-zombodb">Installation of PostGIS prior to ZomboDB</a></h5>
<p>If the <code>postgis</code> extension is already enabled when you install the ZomboDB plugin using <code>CREATE EXTENSION zombodb</code>, then PostGIS support will automatically be enabled in ZomboDB. </p>
<h5 id="installation-of-postgis-after-zombodb"><a class="header" href="#installation-of-postgis-after-zombodb">Installation of PostGIS after ZomboDB</a></h5>
<p>If the PostGIS plugin is installed after ZomboDB, you will need to run <code>SELECT zdb.enable_postgis_support()</code> to enable support for <code>postgis</code> in ZomboDB. If ZomboDB was able to detect the PostGIS extension, the above will return <code>true</code>.  Otherwise it’ll return <code>false</code>.</p>
<h2 id="supported-coordinate-reference-systems"><a class="header" href="#supported-coordinate-reference-systems">Supported Coordinate Reference Systems</a></h2>
<p>While PostGIS supports a plethora of coordinate systems, the current release of ElasticSearch(<strong>6.6.1</strong>) only supports <a href="https://epsg.io/4326">WGS84</a>. To bridge the CRS gap between the two products, ZomboDB creates casts from <code>postgis</code>‘s <code>geography</code> and <code>geometry</code> types to <code>json</code> using <code>ST_AsGeoJSON()</code> and uses <code>ST_Transform()</code> to convert coordinates from their source CRS to <a href="https://epsg.io/4326">WGS84</a> for storage in the ElasticSearch index.</p>
<h2 id="examples-and-sample-data"><a class="header" href="#examples-and-sample-data">Examples and Sample Data</a></h2>
<p>There are two sample sets. </p>
<p><a href="https://github.com/zombodb/zombodb/files/2948109/sample_data_2278.zip">Sample dataset 1</a> is loaded in the <a href="https://epsg.io/2278">NAD83 / Texas South Central (ftUS)</a> CRS. </p>
<p><a href="https://github.com/zombodb/zombodb/files/3027737/sample_data_4326.zip">Sample dataset 2</a> is loaded in the <a href="https://epsg.io/4326">WGS84 - World Geodetic System 1984</a> CRS. </p>
<p>Both are a PG Dump from PostgreSQL 10.6 and PostGIS 2.4.</p>
<p>With this dataset loaded and PostGIS installed, make sure ZomboDB is installed with PostGIS support on as indicated above and create a ZomboDB index on the table by running:</p>
<pre><code class="language-sql">CREATE INDEX sample_data_2278_zombodb
          ON sample_data_2278
       USING zombodb ((sample_data_2278.*))
        WITH (alias=sample_data_2278);
</code></pre>
<p>and</p>
<pre><code class="language-sql">CREATE INDEX sample_data_4326_zombodb
          ON sample_data_4326
       USING zombodb ((sample_data_4326.*))
        WITH (alias=sample_data_4326);
</code></pre>
<h2 id="querying-the-sample-data"><a class="header" href="#querying-the-sample-data">Querying the Sample Data</a></h2>
<p>The most common ways of searching across spatialized data would be searching through points using polygons and bounding boxes whether they be drawn by the user or calculated from the extent of a map on the screen. To do this we will use the Geo Polygon and Bounding Box queries as shown below.</p>
<h4 id="geo-polygon-query"><a class="header" href="#geo-polygon-query">Geo Polygon Query</a></h4>
<p>The function used for this type of query is <code>dsl.geo_polygon</code>. It accepts arguments of <code>field</code> as a text value such as <code>point_to_query</code> and a VARIADIC of type <code>point</code>. A <code>point</code> is a string containing a comma separated <code>'lon, lat'</code> values. The query below would return all records whose geo_point field of PostGIS type <code>POINT</code> fell within the bounds of the polygon coordinates enumerated after it. As this is variadic and a polygon, it must contain at least three points and its ending latitude and longitude must be the same as its starting latitude and longitude.</p>
<pre><code class="language-sql">SELECT * 
FROM sample_data_4326
WHERE sample_data_4326 ==&gt; 
      dsl.geo_polygon('geo_point', 
      '-95.3757924220804,29.7530206054157', 
      '-95.3761162225586,29.753216394294', 
      '-95.3763406015772,29.7529338505327', 
      '-95.3766643966309,29.7531296379236', 
      '-95.3762156463589,29.7536947317361', 
      '-95.3758918431387,29.7534989430962', 
      '-95.3755680421945,29.7533031536912', 
      '-95.3757026673686,29.7531336250561', 
      '-95.3757924220804,29.7530206054157');
</code></pre>
<h4 id="bounding-box-query"><a class="header" href="#bounding-box-query">Bounding Box Query</a></h4>
<p>The function used for this type of query is <code>dsl.geo_bounding_box</code>. It accepts arguments of <code>field</code> as a text value such as <code>point_to_query</code> and a string <code>box</code>. The <code>box</code> string is comprised of 4 comma separated values representing <code>'min lon, min lat, max lon, max lat'</code>. The query below would return all records whose geo_point field of PostGIS type <code>POINT</code> fell within the bounds of the box defined by the four corrdinates.</p>
<pre><code class="language-sql">SELECT *
FROM sample_data_4326
WHERE sample_data_4326 ==&gt;
      dsl.geo_bounding_box('geo_point',
        '-95.3757924220804,29.7530206054157,-94.3757924220804,30.7530206054157');
</code></pre>
<h4 id="geoshape-queries"><a class="header" href="#geoshape-queries">GeoShape Queries</a></h4>
<p>Searching for points as noted above is a fairly straight-forward endeavor as you are merely searching for points inside a shape. To search for shapes such as polygons, linestrings in relation to shapes given by queries, ElasticSearch uses its GeoShape query. GeoShape queries support 4 spatial relation operators:</p>
<ul>
<li>INTERSECTS - (default) Return all documents whose geo_shape field intersects the query geometry.</li>
<li>DISJOINT - Return all documents whose geo_shape field has nothing in common with the query geometry.</li>
<li>WITHIN - Return all documents whose geo_shape field is within the query geometry.</li>
<li>CONTAINS - Return all documents whose geo_shape field contains the query geometry.</li>
</ul>
<p>In addition to the spatial relation operator, you will also supply a shape.</p>
<p>The two queries below show an envelope which is essentially a bounding box. However, our query will search for the column geom which is a POLYGON inside of our indexed table.</p>
<p>The first query will find all geom polygons that intersect with the envelope.</p>
<pre><code class="language-sql">SELECT *
FROM sample_data_4326
WHERE sample_data_4326 ==&gt;
      dsl.geo_shape('geom', '{&quot;type&quot;:&quot;envelope&quot;,&quot;coordinates&quot;:[[-95.3757924220804,29.7530206054157],[-95.3761162225586,29.753216394294]]}','INTERSECTS');
</code></pre>
<p>The second query will find all geom polygons that have no relation to the envelope int hat they are not intersecting, contained or within the envelope defined.</p>
<pre><code class="language-sql">SELECT *
FROM sample_data_4326
WHERE sample_data_4326 ==&gt;
      dsl.geo_shape('geom', '{&quot;type&quot;:&quot;envelope&quot;,&quot;coordinates&quot;:[[-95.3757924220804,29.7530206054157],[-95.3761162225586,29.753216394294]]}','DISJOINT');
</code></pre>
<h4 id="geoshape-with-st_asgeojson"><a class="header" href="#geoshape-with-st_asgeojson">GeoShape with ST_AsGeoJSON()</a></h4>
<p>You can combine ZomboDB query params with PostGIS functions. For example, from the <code>sample_data_4326</code> I can take the following GeoJSON value:</p>
<pre><code class="language-json">{&quot;type&quot;:&quot;MultiPolygon&quot;,&quot;coordinates&quot;:[[[[-95.3757924220804,29.7530206054157],[-95.3761162225586,29.753216394294],[-95.3763406015772,29.7529338505327],[-95.3766643966309,29.7531296379236],[-95.3762156463589,29.7536947317361],[-95.3758918431387,29.7534989430962],[-95.3755680421945,29.7533031536912],[-95.3757026673686,29.7531336250561],[-95.3757924220804,29.7530206054157]]]]}
</code></pre>
<p>With this value, I can create a query like the two in the <strong>GeoShape Queries</strong> section looking for geom points that intersect with this shape. However, this value was derived from the following query:</p>
<pre><code class="language-sql">SELECT st_asgeojson((SELECT geom FROM postgis.sample_data_4326 WHERE &quot;HCAD_NUM&quot; = '1292500000054'))::json;
</code></pre>
<p>I can run the same query using ST_AsGeoJSON() and shorten the query considerably like so:</p>
<pre><code class="language-sql">SELECT postgis.hcad_real_acct.*
FROM sample_data_4326
LEFT JOIN hcad_real_acct ON sample_data_4326.&quot;HCAD_NUM&quot; = realescout.hcad_real_acct.account
WHERE sample_data_4326 ==&gt;
      dsl.geo_shape('geom', st_asgeojson((SELECT geom FROM realescout.sample_data_4326 WHERE &quot;HCAD_NUM&quot; = '1292500000054'))::json,'INTERSECTS');
</code></pre>
<p>Above, we select the <code>geom</code> field encompassing it in the <code>ST_AsGeoJSON()</code> function and cast it as JSON to pass to the <code>dsl.geo_shape</code> query. This is nice for when you have predefined shapes in the database. For example, if I had an additional table called <code>zip_codes</code> with the geometry for all of the zip codes in the dataset stored there, I could do aggregation or selections of items in that zip code based on the shape.</p>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>All queries using ZDB’s spatialized index data need to be in CRS <code>WGS84 - EPSG:4326</code></li>
<li>During indexing, ZomboDB automatically converts <code>geography</code> and <code>geometry</code> to <code>json</code> (using <code>ST_AsGeoJSON</code>) and automatically uses <code>ST_Transform()</code> to transform them to CRS <code>4326</code></li>
<li>Queries using ZDB’s <code>dsl.geo_shape()</code> function need to be in CRS <code>4326</code></li>
<li>The <code>CONTAINS</code> shape relationship has been removed from Elasticsearch 6.6</li>
<li>Postgres’ <code>point</code> type is automatically mapped to the Elasticsearch <code>geo_point</code> type and can be queried with <code>dsl.geo_bounding_box()</code> and <code>dsl.geo_polygon()</code> queries</li>
<li>Columns defined as <code>geometry(Point, x)</code> or <code>geography(Point, x)</code> are automatically mapped to the Elasticsearch <code>geo_point</code> type and can be queried with <code>dsl.geo_bounding_box()</code> and <code>dsl.geo_polygon()</code> queries</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zombodb-installation-instructions"><a class="header" href="#zombodb-installation-instructions">ZomboDB Installation Instructions</a></h1>
<p>ZomboDB is a 100% native Postgres extension.  Additionally, ZomboDB is available as binary <code>.deb</code> and <code>.rpm</code> packages to
<a href="https://github.com/sponsors/eeeebbbbrrrr">sponsors</a> for popular Linux distributions.  As such, installation is fairly straightforward.</p>
<p>If you instead prefer to install ZomboDB from source, please read the [SOURCE-INSTALLATION.md] documentation.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Postgres 10.x, 11.x, 12.x, 13.x installed</li>
<li>A 64bit Intel Architecture</li>
</ul>
<h3 id="installation-on-centosrhel"><a class="header" href="#installation-on-centosrhel">Installation on CentOS/RHEL</a></h3>
<p>Download the proper <code>.rpm</code> package for your CentOS/RHEL distro from https://www.zombodb.com/${your_download_key}/, and simply run:</p>
<pre><code class="language-shell">$ rpm -Uvh zombodb_centos-8_pg10-3000.0.0-alpha1_1.x86_64.rpm
</code></pre>
<h3 id="installation-on-ubuntudebian"><a class="header" href="#installation-on-ubuntudebian">Installation on Ubuntu/Debian</a></h3>
<p>Download the proper <code>.deb</code> package for your Ubuntu/Debian distro from https://www.zombodb.com/${your_download_key}/, and simply run:</p>
<pre><code class="language-shel">$ dpkg -i zombodb_ubuntu-focal_pg10-3000.0.0-alpha1_amd64.deb
</code></pre>
<h3 id="installation-on-macos"><a class="header" href="#installation-on-macos">Installation on MacOS</a></h3>
<p>Please see the <a href="administration/SOURCE-INSTALLATION.html">source installation documentation</a>.</p>
<h2 id="postgresqlconf-settings-to-consider"><a class="header" href="#postgresqlconf-settings-to-consider"><code>postgresql.conf</code> Settings to Consider</a></h2>
<p>ZomboDB defaults to zero Elasticsearch index replicas.  If you’re installing for a production system you might consider setting <code>zdb.default_replicas</code> to a better value.</p>
<p>You might also consider setting <code>zdb.default_elasticsearch_url</code>.</p>
<p>Both of these values can be set per index, so they’re not strictly necessary to set in <code>postgresql.conf</code>.</p>
<p>Make sure to read about ZomboDB’s <a href="administration/CONFIGURATION-SETTINGS.html">configuration settings</a> and its <a href="administration/INDEX-MANAGEMENT.html#with--options">index options</a>.</p>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h2>
<p>Once installed, ensure Postgres is running (it does <strong>not</strong> need to be restarted).  Then you can create a test database and create the ZomboDB extension.</p>
<p>Note that a Postgres “superuser” must issue the <code>CREATE EXTENSION zombodb;</code> statement.</p>
<pre><code class="language-shell">$ createdb zdb_test
$ psql zdb_test
psql (10.1)
Type &quot;help&quot; for help.

zdb_test=# CREATE EXTENSION zombodb;
CREATE EXTENSION
</code></pre>
<h2 id="upgrading-zombodb"><a class="header" href="#upgrading-zombodb">Upgrading ZomboDB</a></h2>
<p>When a new ZomboDB version is released and you need to upgrade you should first ensure you have exclusive access to all databases that use ZomboDB -- in other words, make sure there are no active connections.</p>
<p>Once confirmed, you can simply install the new <code>.deb</code> or <code>.rpm</code> package then for each database that has the ZomboDB extension installed, simply run:</p>
<pre><code class="language-sql">ALTER EXTENSION zombodb UPDATE;
</code></pre>
<p>There will be no need to restart Postgres.</p>
<p>While it is unlikely, should a ZomboDB version upgrade require that indices be <code>REINDEX</code>ed, that will be noted in the release notes for that version.</p>
<h2 id="elasticsearch-considerations"><a class="header" href="#elasticsearch-considerations">Elasticsearch Considerations</a></h2>
<p>Keep in mind that ZomboDB requires Elasticsearch 7.x.</p>
<p>Detailed advice about managing and configuring Elasticsearch clusters is outside the scope of this document, however commercial support can be purchased from ZomboDB, LLC.  Feel free to contact us via https://www.zombodb.com/services.</p>
<p>That said, ZomboDB has been tested against various cloud-hosted Elasticsearch providers such as Bonsai (https://bonsai.io) and Elastic’s own <a href="https://www.elastic.co/cloud/elasticsearch-service">Elasticsearch Service</a>.  ZomboDB can also be used with your own internally-managed Elasticsearch clusters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zombodb-source-installation-instructions"><a class="header" href="#zombodb-source-installation-instructions">ZomboDB Source Installation Instructions</a></h1>
<blockquote>
<p>Note: If you’re a <a href="https://github.com/sponsors/eeeebbbbrrrr">sponsor</a>, you might want to also read the <a href="administration//administration/binary-installation.html">binary installation</a> documentation.</p>
</blockquote>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<ul>
<li>
<p>Postgres 10.x, 11.x, 12.x, or 13.x installed. If you have installed it from a package manager, ensure that you have also included the relevant “<code>-server</code>“ package.</p>
</li>
<li>
<p>A toolchain capable of building Postgres:</p>
<p>For Ubuntu, this is enough:</p>
<pre><code>apt install bison flex zlib1g zlib1g-dev \
    pkg-config make libssl-dev libreadline-dev
</code></pre>
</li>
<li>
<p>The Rust toolchain</p>
</li>
<li>
<p><code>cargo install cargo-pgx</code></p>
</li>
<li>
<p>A 64bit Intel Architecture</p>
</li>
</ul>
<h2 id="building-from-sources"><a class="header" href="#building-from-sources">Building from sources</a></h2>
<p>First off, and you’ll only need to do this once, you need to initialize <code>cargo-pgx</code>, and
you’ll want to tell it the path to the version of Postgres on your computer.</p>
<p>If that version of Postgres is pg12, and assuming its <code>pg_config</code> tool is on your <code>$PATH</code>, 
this will likely work:</p>
<pre><code class="language-shell script">$ cargo pgx init --pg12=`which pg_config`
</code></pre>
<p>Next, clone this repo, change into the checkout directory and simply run:</p>
<pre><code class="language-shell script">$ cargo pgx install --release
</code></pre>
<p>This will compile ZomboDB <strong>and</strong> install it into the Postgres installation described by <code>pg_config</code>.  The user that
runs the above command will need write permissions to the Postgres <code>$PG_INSTALL_PATH/lib/postgresql/</code> and <code>$PG_INSTALL_PATH/share/postgresql/extension/</code> directories.</p>
<h2 id="updating-zombodb-to-a-new-version"><a class="header" href="#updating-zombodb-to-a-new-version">Updating ZomboDB to a new version</a></h2>
<p>Updating ZomboDB from sources will simply require a <code>git pull</code>, another <code>make clean install</code> and running  <code>ALTER EXTENSION zombodb UPDATE;</code> in all databases that use the ZomboDB extension.</p>
<h2 id="building-binary-artifacts-with-docker"><a class="header" href="#building-binary-artifacts-with-docker">Building binary artifacts with Docker</a></h2>
<p>If you have a proper Docker installation you can simply run:</p>
<pre><code class="language-shell script">$ cd docker-build-system
$ cargo run &lt;branch-name&gt; [&lt;docker-image-name&gt; &lt;pg major version&gt;]
</code></pre>
<p>Likely for the <code>&lt;branch-name&gt;</code> argument you’ll want to specify <code>master</code>, unless perhaps you’re working on a custom branch.</p>
<p>If you’re only targeting one Linux distro and Postgres version, you’ll want to specify all three arguments.</p>
<p>This process will take a long time (potentially hours depending on your download speeds), but it will build ZomboDB for all supported Linux distro and Postgres version permutations.</p>
<p>You can set an environment variable named <code>CPUS</code> to limit the number of CPUs the build process will use, but the default is however many your computer has.</p>
<p>The final binary artifacts will be placed in the <code>./target/zdb-build/artifacts/</code> directory.</p>
<p>No logs are created, but in the event of Docker/compilation errors, the entire output of the
thing that failed is printed to stdout.</p>
<p>Once binary artifacts are build, follow the instructions in <a href="administration//administration/binary-installation.html">binary installation</a> to install the proper artifact for your environment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-settings"><a class="header" href="#configuration-settings">Configuration Settings</a></h1>
<p>ZomboDB provides a number of configuration settings that affect how it operates.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<!-- Settings to change within `postgresql.conf`: -->
<table>
  <tr>
    <th><code>postgresql.conf</code> key</th>
    <th>Data type</th>
    <th>Default</th>
    <th>Notes</th>
  </tr>
<tr>
    <td><code>zdb.default_elasticsearch_url</code></td>
    <td>String</td>
    <td></td>
    <td>Requires restart/reload</td>
  </tr>
<tr>
    <td><code>zdb.default_replicas</code></td>
    <td>Integer</td>
    <td>0</td>
    <td>Requires restart/reload</td>
  </tr>
<tr>
    <td><code>zdb.default_row_estimate</code></td>
    <td>Integer</td>
    <td>2500</td>
    <td>Valid range: <code>1</code> - <code>2147483647</code></td>
  </tr>
<tr>
    <td><code>zdb.ignore_visibility</code></td>
    <td>Boolean</td>
    <td>false</td>
    <td>Valid values: <code>true</code>  | <code>false</code></td>
  </tr>
<tr>
    <td><code>zdb.log_level</code></td>
    <td>Enum</td>
    <td><code>DEBUG1</code></td>
    <td>Valid values: <code>DEBUG5</code> | <code>DEBUG4</code> | <code>DEBUG3</code> | <code>DEBUG2</code> | <code>DEBUG1</code> | <code>INFO</code> | <code>NOTICE</code>  | <code>WARNING</code> | <code>LOG</code></td>
  </tr>
<tr>
    <td><code>zdb.enable_search_accelerator</code></td>
    <td>Boolean</td>
    <td>false</td>
    <td>Valid values: <code>true</code>  | <code>false</code></td>
  </tr>
</table>
<h2 id="postgresqlconf-only-settings"><a class="header" href="#postgresqlconf-only-settings"><code>postgresql.conf</code>-only settings</a></h2>
<p>The below settings can only be set in <code>postgresql.conf</code> and require a Postgres configuration reload (or server restart) to be changed.</p>
<h4 id="zdbdefault_elasticsearch_url"><a class="header" href="#zdbdefault_elasticsearch_url"><code>zdb.default_elasticsearch_url</code></a></h4>
<pre><code>Type: string
Default: null
</code></pre>
<p>Defines the default URL for your Elasticsearch cluster so you can elite setting it on every index during <code>CREATE INDEX</code>.  The value used must end with a forward slash (<code>/</code>).</p>
<p>Example:  <code>zdb.default_elasticsearch_url = 'http://es.cluster.ip:9200/'</code></p>
<h4 id="zdbdefault_replicas"><a class="header" href="#zdbdefault_replicas"><code>zdb.default_replicas</code></a></h4>
<pre><code>Type: integer
Default: 0
</code></pre>
<p>Defines the number of replicas all new indices should have.  Changing this value does not propagate to existing indices.</p>
<h2 id="session-level-guc-settings"><a class="header" href="#session-level-guc-settings">Session-level “GUC” settings</a></h2>
<p>The below settings may be set in <code>postgresql.conf</code>, but they can also be changed per session/transaction using Postgres <code>SET key TO value</code> command;</p>
<h4 id="zdbdefault_row_estimate"><a class="header" href="#zdbdefault_row_estimate"><code>zdb.default_row_estimate</code></a></h4>
<pre><code>Type: integer
Default: 2500
Range: [-1, INT_MAX]
</code></pre>
<p>ZomboDB needs to provide Postgres with an estimate of the number of rows Elasticsearch will return for any given query.  2500 is a sensible default estimate that generally convinces Postgres to use an IndexScan plan.  Setting this to <code>-1</code> will cause ZomboDB to execute an Elasticsearch <code>_count</code> request for every query to return the exact number.</p>
<h4 id="zdbignore_visibility"><a class="header" href="#zdbignore_visibility"><code>zdb.ignore_visibility</code></a></h4>
<pre><code>Type: boolean
Default: false
</code></pre>
<p>ZomboDB applies MVCC visibility rules to all queries and aggregate functions.  Setting this to true instructs ZomboDB to <strong>not</strong> do that, which means aggregate functions (such as <code>zdb.terms()</code>) will see dead rows, aborted rows, and in-flight rows.  Generally, this should only be used for debugging.</p>
<h4 id="zdblog_level"><a class="header" href="#zdblog_level"><code>zdb.log_level</code></a></h4>
<pre><code>Type: enum
Default: DEBUG1
Possible Values: DEBUG5, DEBUG4, DEBUG3, DEBUG2, DEBUG1, INFO, NOTICE, WARNING, LOG
</code></pre>
<p>The Postgres log level ZomboDB sends all of its log messages.</p>
<h4 id="zdbenable_search_accelerator"><a class="header" href="#zdbenable_search_accelerator"><code>zdb.enable_search_accelerator</code></a></h4>
<pre><code>Type: boolean
Default: false
</code></pre>
<p>Indicates if you have the ZomboDB Search Accelerator installed on your backing Elasticsearch
cluster.</p>
<p>If you do, ZomboDB is able to highly optimize certain queries, especially those that perform
<a href="administration/./usage/cross-index-joins.html">cross-index joins</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-management"><a class="header" href="#index-management">Index Management</a></h1>
<p>ZomboDB manages indices through standard Postgres DDL commands such as <code>CREATE INDEX</code>, <code>ALTER INDEX</code>, and <code>DROP INDEX</code>.  ZomboDB also exposes a number of index-level options that can be set to affect things like number of shards, replicas, etc.</p>
<!-- etc shouldn't appear in documentation, particularly within an introductory paragraph -->
<h2 id="create-index"><a class="header" href="#create-index">CREATE INDEX</a></h2>
<p>The form for creating ZomboDB indices is:</p>
<pre><code class="language-sql">CREATE INDEX index_name 
          ON table_name 
       USING zombodb ((table_name.*)) 
        WITH (...) -- See below 
</code></pre>
<p>(where the options for <a href="administration/index-management.html#with--options"><code>WITH</code> are detailed below</a>)</p>
<p>ZomboDB generates a UUID to use as the backing Elasticsearch index name, but also assigns an alias in the form of <code>database_name.schema_name.table_name.index_name-index_oid</code>.  “index_oid” is the Postgres catalog id for the index from the “pg_class” system catalog table.</p>
<p>The alias is meant to be a human-readable name that you can use with external tools like Kibana or even <code>curl</code>.</p>
<h2 id="alter-index"><a class="header" href="#alter-index">ALTER INDEX</a></h2>
<p>The various Index Options supported by ZomboDB can be changed using Postgres <code>ALTER INDEX</code> statement.  They can be changed to new values or reset to their defaults.</p>
<p>For example:</p>
<pre><code class="language-sql">ALTER INDEX index_name SET (replicas=2)
</code></pre>
<h2 id="drop-indextableschemadatabase"><a class="header" href="#drop-indextableschemadatabase">DROP INDEX/TABLE/SCHEMA/DATABASE</a></h2>
<p>When you drop a Postgres object that contains a ZomboDB index, the corresponding Elasticsearch is also deleted.</p>
<p><code>DROP</code> statements are transaction safe and don’t delete the backing Elasticsearch index until the controlling transaction commits.</p>
<p>Note that <code>DROP DATABASE</code> can’t delete its corresponding Elasticsearch indices as there’s no way for ZomboDB to receive a notification that a database is being dropped.</p>
<h2 id="with--options"><a class="header" href="#with--options">WITH (...) Options</a></h2>
<p>All of the below options can be set during <code>CREATE INDEX</code> and most of them can be changed with <code>ALTER INDEX</code>.  Those that cannot be altered are noted.</p>
<h3 id="summary-2"><a class="header" href="#summary-2">Summary</a></h3>
<table>
  <tr>
    <th>Option Name</th>
    <th>Data type</th>
    <th>Default</th>
    <th>Valid range or <code>postgresql.conf</code> key</th>
  </tr>
<tr>
    <td><code>url</code></td>
    <td>String</td>
    <td></td>
    <td><code>zdb.default_elasticsearch_url</code>.</td>
  </tr>
<tr>
    <td><code>shards</code></td>
    <td>Integer</td>
    <td><code>5</code></td>
    <td><code>1</code> - <code>32768</code></td>
  </tr>
<tr>
    <td><code>replicas</code></td>
    <td>Integer</td>
    <td><code>0</code></td>
    <td><code>zdb.default_replicas</code>.</td>
  </tr>
<tr>
    <td><code>alias</code></td>
    <td>String</td>
    <td><code>"database.schema.table.index-index_oid"</code></td>
    <td></td>
  </tr>
<tr>
    <td><code>refresh_interval</code></td>
    <td>String</td>
    <td><code>"-1"</code></td>
    <td></td>
  </tr>
<tr>
    <td><code>type_name</code></td>
    <td>String</td>
    <td><code>"_doc"</code></td>
    <td></td>
  </tr>
<tr>
    <td><code>translog_durability</code></td>
    <td>String</td>
    <td><code>"request"</code></td>
    <td><code>"request"</code> | <code>"async"</code> </td>
  </tr>
<tr>
    <td><code>max_result_window</code></td>
    <td>Integer</td>
    <td><code>10000</code></td>
    <td><code>1</code> - <code>2147483647</code></td>
  </tr>
<tr>
    <td><code>nested_fields_limit</code></td>
    <td>Integer</td>
    <td><code>1000</code></td>
    <td><code>1</code> - <code>2147483647</code></td>
  </tr>
<tr>
    <td><code>total_fields_limit</code></td>
    <td>Integer</td>
    <td><code>1000</code></td>
    <td><code>1</code> - <code>2147483647</code></td>
  </tr>
<tr>
    <td><code>max_terms_count</code></td>
    <td>Integer</td>
    <td><code>65535</code> (<code>2^16 - 1</code>)</td>
    <td><code>1</code> - <code>2147483647</code></td>
  </tr>
<tr>
    <td><code>bulk_concurrency</code></td>
    <td>Integer</td>
    <td><code>12</code></td>
    <td><code>1</code> - <code>2147483647</code></td>
  </tr>
<tr>
    <td><code>batch_size</code></td>
    <td>Integer</td>
    <td><code>8388608</code> (<code>8 * 2^20</code>)</td>
    <td></td>
  </tr>
<tr>
    <td><code>compression_level</code></td>
    <td>Integer</td>
    <td><code>1</code></td>
    <td><code>1</code> - <code>2147483647</code></td>
  </tr>
<tr>
    <td><code>nested_object_numeric_detection</code></td>
    <td>Boolean</td>
    <td><code>true</code></td>
    <td></td>
  </tr>
<tr>
    <td><code>nested_object_date_detection</code></td>
    <td>Boolean</td>
    <td><code>false</code></td>
    <td></td>
  </tr>
<tr>
    <td><code>nested_object_text_mapping</code></td>
    <td>String (containing valid JSON)</td>
    <td><pre><code>{
  "type": "keyword",
  "ignore_above": 10922,
  "normalizer": "lowercase",
  "copy_to": "zdb_all"
}</code></pre></td>
    <td></td>
  </tr>
<tr>
    <td><code>options</code></td>
    <td>Comma delimited strings</td>
    <td></td>
    <td></td>
  </tr>
<tr>
    <td><code>field_lists</code></td>
    <td>Comma delimited strings</td>
    <td></td>
    <td></td>
  </tr>
</table>
<h3 id="required-options"><a class="header" href="#required-options">Required Options</a></h3>
<h4 id="url"><a class="header" href="#url"><code>url</code></a></h4>
<pre><code>Type: string
Default: zdb.default_elasticsearch_url
</code></pre>
<p>The Elasticsearch Cluster URL for the index.  This option is required, but can be omitted if the <code>postgresql.conf</code> setting <code>zdb.default_elasticsearch_url</code> is set.  This option can be changed with <code>ALTER INDEX</code>, but you must be a Postgres superuser to do so.</p>
<p>The value must end with a forward slash (<code>/</code>).</p>
<h3 id="elasticsearch-options"><a class="header" href="#elasticsearch-options">Elasticsearch Options</a></h3>
<h4 id="shards"><a class="header" href="#shards"><code>shards</code></a></h4>
<pre><code>Type: integer
Default: 5
Range: [1, 32768]
</code></pre>
<p>The number of shards Elasticsearch should create for the index.  This option can be changed with <code>ALTER INDEX</code> but you must issue a <code>REINDEX INDEX</code> before the change will take effect.</p>
<h4 id="replicas"><a class="header" href="#replicas"><code>replicas</code></a></h4>
<pre><code>Type: integer
Default: zdb.default_replicas
</code></pre>
<p>This controls the number of Elasticsearch index replicas.  The default is the value of the <code>zdb.default_replicas</code> GUC, which itself defaults to zero.  Changes to this value via <code>ALTER INDEX</code> take effect immediately.</p>
<h4 id="alias"><a class="header" href="#alias"><code>alias</code></a></h4>
<pre><code>Type: string
Default: &quot;database.schema.table.index-index_oid&quot;
</code></pre>
<p>You can set an alias to use to identify an index from external tools.  This is for user convenience only.  Changes via <code>ALTER INDEX</code> take effect immediately.</p>
<p>Normal SELECT statements are executed in Elasticsearch directly against the named index.  Aggregate functions such as <code>zdb.count()</code> and <code>zdb.terms()</code> use the alias, however.</p>
<p>In cases where you’re using ZomboDB indices on inherited tables or on partition tables, it is suggested you assigned the <strong>same</strong> alias name to all tables in the hierarchy so that aggregate functions will run across all the tables involved.</p>
<h4 id="refresh_interval"><a class="header" href="#refresh_interval"><code>refresh_interval</code></a></h4>
<pre><code>Type: string
Default: &quot;-1&quot;
</code></pre>
<p>This option specifies how frequently Elasticsearch should refresh the index to make changes visible to searches.  By default, this is set to <code>-1</code> because ZomboDB wants to control refreshes itself so that it can maintain proper MVCC visibility results.  It is not recommented that you change this setting unless you’re okay with search results being inconsistent with what Postgres expects.  Changes via <code>ALTER INDEX</code> take effect immediately.</p>
<h4 id="type_name"><a class="header" href="#type_name"><code>type_name</code></a></h4>
<pre><code>Type: string
Default: &quot;_doc&quot;
</code></pre>
<p>This is the Elasticsearch index type into which documents are mapped.  The default, “_doc” is compatible with Elasticsearch v5 and v6.  There should be no need to change this setting.  Note that it can only be set during <code>CREATE INDEX</code>.</p>
<h4 id="translog_durability"><a class="header" href="#translog_durability"><code>translog_durability</code></a></h4>
<pre><code>Type: string
Default: &quot;request&quot;
Valid values: &quot;request&quot;, &quot;async&quot;
</code></pre>
<p>Whether or not to fsync and commit the translog after every index, delete, update, or bulk request. This setting accepts 
the following parameters:</p>
<ul>
<li>request:  (default) fsync and commit after every request. In the event of hardware failure, all acknowledged writes will already have been committed to disk.</li>
<li>async:  fsync and commit in the background every sync_interval. In the event of a failure, all acknowledged writes since the last automatic commit will be discarded.</li>
</ul>
<p>See: https://www.elastic.co/guide/en/elasticsearch/reference/7.x/index-modules-translog.html#_translog_settings</p>
<h4 id="max_result_window"><a class="header" href="#max_result_window"><code>max_result_window</code></a></h4>
<pre><code>Tyoe: integer
Default: 10000
Range: [1, INT_32_MAX]
</code></pre>
<p>The maximum number of docs ZomboDB will retrieve from Elasticsearch in a single scroll request.</p>
<p>See: https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-max-result-window</p>
<h4 id="nested_fields_limit"><a class="header" href="#nested_fields_limit"><code>nested_fields_limit</code></a></h4>
<pre><code>Type: integer
Default: 1000
Range: [1, INT_32_MAX]
</code></pre>
<p>The maximum number of distinct nested mappings in an index. The nested type should only be used 
in special cases, when arrays of objects need to be queried independently of each other. To 
safeguard against poorly designed mappings, this setting limits the number of unique nested 
types per index.</p>
<p>See: https://www.elastic.co/guide/en/elasticsearch/reference/master/mapping-settings-limit.html</p>
<h4 id="total_fields_limit"><a class="header" href="#total_fields_limit"><code>total_fields_limit</code></a></h4>
<pre><code>Type: integer
Default: 1000
Range: [1, INT_32_MAX]
</code></pre>
<p>The maximum number of fields in an index. Field and object mappings, as well as field aliases 
count towards this limit. The default value is 1000.</p>
<p>See: https://www.elastic.co/guide/en/elasticsearch/reference/master/mapping-settings-limit.html</p>
<h4 id="max_terms_count"><a class="header" href="#max_terms_count"><code>max_terms_count</code></a></h4>
<pre><code>Type: integer
Default: 65535
Range: [1, INT_32_MAX]
</code></pre>
<p>The maximum number of terms that can be used in Terms Query.</p>
<p>Increasing this limit might be necessary for performing large <a href="administration/CROSS-INDEX-JOINS.html">cross-index joins</a> 
when the ZomboDB Search Accelerator is not installed.</p>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-max-terms-count</p>
<h3 id="network-options"><a class="header" href="#network-options">Network Options</a></h3>
<h4 id="bulk_concurrency"><a class="header" href="#bulk_concurrency"><code>bulk_concurrency</code></a></h4>
<pre><code>Type: integer
Default: 12
Range: [1, 1024]
</code></pre>
<p>When synchronizing changes to Elasticsearch, ZomboDB does this by multiplexing HTTP(S) requests using libcurl.  This setting controls the number of concurrent requests.  ZomboDB also logs how many active concurrent requests it’s managing during writes to Elasticsearch.  You can use that value to ensure you’re not overloading your Elasticsearch cluster.  Changes via <code>ALTER INDEX</code> take effect immediately.</p>
<h4 id="batch_size"><a class="header" href="#batch_size"><code>batch_size</code></a></h4>
<pre><code>Type: integer (in bytes)
Default: 8388608
Range: [1024, (INT_MAX/2)-1]
</code></pre>
<p>When synchronizing changes to Elasticsearch, ZomboDB does this by batching them together into chunks of <code>batch_size</code>.  The default of 8mb is a sensible default, but can be changed in conjunction with <code>bulk_concurrency</code> to improve overall write performance.  Changes via <code>ALTER INDEX</code> take effect immediately.</p>
<h4 id="compression_level"><a class="header" href="#compression_level"><code>compression_level</code></a></h4>
<pre><code>Type: integer
Default: 1
Range: [0, 9]
</code></pre>
<p>Sets the HTTP(s) transport (and request body) deflate compression level.  Over slow networks, it may make sense to set this to a higher value.  Setting to zero turns off all compression.  Changes via <code>ALTER INDEX</code> take effect immediately.</p>
<h3 id="nested-object-mapping-options"><a class="header" href="#nested-object-mapping-options">Nested Object Mapping Options</a></h3>
<h4 id="nested_object_date_detection"><a class="header" href="#nested_object_date_detection"><code>nested_object_date_detection</code></a></h4>
<pre><code>Type: bool
Default: false
</code></pre>
<p>If <code>nested_object_date_detection</code> is enabled (default is false), then new string fields 
in nested objects (fields of type ‘json’ or ‘jsonb’) are checked to see whether their 
contents match any of the date patterns specified in dynamic_date_formats. If a match is 
found, a new date field is added with the corresponding format.</p>
<p>The default value for dynamic_date_formats is:</p>
<pre><code class="language-json"> [ &quot;strict_date_optional_time&quot;,&quot;yyyy/MM/dd HH:mm:ss Z||yyyy/MM/dd Z&quot;]
</code></pre>
<p>See:  https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-field-mapping.html#date-detection</p>
<h4 id="nested_object_numeric_detection"><a class="header" href="#nested_object_numeric_detection"><code>nested_object_numeric_detection</code></a></h4>
<pre><code>Type: bool
Default: true
</code></pre>
<p>While JSON has support for native floating point and integer data types, some 
applications or languages may sometimes render numbers as strings. Usually the correct 
solution is to map these fields explicitly, but numeric detection (which is disabled by 
default) can be enabled to do this automatically.</p>
<p>See:  https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-field-mapping.html#numeric-detection</p>
<h4 id="nested_object_text_mapping"><a class="header" href="#nested_object_text_mapping"><code>nested_object_text_mapping</code></a></h4>
<pre><code>Type: String (as JSON)
Default: {
           &quot;type&quot;: &quot;keyword&quot;,
           &quot;ignore_above&quot;: 10922,
           &quot;normalizer&quot;: &quot;lowercase&quot;,
           &quot;copy_to&quot;: &quot;zdb_all&quot;
         }
</code></pre>
<p>By default, ZomboDB will map “string” properties found in nested objects (fields of type
‘json’ or ‘jsonb’) using the above type mapping -- they’ll be indexed as full-value keywords.</p>
<p>You can override this at <code>CREATE INDEX</code> time.</p>
<h3 id="advanced-options"><a class="header" href="#advanced-options">Advanced Options</a></h3>
<h4 id="options"><a class="header" href="#options"><code>options</code></a></h4>
<pre><code>Type: comma-separated String of index link definitions
</code></pre>
<p><code>options</code> is a ZomboDB-specific string that allows you to define how this index relates to other indexes. 
This is an advanced-use feature and is documented <a href="administration/CROSS-INDEX-JOINS.html">here</a>.</p>
<p>Changes via <code>ALTER INDEX</code> take effect immediately.</p>
<h4 id="field_lists"><a class="header" href="#field_lists"><code>field_lists</code></a></h4>
<pre><code>Type: comma-separated String
</code></pre>
<p>Allows to define lists fields that, when queried, are dynamically expanded to search their defined list of other fields. 
The syntax for this setting is: </p>
<pre><code>field_lists='fake_field1=[a, b, c], fake_field2=[d,e,f], ...'
</code></pre>
<p>This can be useful, for example, for searching all “date” fields at once, or defining a set of fields that represent 
“names” or “locations”. Note that each field in a list must be of the same underlying Postgres data type.</p>
<p>Changes via <code>ALTER INDEX</code> take effect immediately.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-zombodb-index-in-postgres"><a class="header" href="#creating-a-zombodb-index-in-postgres">Creating a ZomboDB Index in Postgres</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="important-things-to-know"><a class="header" href="#important-things-to-know">Important Things To Know</a></h1>
<h2 id="general-design-notes"><a class="header" href="#general-design-notes">General Design Notes</a></h2>
<p>Postgres↔Elasticsearch integrations are usually implemented in application code and are typically asynchronous, meaning that Elasticsearch index updates appear to query results some time in the future.  ZomboDB is not this kind of integration.</p>
<p>ZomboDB ties into Postgres’ Index Access Method API, which means it’s synchronous.  This is not to say that ZomboDB isn’t also concurrent -- it most definitely is.  However, any <code>COPY</code>/<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> in a given Postgres session against a table with a ZomboDB index will round-trip to Elasticsearch.</p>
<p>ZomboDB does, however, batch Elasticsearch indexing requests by transaction (<strong>not</strong> by row).  This approach reduces the number of round trips to Elasticsearch to the minimal amount.  If during a transaction, a batch needs to be sent to Elasticsearch in order to properly a search (a SELECT or aggregate function) then ZomboDB will do that automatically.</p>
<p>Because ZomboDB is an index type, it (along with help from Postgres) guarantees MVCC correctness across all queries that use it.  This includes normal WHERE clause conditions along with SQL-functions that perform Elasticsearch-specific aggregates that are wholly solved within the Elasticsearch cluster.</p>
<p>As such, any sort of failure either with ZomboDB itself, between Postgres and Elasticsearch (network layer), or within Elasticsearch will cause the operating Postgres transaction to ABORT.</p>
<p>This is most definitely by design.  Yet it’s important to realize that such failures are pushed forward to the client.</p>
<h2 id="zombodb-defaults-to-zero-elasticsearch-index-replicas"><a class="header" href="#zombodb-defaults-to-zero-elasticsearch-index-replicas">ZomboDB Defaults to <strong>ZERO</strong> Elasticsearch Index Replicas</a></h2>
<p>ZomboDB’s <code>VACUUM</code> implementation requires that, when it deletes dead docs from the backing Elasticsearch index, it must <code>?wait_for_active_shards=all</code>.  This is necessary to ensure that deleted docs are fully replicated before Postgres decides to re-use those tuple slots.</p>
<p>In a typical development environment you’re likely only going to have one Elasticsearch node (which is fine).  So if you had replicas set to &gt;= 1, ZomboDB’s VACUUM process would hang (until timeout) waiting for the replicas to receive the delete requests -- because with only one node, replicas are in an uninitialized state.</p>
<p>As such, ZomboDB provides a Postgres GUC called <code>zdb.default_replicas</code> (default is zero) that you can set on production servers where you have a well-configured Elasticsearch cluster.  You can also control the number of replicas per index with the <code>replicas</code> index option.</p>
<h2 id="you-always-want-postgres-to-plan-an-indexscan"><a class="header" href="#you-always-want-postgres-to-plan-an-indexscan">You Always Want Postgres to Plan an IndexScan</a></h2>
<p>While ZomboDB works just fine with query plans that plan Sequential Scans, Bitmap Index Scans, and other scans with Filter/Recheck conditions, you really want Postgres to choose an Index Scan against the ZomboDB index you intend to use.</p>
<p>ZomboDB assumes, by default, that the number of rows returned from a <code>==&gt;</code> query will be 2500.  For large tables, this is a good default that generally convinces Postgres that an Index Scan is the right choice.  You can, however, override this number either via the <code>zdb.default_row_estimate</code> GUC, or per query (described in <a href="internals/QUERY-DSL.html">QUERY-DSL.md</a>).</p>
<p>So as usual with Postgres, if you’re troubleshooting “slow queries”, make sure to <code>EXPLAIN</code> your query and ensure it’s using an Index Scan.</p>
<p>It’s also good to know that an Index Scan against a ZomboDB index returns the matching tuples in heap order (unlike a standard Postgres btree index), so it’s actually fairly efficient because it’s effectively doing a sequential scan on the heap (just likely skipping lots of pages along the way).</p>
<p>Note that if your query, however, requests scores (via <code>zdb.score()</code>) <strong>or</strong> has a <code>LIMIT</code> clause, then the tuples will be returned in descending score order (highest-scoring document first).  This is only true when an Index Scan is planned, but can be a big performance boost because you won’t also need to order the results by score.</p>
<h2 id="indexing-more-columns-means-more-elasticsearch-abilities"><a class="header" href="#indexing-more-columns-means-more-elasticsearch-abilities">Indexing More Columns Means More Elasticsearch Abilities</a></h2>
<p>ZomboDB is capable of anwering any Elasticsearch query, with correct MVCC results, wholly within Elasticsearch.  This means that complex aggregate queries can be answered in parallel across your Elasticsearch cluster, whereas the corresponding SQL “group by” query may run in a single thread on your Postgres node.</p>
<p>So while there is a cost in terms of storage and indexing time to index many columns, it may make sense to do so in order to maintain fast search response times.</p>
<h2 id="zombodb-stores-the-entire-row-in-elasticsearch"><a class="header" href="#zombodb-stores-the-entire-row-in-elasticsearch">ZomboDB Stores the Entire Row in Elasticsearch</a></h2>
<p>In order for ZomboDB to guarantee MVCC correct results it needs to track certain transaction visibility values in Elasticsearch.  Additionally, it needs to update those values when tuples are updated or deleted or vacuumed away.  This necessitates that ZomboDB store the entire document source for each indexed row so that Elasticsearch can properly update the corresponding indexed document.</p>
<p>This means your Elasticsearch index sizes are most likely going to be measurably <em>larger</em> (perhaps close to 2x larger) than the on-disk representation in Postgres.  This is due to storing the document source plus all the indexed/analyzed terms for every field.  Keep this in mind when designing your Elasticsearch cluster.</p>
<h2 id="zombodb-rewrites-your-queries-and-create-index-statements"><a class="header" href="#zombodb-rewrites-your-queries-and-create-index-statements">ZomboDB Rewrites Your Queries and CREATE INDEX Statements</a></h2>
<p>When you write a ZomboDB query, you use the <code>==&gt;</code> operator.  The left-hand-side of <code>==&gt;</code> is a reference to the table you want to query, and the right-hand-side is your actual Elasticsearch query.</p>
<p>During the Postgres query planning phase, ZomboDB rewrites this so that the left-hand-side of <code>==&gt;</code> is actually the <code>ctid</code> system column of the table you originally specified.</p>
<p>For example, the query <code>SELECT * FROM table WHERE table ==&gt; 'foo'</code> is rewritten as if you had actually specified <code>SELECT * FROM table WHERE table.ctid ==&gt; 'foo'</code>.</p>
<p>This is transparent to you, but is necessary in order for ZomboDB to support all of Postgres’ various query plan types, including plans that include sequential scans and hash joins.</p>
<h2 id="zombodb-attaches-hidden-triggers-to-tables"><a class="header" href="#zombodb-attaches-hidden-triggers-to-tables">ZomboDB Attaches “hidden” Triggers to Tables</a></h2>
<p>When you <code>CREATE INDEX ... ON table USING zombodb (...)</code> ZomboDB attaches two “hidden” triggers (they’re considered <code>tgisinternal</code> triggers) to the <code>table</code>.  The triggers are FOR EACH ROW BEFORE UPDATE and DELETE triggers that track MVCC visibility changes as part of the UPDATE and DELETE statement.</p>
<p>They’re uniquely named and shouldn’t cause conflicts with triggers you might need to add yourself.</p>
<p>Additionally, the triggers have a catalog dependency on the ZomboDB index, so when you drop the index, the triggers are automatically dropped.</p>
<p>This should be a worry-free thing, but it’s something to know.</p>
<h2 id="external-tools-like-kibana-are-supported"><a class="header" href="#external-tools-like-kibana-are-supported">External Tools Like Kibana are Supported</a></h2>
<p>Not only tools like Kibana, but you can search ZomboDB-managed indices with curl, if you want.  But there’s a catch...</p>
<p>ZomboDB stores dead rows, aborted rows, and in-flight rows from active transactions, and manages this state itself with help from Postgres.</p>
<p>If you’re searching the indices with an external tool, you’re going to see those rows too because you don’t also have Postgres helping you.</p>
<p>It’s also important to mention that you should <strong>NOT</strong> be modifying ZomboDB-managed indices with external tools.  While there’s nothing stopping you from doing this you’ll end up breaking ZomboDB’s results from within Postgres, and that’s the whole reason you decided to install ZomboDB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-mapping"><a class="header" href="#type-mapping">Type Mapping</a></h1>
<p>ZomboDB provides a set of default mappings between Postgres and Elasticsearch for Postgres’ common data types.  ZomboDB also includes a complete set of custom Postgres DOMAINs that represent all of the foreign languages that Elasticsearch supports.</p>
<p>This document attempts to explain how ZomboDB maps Postgres data types to Elasticsearch data types, how they’re analyzed (if at all), and how these things can be controlled through a combination of Postgres’ type system and ZomboDB-specific functions.</p>
<h2 id="common-data-types"><a class="header" href="#common-data-types">Common Data Types</a></h2>
<p>These are the default mappings:</p>
<table><thead><tr><th>Postgres Type</th><th>Elasticsearch JSON Mapping Definition</th></tr></thead><tbody>
<tr><td><code>bytea</code></td><td><code>{&quot;type&quot;: &quot;binary&quot;}</code></td></tr>
<tr><td><code>boolean</code></td><td><code>{&quot;type&quot;: &quot;boolean&quot;}</code></td></tr>
<tr><td><code>smallint</code></td><td><code>{&quot;type&quot;: &quot;short&quot;}</code></td></tr>
<tr><td><code>integer</code></td><td><code>{&quot;type&quot;: &quot;integer&quot;}</code></td></tr>
<tr><td><code>bigint</code></td><td><code>{&quot;type&quot;: &quot;long&quot;}</code></td></tr>
<tr><td><code>real</code></td><td><code>{&quot;type&quot;: &quot;float&quot;}</code></td></tr>
<tr><td><code>double precision</code></td><td><code>{&quot;type&quot;: &quot;double&quot;}</code></td></tr>
<tr><td><code>character varying</code></td><td><code>{&quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;, &quot;normalizer&quot;: &quot;lowercase&quot;, &quot;ignore_above&quot;: 10922}</code></td></tr>
<tr><td><code>text</code></td><td><code>{&quot;type&quot;: &quot;text&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;, &quot;analyzer&quot;: &quot;zdb_standard&quot;, &quot;fielddata&quot;: true}</code></td></tr>
<tr><td><code>time without time zone</code></td><td><code>{&quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;HH:mm:ss.SSSSSS&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>time with time zone</code></td><td><code>{&quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;HH:mm:ss.SSSSSSZZ&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>date</code></td><td><code>{&quot;type&quot;: &quot;date&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>timestamp without time zone</code></td><td><code>{&quot;type&quot;: &quot;date&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>timestamp with time zone</code></td><td><code>{&quot;type&quot;: &quot;date&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>json</code></td><td><code>{&quot;type&quot;: &quot;nested&quot;, &quot;include_in_parent&quot;: true}</code></td></tr>
<tr><td><code>jsonb</code></td><td><code>{&quot;type&quot;: &quot;nested&quot;, &quot;include_in_parent&quot;: true}</code></td></tr>
<tr><td><code>inet</code></td><td><code>{&quot;type&quot;: &quot;ip&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;}</code></td></tr>
<tr><td><code>point</code></td><td><code>{&quot;type&quot;: &quot;geo_point&quot;}</code></td></tr>
<tr><td><code>zdb.fulltext</code></td><td><code>{&quot;type&quot;: &quot;text&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;, &quot;analyzer&quot;: &quot;zdb_standard&quot;}</code></td></tr>
<tr><td><code>zdb.fulltext_with_shingles</code></td><td><code>{&quot;type&quot;: &quot;text&quot;, &quot;copy_to&quot;: &quot;zdb_all&quot;, &quot;analyzer&quot;: &quot;fulltext_with_shingles&quot;, &quot;search_analyzer&quot;: &quot;fulltext_with_shingles_search&quot;}</code></td></tr>
<tr><td><code>geography</code> (from postgis)</td><td><code>{&quot;type&quot;: &quot;geo_shape&quot;}</code></td></tr>
<tr><td><code>geometry</code> (from postgis)</td><td><code>{&quot;type&quot;: &quot;geo_shape&quot;}</code></td></tr>
<tr><td><code>geography(Point, x)</code> (from postgis)</td><td><code>{&quot;type&quot;: &quot;geo_point&quot;}</code></td></tr>
<tr><td><code>geometry(Point, x)</code> (from postgis)</td><td><code>{&quot;type&quot;: &quot;geo_point&quot;}</code></td></tr>
<tr><td>Some things to note from the above:</td><td></td></tr>
</tbody></table>
<ul>
<li>Columns of type <code>bytea</code> are automatically encoded as <code>base64</code> for proper storage by Elasticsearch</li>
<li>Columns of type <code>character varying (varchar)</code> are <strong>not</strong> analyzed by Elasticsearch.  They’re indexed as whole values, but are converted to lowercase</li>
<li>Columns of type <code>text</code> <strong>are</strong> analyzed by Elasticsearch using its <code>standard</code> analyzer, and the individual terms are converted to lowercase</li>
<li>Columns of type <code>json/jsonb</code> are mapped to Elasticsearch’s <code>nested</code> object with a dynamic template that treats “string” properties as if they’re of type <code>character varying</code> (ie, unanalyzed exact, lowercased values), and treats “date” properties as if they’re dates, accepting a wide range of date formats</li>
<li>Columns of type <code>geometry</code> and <code>geography</code> are automatically converted to GeoJson at index time and translated to CRS <code>4326</code>
In all cases above, arrays of Postgres types are fully supported.</li>
</ul>
<h2 id="zombodbs-custom-domain-types"><a class="header" href="#zombodbs-custom-domain-types">ZomboDB’s Custom DOMAIN types</a></h2>
<p>ZomboDB includes a few custom Postgres DOMAIN types which can be used as column types in your tables.</p>
<p><code>zdb.fulltext</code> works exactly the same way as a column of type <code>text</code>, but exists so as to provide an extra hint of metadata to client applications indicating that the column likely contains a large amount of text.</p>
<p><code>zdb.fulltext_with_shingles</code> is akin to <code>zdb.fulltext</code> but uses a 2-gram single filter for high-speed right-truncated wildcard support.</p>
<h2 id="language-specific-domain-types"><a class="header" href="#language-specific-domain-types">Language-specific DOMAIN types</a></h2>
<p>As noted earlier, ZomboDB provide support for all of Elasticsearch’s language analyzers, exposed as Postgres DOMAINs.  This allows you to create tables with columns of type <code>portuguese</code> or <code>thai</code>, for example.  The complete set of language domains is:</p>
<pre><code>arabic, armenian, basque, brazilian, bulgarian, catalan, chinese, cjk, 
czech, danish, dutch, english, finnish, french, galician, german, greek, 
hindi, hungarian, indonesian, irish, italian, latvian, norwegian, persian, 
portuguese, romanian, russian, sorani, spanish, swedish, turkish, thai
</code></pre>
<p>More details on how Elasticsearch analyzes each of these can be found in its <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html">language analyzers</a> documentation.</p>
<h1 id="defining-custom-analyzers-filters-normalizers-type-mappings"><a class="header" href="#defining-custom-analyzers-filters-normalizers-type-mappings">Defining Custom Analyzers, Filters, Normalizers, Type Mappings</a></h1>
<p>ZomboDB provides a set of SQL-level functions that allow you to define custom analyzer chains, filters, normalizers, along with custom type mappings.</p>
<p>These are designed to be used with Postgres’ <code>CREATE DOMAIN</code> command where the domain name exactly matches the analyzer name.</p>
<h2 id="analysis-definition-functions"><a class="header" href="#analysis-definition-functions">Analysis Definition Functions</a></h2>
<pre><code class="language-sql">FUNCTION zdb.define_analyzer(name text, definition json)
</code></pre>
<p>Allows for the definition of Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-custom-analyzer.html">custom analyzers</a>.  Depending on the complexity of the analyzer you need to define, you’ll likely first need to define custom filters or tokenizers, as described below.</p>
<p>In order to use a custom analyzer you must make a custom Postgres DOMAIN with the same name, and then you can use that DOMAIN as column type in your tables.</p>
<p>You can also use the custom analyzer in conjunction with a custom field mapping via the <code>zdb.define_field_mapping()</code> function described below.</p>
<p>Note that making changes to any of the analysis definitions will require a <code>REINDEX</code> of any indices that use the things you changed.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_filter(name text, definition json)
</code></pre>
<p>Allows for the definition of a custom Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenfilters.html">token filter</a>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_char_filter(name text, definition json) 
</code></pre>
<p>Allows for the definition of a custom Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html">character filter</a>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_tokenizer(name text, definition json)
</code></pre>
<p>Allows for the definition of a custom Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html">tokenizer</a>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_normalizer(name text, definition json) 
</code></pre>
<p>Allows for the definition of a custom Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-normalizers.html">normalizer</a>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_type_mapping(type_name regtype, definition json)
</code></pre>
<p>If you need to define a type mapping for a Postgres datatype that isn’t included in ZomboDB’s defaults (<code>citext</code>, for example), this is the function to use.</p>
<pre><code class="language-sql">FUNCTION zdb.define_type_mapping(type_name regtype, funcid regproc)
</code></pre>
<p>If you need to define a type mapping for a Postgres datatype that isn’t included in ZomboDB’s defaults and if doing so
requires looking at the <code>typmod</code> value as it’s defined for the column being indexed, use this function.</p>
<p>The first argument is the type name (as a <code>regtype</code>) and the second argument is the <code>regproc</code> oid of the function ZDB
should call to generate the mapping.</p>
<p>That function should take two arguments, the first being of type <code>regtype</code> and the second being an integer that is the
<code>typmod</code> value.</p>
<h2 id="field-specific-mapping-functions"><a class="header" href="#field-specific-mapping-functions">Field-Specific Mapping Functions</a></h2>
<p>Rather than using DOMAIN types to map Postgres types to an Elasticsearch analyzer, you can also define field-specific mappings per table and field.</p>
<p>This approach can be quite powerful as you can set, per field, all the mapping properties that Elasticsearch allows, and you don’t need to create and manage custom DOMAIN types.</p>
<pre><code class="language-sql">FUNCTION zdb.define_field_mapping(table_name regclass, field_name text, definition json) 
</code></pre>
<p>If you need to define a field mapping for a specific field in a specific table, this is the function to use.  You can specify any <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html">custom mapping definition json</a> that is supported by Elasticsearch.</p>
<p>Creating or changing a field mapping requires a <code>REINDEX</code> of the specified table.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.define_es_only_field(table_name regclass, field_name text, definition json)
</code></pre>
<p>If you want a custom field that only exists in the Elasticsearch index (perhaps as a target to the mapping <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/copy-to.html"><code>copy_to</code></a> property, you can use this.</p>
<p>Any field you create here can be searched and used with aggregates, but won’t be SELECT-able by Postgres.</p>
<p>Creating or changing an Elasticearch-only field requires a <code>REINDEX</code> of the specified table.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-sql">SELECT zdb.define_tokenizer('example_tokenizer', '{
          &quot;type&quot;: &quot;pattern&quot;,
          &quot;pattern&quot;: &quot;_&quot;
        }');
SELECT zdb.define_analyzer('example', '{
          &quot;tokenizer&quot;: &quot;example_tokenizer&quot;
        }');
CREATE DOMAIN example AS text;
CREATE TABLE foo (
   id serial8,
   some_field example
);
CREATE INDEX idxfoo ON foo USING zombodb ((foo.*));
INSERT INTO foo (some_field) VALUES ('this_is_a_test');
SELECT * FROM foo WHERE foo ==&gt; 'some_field:this';
</code></pre>
<h1 id="testing-analyzers"><a class="header" href="#testing-analyzers">Testing Analyzers</a></h1>
<p>ZomboDB provides a few functions that can be used to evaluate how an analyzer actually tokenizes text.</p>
<pre><code class="language-sql">FUNCTION zdb.analyze_with_field(
	index regclass, 
	field text, 
	text text) 
RETURNS TABLE (
	type text, 
	token text, 
	&quot;position&quot; int, 
	start_offset int, 
	end_offset int)
</code></pre>
<p>This function allows you to evaluate text analysis using the analyzer already defined for a particular field.</p>
<p>Examples:</p>
<pre><code class="language-sql">SELECT * FROM zdb.analyze_with_field('idxproducts', 'keywords', 'this is a test');
 type |     token      | position | start_offset | end_offset 
------+----------------+----------+--------------+------------
 word | this is a test |        0 |            0 |         14
(1 row)
</code></pre>
<pre><code class="language-sql">SELECT * FROM zdb.analyze_with_field('idxproducts', 'long_description', 'this is a test');
    type    | token | position | start_offset | end_offset 
------------+-------+----------+--------------+------------
 &lt;ALPHANUM&gt; | this  |        0 |            0 |          4
 &lt;ALPHANUM&gt; | is    |        1 |            5 |          7
 &lt;ALPHANUM&gt; | a     |        2 |            8 |          9
 &lt;ALPHANUM&gt; | test  |        3 |           10 |         14
(4 rows)
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION zdb.analyze_text(
	index regclass, 
	analyzer text, 
	text text) 
RETURNS TABLE (
	type text, 
	token text, 
	&quot;position&quot; int, 
	start_offset int, 
	end_offset int)
</code></pre>
<p>This function allows you to evaluate analysis using a specific analyzer name, either built-in to Elasticsearch or one of the custom analyzers you may have defined.</p>
<p>Examples:</p>
<pre><code class="language-sql">SELECT * FROM zdb.analyze_text('idxproducts', 'keyword', 'this is a test');
 type |     token      | position | start_offset | end_offset 
------+----------------+----------+--------------+------------
 word | this is a test |        0 |            0 |         14
</code></pre>
<pre><code class="language-sql">SELECT * FROM zdb.analyze_text('idxproducts', 'standard', 'this is a test');
    type    | token | position | start_offset | end_offset 
------------+-------+----------+--------------+------------
 &lt;ALPHANUM&gt; | this  |        0 |            0 |          4
 &lt;ALPHANUM&gt; | is    |        1 |            5 |          7
 &lt;ALPHANUM&gt; | a     |        2 |            8 |          9
 &lt;ALPHANUM&gt; | test  |        3 |           10 |         14
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION zdb.analyze_custom(
	index regclass, 
	text text DEFAULT NULL, 
	tokenizer text DEFAULT NULL, 
	normalizer text DEFAULT NULL, 
	filter text[] DEFAULT NULL, 
	char_filter text[] DEFAULT NULL) 
RETURNS TABLE (
	type text, 
	token text, 
	&quot;position&quot; int, 
	start_offset int, 
	end_offset int)
</code></pre>
<p>This function allows you to dynamically define a custom analyzer and test it in real-time.</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT * FROM zdb.analyze_custom(
	index=&gt;'idxproducts', 
	text=&gt;'This is a test, 42 https://www.zombodb.com', 
	tokenizer=&gt;'whitespace', 
	filter=&gt;ARRAY['lowercase']);
 type |          token          | position | start_offset | end_offset 
------+-------------------------+----------+--------------+------------
 word | this                    |        0 |            0 |          4
 word | is                      |        1 |            5 |          7
 word | a                       |        2 |            8 |          9
 word | test,                   |        3 |           10 |         15
 word | 42                      |        4 |           16 |         18
 word | https://www.zombodb.com |        5 |           19 |         42
(6 rows)
</code></pre>
<h1 id="about-elasticsearchs-_all-field"><a class="header" href="#about-elasticsearchs-_all-field">About Elasticsearch’s <code>_all</code> Field</a></h1>
<p>In short, ZomboDB disables Elasticsearch’s <code>_all</code> field and instead configures its own field named <code>zdb_all</code>.  By default, all non-numeric field types are added to the <code>zdb_all</code> field.</p>
<p>ZomboDB does this to maintain compatability between Elasticsearch 5 and Elasticsearch 6, where <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-all-field.html">ES 6 deprecates the <code>_all</code> field</a>.</p>
<h1 id="custom-json-conversion"><a class="header" href="#custom-json-conversion">Custom JSON Conversion</a></h1>
<p>In general ZomboDB uses the equivalent of Postgres’ <code>to_json()</code> function to convert individual columns to JSON when indexing.<br />
However, ZomboDB does provide the ability to provide custom json conversion functions for any data type, and it installs
custom conversion functions for Postgres’ <code>point</code> type along with PostGIS’ <code>geometry</code> and <code>geography</code> types.</p>
<pre><code class="language-sql">FUNCTION zdb.define_type_conversion(
  typeoid regtype, 
  funcoid regproc) 
RETURNS void
</code></pre>
<p>If you have a custom datatype that you need to convert to json, you need to make a conversion function that takes a
single argument that is the type you wish to convert and returns json.  Then you’ll call this function to associate
your type with your conversion function.</p>
<p>You’ll also need to define a custom type mapping using <code>zdb.define_type_mapping()</code> (see above).</p>
<p>An example might be:</p>
<pre><code class="language-sql">CREATE TYPE example AS (
  title varchar(255),
  description text
);

-- custom json conversion function
CREATE OR REPLACE FUNCTION example_type_to_json(example) RETURNS json IMMUTABLE STRICT LANGUAGE sql AS $$
  SELECT json_build_object('title', $1.title, 'description', $1.description);
$$;

-- associate the type with the custom json conversion function
SELECT zdb.define_type_conversion('example'::regtype, 'example_type_to_json'::regproc);

-- define a type mapping for 'example'
SELECT zdb.define_type_mapping('example'::regtype, '{&quot;type&quot;:&quot;nested&quot;}');
</code></pre>
<p>Now you can create a table using that type and create a ZomboDB index on it:</p>
<pre><code class="language-sql">CREATE TABLE test (
  id serial8 NOT NULL PRIMARY KEY,
  data example
);

CREATE INDEX idxtest ON test USING zombodb ((test.*));

INSERT INTO test (data) VALUES (('this is the title', 'this is the description'));

SELECT * FROM test WHERE test ==&gt; dsl.nested('data', dsl.term('data.title', 'this is the title'));
 id |                      data                       
----+-------------------------------------------------
  1 | (&quot;this is the title&quot;,&quot;this is the description&quot;)
(1 row)

</code></pre>
<h1 id="similarity-module-support"><a class="header" href="#similarity-module-support">Similarity Module Support</a></h1>
<p>ZomboDB supports <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-similarity.html">Elasticsearch’s “Similarity Module”</a>) in a manner similar to the above.</p>
<p>This allows you to define different similarity algorithms and apply them to individual field mappings.</p>
<p>It uses the function</p>
<pre><code class="language-sql">FUNCTION zdb.define_similarity(name text, definition json) 
</code></pre>
<p>An short example of defining <code>LMJelinekMercer</code> algorithm:</p>
<pre><code class="language-sql">SELECT zdb.define_similarity('my_similarity', '
{
    &quot;type&quot;: &quot;LMJelinekMercer&quot;,
    &quot;lambda&quot;: 0.075
}
');
</code></pre>
<p>And then we’d define it for a field in a table.  Note that in doing so, we are required to define the entire
field mapping for this field.</p>
<pre><code class="language-sql">CREATE TABLE test (
  id serial8 NOT NULL PRIMARY KEY,
  data text
);

SELECT zdb.define_field_mapping('test', 'data', '
{
    &quot;type&quot;: &quot;text&quot;,
    &quot;analyzer&quot;: &quot;zdb_standard&quot;,
    &quot;similarity&quot;: &quot;my_similarity&quot;
}
');

CREATE INDEX idxtest ON test USING zombodb ((test.*));
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
