<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js zombo">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Aggregations</title>


        <!-- Custom HTML head -->
<link href="https://fonts.googleapis.com/css?family=Josefin+Slab|Open+Sans|Raleway" rel="stylesheet">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">
        <link rel="stylesheet" href="../zombo-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../zombo.css">
        <link rel="stylesheet" href="../zombo-highlight.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = "zombo";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('zombo')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting-started.html"><strong aria-hidden="true">2.</strong> Getting started tutorial</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="../usage/zql-queries.html"><strong aria-hidden="true">3.</strong> ZQL queries</a></li><li class="chapter-item expanded "><a href="../usage/elasticsearch-dsl-queries.html"><strong aria-hidden="true">4.</strong> ElasticSearch QueryDSL queries</a></li><li class="chapter-item expanded "><a href="../usage/using-sql-functions.html"><strong aria-hidden="true">5.</strong> Using SQL functions</a></li><li class="chapter-item expanded "><a href="../usage/scoring.html"><strong aria-hidden="true">6.</strong> Scoring</a></li><li class="chapter-item expanded "><a href="../usage/highlighting.html"><strong aria-hidden="true">7.</strong> Highlighting</a></li><li class="chapter-item expanded "><a href="../usage/cross-index-joins.html"><strong aria-hidden="true">8.</strong> Cross-index joins</a></li><li class="chapter-item expanded "><a href="../usage/aggregations.html" class="active"><strong aria-hidden="true">9.</strong> Aggregations</a></li><li class="chapter-item expanded "><a href="../usage/aggregate-builder-api.html"><strong aria-hidden="true">10.</strong> Aggregate Builder API</a></li><li class="chapter-item expanded "><a href="../usage/_cat-api_.html"><strong aria-hidden="true">11.</strong> ElasticSearch _cat API</a></li><li class="chapter-item expanded "><a href="../usage/postgis-support.html"><strong aria-hidden="true">12.</strong> PostGIS Support</a></li><li class="chapter-item expanded affix "><li class="part-title">Administration</li><li class="chapter-item expanded "><a href="../administration/binary-installation.html"><strong aria-hidden="true">13.</strong> Binary installation</a></li><li class="chapter-item expanded "><a href="../administration/source-installation.html"><strong aria-hidden="true">14.</strong> Source installation</a></li><li class="chapter-item expanded "><a href="../administration/configuration.html"><strong aria-hidden="true">15.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../administration/index-management.html"><strong aria-hidden="true">16.</strong> Index Management</a></li><li class="chapter-item expanded "><a href="../usage/creating-a-zombodb-index.html"><strong aria-hidden="true">17.</strong> Creating a ZomboDB Index in Postgres</a></li><li class="chapter-item expanded affix "><li class="part-title">Internals</li><li class="chapter-item expanded "><a href="../internals/important-things-to-know.html"><strong aria-hidden="true">18.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="../internals/type-mapping.html"><strong aria-hidden="true">19.</strong> Type Mapping</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="zombo">Zombo (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Cool</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="aggregate-functions"><a class="header" href="#aggregate-functions">Aggregate Functions</a></h1>
<p>ZomboDB exposes nearly all of Elasticsearch’s aggregates as type-checked SQL functions that return tables and discreet values, as opposed to json blobs.</p>
<p>In all cases, unless explicitly otherwise noted, the results returned from all of the below aggregate functions are MVCC-correct.  This means that the functions only operate against records that are considered visible to the current transaction.</p>
<h2 id="arbitrary-aggregate-support"><a class="header" href="#arbitrary-aggregate-support">Arbitrary Aggregate Support</a></h2>
<pre><code class="language-sql">FUNCTION zdb.arbitrary_agg(
	index regclass,
	query zdbquery,
	agg_json json) 
RETURNS json
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html</p>
<p>This function is a direct-path for executing any arbitrary aggregate search request that Elasticsearch supports.</p>
<p>The result is a json blob that can be processed in your application code or otherwise manipulated using Postgres json support functions.</p>
<h2 id="single-value-aggregates"><a class="header" href="#single-value-aggregates">Single-Value Aggregates</a></h2>
<pre><code class="language-sql">FUNCTION zdb.avg(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-avg-aggregation.html</p>
<p>A single-value metrics aggregation that computes the average of numeric values that are extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.cardinality(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-cardinality-aggregation.html</p>
<p>A single-value metrics aggregation that calculates an approximate count of distinct values. Values can be extracted either from specific fields in the document.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.count(
	index regclass,
	query zdbquery) 
RETURNS bigint
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html</p>
<p>Not an aggregate per se, this function is mapped to Elasticsearch’s <code>_count</code> endpoint and simply returns the number of documents that match the provided query.  The result is MVCC-correct.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.raw_count(
	index regclass,
	query zdbquery) 
RETURNS bigint SET zdb.ignore_visibility = true
</code></pre>
<p>Similar to <code>zdb.count()</code> above, but it ignores MVCC visibility rules, and the result is the actual count of documents matching the query, including deleted documents, documents from aborted transactions, old versions of documents from an UPDATE statement, and new/updated docs from in-flight transactions.</p>
<p>Generally you’ll want to use <code>zdb.count()</code> instead.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.max(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-max-aggregation.html</p>
<p>A single-value metrics aggregation that keeps track and returns the maximum value among the numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.min(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-min-aggregation.html</p>
<p>A single-value metrics aggregation that keeps track and returns the minimum value among numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.missing(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-missing-aggregation.html</p>
<p>A field data based single bucket aggregation, that creates a bucket of all documents in the current document set context that are missing a field value (effectively, missing a field or having the configured NULL value set).</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.sum(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-sum-aggregation.html</p>
<p>A single-value metrics aggregation that sums up numeric values that are extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.value_count(
	index regclass,
	field text,
	query zdbquery) 
RETURNS numeric
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-valuecount-aggregation.html</p>
<p>A single-value metrics aggregation that counts the number of values that are extracted from the aggregated documents. These values can be extracted either from specific fields in the documents.</p>
<hr />
<h2 id="multi-rowcolumn-aggregates"><a class="header" href="#multi-rowcolumn-aggregates">Multi-Row/Column Aggregates</a></h2>
<p>The following aggregates transform the results from Elasticsearch into “tables”, and should all be queried as such.  For example:</p>
<pre><code class="language-sql">SELECT * FROM zdb.terms('idxproducts', 'tags', dsl.match_all());
</code></pre>
<hr />
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	key text,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-adjacency-matrix-aggregation.html</p>
<p>A bucket aggregation returning a form of adjacency matrix. The request provides a collection of named filter expressions, similar to the filters aggregation request. Each bucket in the response represents a non-empty cell in the matrix of intersecting filters.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix_2x2(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	&quot;-&quot; text,
	&quot;1&quot; text,
	&quot;2&quot; text)
</code></pre>
<p>This is a table-based version of <code>zdb.adjacency_matrix()</code> that outputs a 2x2 matrix.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix_3x3(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	&quot;-&quot; text,
	&quot;1&quot; text,
	&quot;2&quot; text,
	&quot;3&quot; text)
</code></pre>
<p>This is a table-based version of <code>zdb.adjacency_matrix()</code> that outputs a 3x3 matrix.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix_4x4(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	&quot;-&quot; text,
	&quot;1&quot; text,
	&quot;2&quot; text,
	&quot;3&quot; text,
	&quot;4&quot; text)
</code></pre>
<p>This is a table-based version of <code>zdb.adjacency_matrix()</code> that outputs a 4x4 matrix.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.adjacency_matrix_5x5(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	&quot;-&quot; text,
	&quot;1&quot; text,
	&quot;2&quot; text,
	&quot;3&quot; text,
	&quot;4&quot; text,
	&quot;5&quot; text)
</code></pre>
<p>This is a table-based version of <code>zdb.adjacency_matrix()</code> that outputs a 5x5 matrix.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.date_histogram(
	index regclass,
	field text,
	query zdbquery,
	&quot;interval&quot; text,
	format text DEFAULT 'yyyy-MM-dd') 
RETURNS TABLE (
	key numeric,
	key_as_string text,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-datehistogram-aggregation.html</p>
<p>A multi-bucket aggregation similar to the histogram except it can only be applied on date values. Since dates are represented in Elasticsearch internally as long values, it is possible to use the normal histogram on dates as well, though accuracy will be compromised. The reason for this is in the fact that time based intervals are not fixed (think of leap years and on the number of days in a month). For this reason, we need special support for time based data. From a functionality perspective, this histogram supports the same features as the normal histogram. The main difference is that the interval can be specified by date/time expressions.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.date_range(
	index regclass,
	field text,
	query zdbquery,
	date_ranges_array json) 
RETURNS TABLE (
	key text,
	&quot;from&quot; numeric,
	from_as_string timestamp with time zone,
	&quot;to&quot; numeric,
	to_as_string timestamp with time zone,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html</p>
<p>A range aggregation that is dedicated for date values. The main difference between this aggregation and the normal range aggregation is that the from and to values can be expressed in Date Math expressions, and it is also possible to specify a date format by which the from and to response fields will be returned. Note that this aggregation includes the from value and excludes the to value for each range.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.extended_stats(
	index regclass,
	field text,
	query zdbquery,
	sigma int DEFAULT 0) 
RETURNS TABLE (
	count bigint,
	min numeric,
	max numeric,
	avg numeric,
	sum numeric,
	sum_of_squares numeric,
	variance numeric,
	stddev numeric,
	stddev_upper numeric,
	stddev_lower numeric)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-extendedstats-aggregation.html</p>
<p>A multi-value metrics aggregation that computes stats over numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.filters(
	index regclass,
	labels text[],
	filters zdbquery[]) 
RETURNS TABLE (
	label text,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filters-aggregation.html</p>
<p>Similar to <code>zdb.count()</code> except multiple queries (filters) are supported.</p>
<p>The <code>labels</code> and <code>filters</code> arguments must have the same bounds.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.histogram(
	index regclass,
	field text,
	query zdbquery,
	&quot;interval&quot; float8) 
RETURNS TABLE (
	key numeric,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-histogram-aggregation.html</p>
<p>A multi-bucket values source based aggregation that can be applied on numeric values extracted from the documents. It dynamically builds fixed size (a.k.a. interval) buckets over the values. For example, if the documents have a field that holds a price (numeric), we can configure this aggregation to dynamically build buckets with interval 5 (in case of price it may represent $5).</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.ip_range(
	index regclass,
	field text,
	query zdbquery,
	ip_ranges_array json) 
RETURNS TABLE (
	key text,
	&quot;from&quot; inet,
	&quot;to&quot; inet,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-iprange-aggregation.html</p>
<p>Just like the dedicated date range aggregation, there is also a dedicated range aggregation for IP typed fields.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.matrix_stats(
	index regclass,
	fields text[],
	query zdbquery) 
RETURNS TABLE (
	name text,
	count bigint,
	mean numeric,
	variance numeric,
	skewness numeric,
	kurtosis numeric,
	covariance json,
	correlation json)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-matrix-stats-aggregation.html</p>
<p>The matrix_stats aggregation is a numeric aggregation that computes various statistics over a set of document fields.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.percentile_ranks(
	index regclass,
	field text,
	query zdbquery,
	&quot;values&quot; text DEFAULT '') 
RETURNS TABLE (
	percentile numeric,
	value numeric)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-rank-aggregation.html</p>
<p>A multi-value metrics aggregation that calculates one or more percentile ranks over numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.percentiles(
	index regclass,
	field text,
	query zdbquery,
	percents text DEFAULT '') 
RETURNS TABLE (
	percentile numeric,
	value numeric)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-aggregation.html</p>
<p>A multi-value metrics aggregation that calculates one or more percentiles over numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.range(
	index regclass,
	field text,
	query zdbquery,
	ranges_array json) 
RETURNS TABLE (
	key text,
	&quot;from&quot; numeric,
	&quot;to&quot; numeric,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-range-aggregation.html</p>
<p>A multi-bucket value source based aggregation that enables the user to define a set of ranges - each representing a bucket. During the aggregation process, the values extracted from each document will be checked against each bucket range and “bucket” the relevant/matching document. Note that this aggregation includes the from value and excludes the to value for each range.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.significant_terms(
	index regclass,
	field text,
	query zdbquery) 
RETURNS TABLE (
	term text,
	doc_count bigint,
	score numeric,
	bg_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significantterms-aggregation.html</p>
<p>An aggregation that returns interesting or unusual occurrences of terms in a set.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.significant_terms_two_level(
	index regclass,
	first_field text,
	second_field text,
	query zdbquery,
	size bigint DEFAULT 0) 
RETURNS TABLE (
	first_term text,
	second_term text,
	doc_count bigint,
	score numeric,
	bg_count bigint,
	doc_count_error_upper_bound bigint,
	sum_other_doc_count bigint)
</code></pre>
<p>An adaption of <code>zdb.significant_terms()</code> where it uses <code>zdb.terms()</code> for the terms from <code>first_field</code> and <code>zdb.significant_terms()</code> for the terms for <code>second_field</code>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.significant_text(
	index regclass,
	field text,
	query zdbquery,
	sample_size int DEFAULT 0,
	filter_duplicate_text boolean DEFAULT true) 
RETURNS TABLE (
	term text,
	doc_count bigint,
	score numeric,
	bg_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significanttext-aggregation.html</p>
<p>An aggregation that returns interesting or unusual occurrences of free-text terms in a set. It is like the significant terms aggregation but differs in that:</p>
<ul>
<li>It is specifically designed for use on type text fields</li>
<li>It does not require field data or doc-values</li>
<li>It re-analyzes text content on-the-fly meaning it can also filter duplicate sections of noisy text that otherwise tend to skew statistics.</li>
</ul>
<p>This aggregate is only supported by Elasticsearch 6+ clusters.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.suggest_terms(
    index regclass,
    field_name text,
    suggest test,
    query zdbquery,
) RETURNS TABLE (
        term text,
        offset bigint,
        length bigint,
        suggestion text,
        score double precision,
        frequency bigint,

)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html</p>
<p>While not necessarily an aggregate, <code>zdb.terms_suggester</code> will tokenize an input textual suggestion string
and provide suggestions for each token that contains suggestions.</p>
<p>Useful for correcting misspellings -- ie, “Did you mean?”-style queries</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.stats(
	index regclass,
	field text,
	query zdbquery) 
RETURNS TABLE (
	count bigint,
	min numeric,
	max numeric,
	avg numeric,
	sum numeric)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-stats-aggregation.html</p>
<p>A multi-value metrics aggregation that computes stats over numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents.</p>
<hr />
<pre><code class="language-FUNCTION zdb_tally(">    index_name regclass, 
    fieldname text 
    [, is_nested boolean], 
    stem text, 
    query zdbquery, 
    max_terms bigint, 
    sort_order zdb_tally_order 
    [, shard_size int DEFAULT 0]) 
RETURNS SET OF zdb_tally_response
</code></pre>
<p><code>index_name</code>:  The name of the a ZomboDB index to query<br />
<code>fieldname</code>: The name of a field from which to derive terms<br />
<code>is_nested</code>: Optional argument to indicate that the terms should only come from matching nested object sub-elements.  Default is <code>false</code><br />
<code>stem</code>:  a Regular expression by which to filter returned terms, or a date interval if the specified <code>fieldname</code> is a date or timestamp<br />
<code>query</code>: a ZomboDB query<br />
<code>max_terms</code>: maximum number of terms to return.  A value of zero means “all terms”.
<code>sort_order</code>: how to sort the terms.  one of <code>'count'</code>, <code>'term'</code>, <code>'reverse_count'</code>, <code>'reverse_term'</code><br />
<code>shard_size</code>: optional parameter that tells Elasticsearch how many terms to return from each shard.  Default is zero, which means all terms</p>
<p>This function provides direct access to Elasticsearch’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html">terms aggregate</a> and cannot
be used with fields of type <code>fulltext</code>.  The results are MVCC-safe.  Returned terms are forced to upper-case.</p>
<p>If a stem is not specified, no results will be returned.</p>
<p>To match all terms: <code>^.*</code></p>
<p>If the specifield <code>fieldname</code> is a date/timestamp, then one of the following values are allowed for aggregating values 
into histogram buckets of the specified interval: <code>year, quarter, month, week, day, hour, minute, second</code>.  In all cases, 
an optional offset value can be specified.  For example:  <code>week:-1d</code> will offset the dates by one day so that the first 
day of the week will be considered to be Sunday (instead of the default of Monday).</p>
<p>Example:</p>
<pre><code class="language-sql">SELECT * FROM zdb_tally('products', 'keywords', '^.*', 'base* or distance', 5000, 'term');

    term      | count 
&gt;---------------+-------
BASEBALL      |     1
COMMUNICATION |     1
PRIMITIVE     |     1
SPORTS        |     1
THOMAS EDISON |     1
</code></pre>
<p>Regarding the <code>is_nested</code> argument, consider data like this:</p>
<pre><code>row #1: contributor_data=[ 
  { &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 42, &quot;location&quot;: &quot;TX&quot;, &quot;tags&quot;: [&quot;active&quot;] },
  { &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 36, &quot;location&quot;: &quot;TX&quot;, &quot;tags&quot;: [&quot;nice&quot;] }
&gt;]
&gt;
&gt;row #2: contributor_data=[ 
  { &quot;name&quot;: &quot;Bob Dole&quot;, &quot;age&quot;: 92, &quot;location&quot;: &quot;KS&quot;, &quot;tags&quot;: [&quot;nice&quot;, &quot;politician&quot;] },
  { &quot;name&quot;: &quot;Elizabth Dole&quot;, &quot;age&quot;: 79, &quot;location&quot;: &quot;KS&quot;, &quot;tags&quot;: [&quot;nice&quot;] }
&gt;]
</code></pre>
<p>And a query where <code>is_nested</code> is false:</p>
<pre><code class="language-sql">SELECT * FROM zdb.tally('idxproducts', 'contributor_data.name', false, '^.*', 'contributor_data.location:TX AND contributor_data.tags:nice', 5000, 'term');
</code></pre>
<p>returns:</p>
<pre><code>    term   | count 
----------+-------
  JANE DOE |     1
  JOHN DOE |     1
(2 rows)
</code></pre>
<blockquote>
<p>Whereas, if <code>is_nested</code> is true, only “JANE DOE” is returned because it’s the only subelement of <code>contributor_data</code> that matched the query:</p>
</blockquote>
<pre><code class="language-sql">SELECT * FROM zdb.tally('idxproducts', 'contributor_data.name', true, '^.*', 'contributor_data.location:TX WITH contributor_data.tags:nice', 5000, 'term');
</code></pre>
<p>returns:</p>
<pre><code>    term   | count 
----------+-------
  JANE DOE |     1
(1 row)
</code></pre>
<pre><code class="language-sql">CREATE TYPE terms_order AS ENUM (
	'count',
	'term',
	'reverse_count',
	'reverse_term');
FUNCTION zdb.terms(
	index regclass,
	field text,
	query zdbquery,
	size_limit bigint DEFAULT 0,
	order_by terms_order DEFAULT 'count') 
RETURNS TABLE (
	term text,
	doc_count bigint)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html</p>
<p>A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.terms_array(
	index regclass,
	field text,
	query zdbquery,
	size_limit bigint DEFAULT 0,
	order_by terms_order DEFAULT 'count') 
RETURNS text[]
</code></pre>
<p>A version of <code>zdb.terms()</code> that instead returns only the terms as a <code>text[]</code>.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.terms_two_level(
	index regclass,
	first_field text,
	second_field text,
	query zdbquery,
	order_by terms_order DEFAULT 'count',
	size bigint DEFAULT 0) 
RETURNS TABLE (
	first_term text,
	second_term text,
	doc_count bigint)
</code></pre>
<p>Similar to <code>zdb.significant_terms_two_level()</code>, this is an adaption of <code>zdb.terms()</code> to provide a two-level nested hierarchy of terms from two different fields.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.top_hits(
	index regclass,
	fields text[],
	query zdbquery,
	size int) 
RETURNS TABLE (
	ctid tid,
	score float4,
	source json)
</code></pre>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-top-hits-aggregation.html</p>
<p>A top_hits metric aggregator keeps track of the most relevant document being aggregated. This aggregator is intended to be used as a sub aggregator, so that the top matching documents can be aggregated per bucket.</p>
<hr />
<pre><code class="language-sql">FUNCTION zdb.top_hits_with_id(
	index regclass,
	fields text[],
	query zdbquery,
	size int) 
RETURNS TABLE (
	_id text,
	score float4,
	source json)
</code></pre>
<p>Similar to <code>zdb.top_hits()</code> above, but returns the Elasticsearch document <code>_id</code> value for each hit rather than the corresponding Postgres <code>ctid</code> value.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../usage/cross-index-joins.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../usage/aggregate-builder-api.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../usage/cross-index-joins.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../usage/aggregate-builder-api.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
