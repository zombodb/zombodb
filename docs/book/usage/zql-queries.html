<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js zombo">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ZQL queries</title>


        <!-- Custom HTML head -->
<link href="https://fonts.googleapis.com/css?family=Josefin+Slab|Open+Sans|Raleway" rel="stylesheet">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">
        <link rel="stylesheet" href="../zombo-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../zombo.css">
        <link rel="stylesheet" href="../zombo-highlight.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = "zombo";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('zombo')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting-started.html"><strong aria-hidden="true">2.</strong> Getting started tutorial</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="../usage/zql-queries.html" class="active"><strong aria-hidden="true">3.</strong> ZQL queries</a></li><li class="chapter-item expanded "><a href="../usage/elasticsearch-dsl-queries.html"><strong aria-hidden="true">4.</strong> ElasticSearch QueryDSL queries</a></li><li class="chapter-item expanded "><a href="../usage/using-sql-functions.html"><strong aria-hidden="true">5.</strong> Using SQL functions</a></li><li class="chapter-item expanded "><a href="../usage/scoring.html"><strong aria-hidden="true">6.</strong> Scoring</a></li><li class="chapter-item expanded "><a href="../usage/highlighting.html"><strong aria-hidden="true">7.</strong> Highlighting</a></li><li class="chapter-item expanded "><a href="../usage/cross-index-joins.html"><strong aria-hidden="true">8.</strong> Cross-index joins</a></li><li class="chapter-item expanded "><a href="../usage/aggregations.html"><strong aria-hidden="true">9.</strong> Aggregations</a></li><li class="chapter-item expanded "><a href="../usage/aggregate-builder-api.html"><strong aria-hidden="true">10.</strong> Aggregate Builder API</a></li><li class="chapter-item expanded "><a href="../usage/_cat-api_.html"><strong aria-hidden="true">11.</strong> ElasticSearch _cat API</a></li><li class="chapter-item expanded "><a href="../usage/postgis-support.html"><strong aria-hidden="true">12.</strong> PostGIS Support</a></li><li class="chapter-item expanded affix "><li class="part-title">Administration</li><li class="chapter-item expanded "><a href="../administration/binary-installation.html"><strong aria-hidden="true">13.</strong> Binary installation</a></li><li class="chapter-item expanded "><a href="../administration/source-installation.html"><strong aria-hidden="true">14.</strong> Source installation</a></li><li class="chapter-item expanded "><a href="../administration/configuration.html"><strong aria-hidden="true">15.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../administration/index-management.html"><strong aria-hidden="true">16.</strong> Index Management</a></li><li class="chapter-item expanded "><a href="../usage/creating-a-zombodb-index.html"><strong aria-hidden="true">17.</strong> Creating a ZomboDB Index in Postgres</a></li><li class="chapter-item expanded affix "><li class="part-title">Internals</li><li class="chapter-item expanded "><a href="../internals/important-things-to-know.html"><strong aria-hidden="true">18.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="../internals/type-mapping.html"><strong aria-hidden="true">19.</strong> Type Mapping</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="zombo">Zombo (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Cool</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="zql-queries"><a class="header" href="#zql-queries">ZQL queries</a></h1>
<p>ZQL (Zombo Query Language) is designed with many conveniences for text-search operations.</p>
<p>An example query might look like:</p>
<pre><code>    beer wine cheese w/3 food
</code></pre>
<p>Which would find all documents that contain the words <code>beer</code> <strong>and</strong> <code>wine</code> <strong>and</strong> occurrences of <code>cheese</code> within 3 words of <code>food</code>, regardless of the field (or fields) that contain each word.</p>
<p>The ZomboDB query syntax provides support for searching (in no particular order):</p>
<ul>
<li>full boolean operators (WITH, AND, OR, NOT),</li>
<li>words,</li>
<li>phrases,</li>
<li>fielded searching,</li>
<li>value lists</li>
<li>fuzzy words and phrases,</li>
<li>value ranges,</li>
<li>wildcards (left, middle, and right truncation),</li>
<li>term boosting</li>
<li>proximity (of word or phrase or combinations),</li>
<li>scripted searching,</li>
<li>Elasticsearch “bool” queries</li>
<li>Direct access to any Elasticsearch query via JSON</li>
<li>query expansion,</li>
<li>“more like this”,</li>
<li>limit/offset with sorting, and</li>
<li>more!</li>
</ul>
<h2 id="boolean-expressions-and-operator-precedence"><a class="header" href="#boolean-expressions-and-operator-precedence">Boolean Expressions and Operator Precedence</a></h2>
<p>The supported set of boolean operators are the standard <strong>NOT</strong>, <strong>WITH</strong> (for searching nested objects), <strong>AND</strong>, and <strong>OR</strong> operators along with proximity (<strong>W/n</strong> or <strong>WO/n</strong>).</p>
<p>If no operator is declared between terms, <strong>AND</strong> is assumed.  Additionally, parenthetical groupings are allowed to form complex boolean expressions.</p>
<p>The <strong>PROXIMITY</strong> operators take the highest priority, followed by <strong>NOT</strong>, <strong>WITH</strong>, <strong>AND</strong>, then finally <strong>OR</strong>.</p>
<p>For example, this query finds all documents which contain both <code>beer</code> <strong>AND</strong> <code>cheese</code> plus any documents that contain <code>wine</code>:</p>
<pre><code>    wine or beer and cheese
</code></pre>
<p>It is functionally equivalent to this query:</p>
<pre><code>    wine or (beer and cheese)
</code></pre>
<p>Whereas, this query finds all documents which contain both <code>beer</code> <strong>AND</strong> <code>cheese</code> but <strong>NOT</strong> <code>food</code>, plus any documents that contain <code>wine</code>:</p>
<pre><code>    wine or beer and cheese not food
</code></pre>
<p>It is functionally equivalent to this query:</p>
<pre><code>    wine or (beer and (cheese not food))
</code></pre>
<p>For convenience, each boolean operator has a single-character abbreviation:</p>
<ul>
<li>WITH: <strong>%</strong></li>
<li>AND:  <strong>&amp;</strong></li>
<li>OR:  <strong>,</strong></li>
<li>NOT:  <strong>!</strong></li>
</ul>
<p>So taking the example above, it could be rewritten as:</p>
<pre><code>    wine, beer &amp; cheese !food
</code></pre>
<p>And since the <strong>AND</strong> operator is the default, it could also be written as:</p>
<pre><code>    wine, beer cheese !food
</code></pre>
<h2 id="tokenization-escaping-case-sensitivity-and-term-analysis"><a class="header" href="#tokenization-escaping-case-sensitivity-and-term-analysis">Tokenization, Escaping, Case-Sensitivity, and Term Analysis</a></h2>
<p>During query parsing, tokens are formed whenever a character in this set is encountered:</p>
<pre><code>[  
   &quot;'&quot;, &quot;\&quot;&quot;,  &quot;:&quot;,  &quot;*&quot;,  &quot;~&quot;, &quot;?&quot;, 
   &quot;!&quot;,  &quot;%&quot;,  &quot;&amp;&quot;,  &quot;(&quot;,  &quot;)&quot;, &quot;,&quot;,
   &quot;&lt;&quot;,  &quot;=&quot;,  &quot;&gt;&quot;,  &quot;[&quot;,  &quot;]&quot;, &quot;^&quot;,
   &quot;{&quot;,  &quot;}&quot;,  &quot;`&quot;,  &quot; &quot;,  &quot;\r&quot;, &quot;\n&quot;, 
   &quot;\t&quot;, &quot;\f&quot; 
]
</code></pre>
<p>All other characters a valid token characters.</p>
<p>To use one of the above characters it must be escaped using a backslash, <em>or</em> the term must be quoted.  Any character is allowed within a quoted phrase.</p>
<p><code>foo#bar</code>, for example, would parse as a single term.</p>
<p>Terms and phrases are sub-parsed (analyzed) using the Elasticsearch-defined search analyzer for the field being searched.  Typically, analysis only happens on fields of type <code>phrase</code>, <code>phrase_array</code>, and <code>fulltext</code>.  Additionally, fields of custom <code>DOMAIN</code> types (such as <code>thai</code>, <code>english</code>, <code>cjk</code>) are also analyzed.</p>
<p>Token case is preserved, but may or may not be significant depending on how the underlying analyzer is defined.  All the default-supported analyzers are case-insensitive (including searching fields of type <code>text</code> and <code>varchar</code>), but a custom analyzer might decide to preserve case.</p>
<h2 id="term-and-phrase-searching"><a class="header" href="#term-and-phrase-searching">Term and Phrase Searching</a></h2>
<p>Terms and phrases are the basic search constructs for ZomboDB and are exactly what they sound like.</p>
<p>A term query:  <code>food</code><br />
A phrase query: <code>&quot;Now is the time&quot;</code></p>
<p>Phrases can be quoted using either single or double-quotes.</p>
<p>A unique feature of ZomboDB is that wildcards (<code>?</code>, <code>*</code>, and <code>~</code>) are allowed in “quoted phrases”.  Phrases that contain wildcards are transparently rewritten as proximity queries.</p>
<h2 id="fields-operators-keywords"><a class="header" href="#fields-operators-keywords">Fields, Operators, Keywords</a></h2>
<h3 id="fields"><a class="header" href="#fields">Fields</a></h3>
<p>If a term (or phrase) is prefixed with a field name and operator, searching will be limited to that field.  For convenience, entire parenthetical groups can be prefixed with a field name.</p>
<p>For example: </p>
<pre><code>name:&quot;John Doe&quot; and location:unknown 
  and crime:(shoplifting, &quot;grand-theft auto&quot;, jaywalking)
</code></pre>
<p>Fieldnames can also be quoted using backticks (`).  For example:</p>
<pre><code>`some:weird:Fieldname$`: &quot;the value to find&quot;
</code></pre>
<p>Typically, this is useful for searching property names within <code>json</code>/<code>jsonb</code> fields.</p>
<p>Without a field name, ZomboDB’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.6/mapping-all-field.html">zdb_all</a> field is searched.</p>
<p>Most of the examples that follow elide field names for (my) convenience, but know that they can be used in almost any situation a bare term or phrase is used.</p>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<p>Combined with a field name, these operators allow more sophisticated searching options.</p>
<table><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody>
<tr><td><code>:</code></td><td>field contains term</td></tr>
<tr><td><code>=</code></td><td>field contains term (same as : )</td></tr>
<tr><td><code>&lt;</code></td><td>field contains terms less than value</td></tr>
<tr><td><code>&lt;=</code></td><td>field contains terms less than or equal to value</td></tr>
<tr><td><code>&gt;</code></td><td>field contains terms greater than value</td></tr>
<tr><td><code>&gt;=</code></td><td>field contains terms greater than or equal to value</td></tr>
<tr><td><code>!=</code></td><td>field does not contain term</td></tr>
<tr><td><code>&lt;&gt;</code></td><td>field does not contain term (same as != )</td></tr>
<tr><td><code>/to/</code></td><td>range query, in form of field:START /to/ END</td></tr>
<tr><td><code>:~</code></td><td>field contains terms matching a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html#regexp-syntax">regular expression</a>.  Note that regular expression searches are always <strong>case sensitive</strong>.</td></tr>
<tr><td><code>:@</code></td><td><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html">“more like this”</a></td></tr>
<tr><td><code>:@~</code></td><td><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-flt-field-query.html">“fuzzy like this”</a></td></tr>
<tr><td><code>==&gt;</code></td><td>field “matches” the term, using Elasticsearch’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html">“match query”</a></td></tr>
</tbody></table>
<h3 id="keywords"><a class="header" href="#keywords">Keywords</a></h3>
<p>The list of keywords is very short: <code>with</code>, <code>and</code>, <code>or</code>, <code>not</code>, <code>null</code>, <code>true</code>, and <code>false</code>.<br />
To use one of these as a search term, simply quote it.</p>
<h2 id="value-lists--and-"><a class="header" href="#value-lists--and-">Value Lists (<code>[]</code> and <code>[[]]</code>)</a></h2>
<p>ZomboDB supports searching for lists of values using an array-like syntax.  For example:</p>
<p><code>field = [1,2,3,4,5]</code> or <code>field = [a,b,c,d]</code></p>
<p>Each element of the array is parsed as a token and run through analysis.  The underlying search is as if you OR’d those terms together, as in <code>field = 1 or field = 2 or field = 3 or field = 4 or field = 5</code></p>
<p>If you plan on searching for a large list of terms, as in 1,000 or even 10,000, you should use a slightly different syntax:</p>
<p><code>field = [[1,2,3...10000]]</code></p>
<ul>
<li>Note the double brackets</li>
</ul>
<p>This syntax is a “fast-pass” parsing that also doesn’t run each individual term through analysis.  With lots of terms, this is significantly faster than the other form that uses single brackets.</p>
<p>In either case, the only supported operators are equals and not equals, ie:
<code>:</code>, <code>=</code>, <code>!=</code>, <code>&lt;&gt;</code></p>
<h2 id="wildcards"><a class="header" href="#wildcards">Wildcards</a></h2>
<p>There are three types of wildcards.</p>
<table><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody>
<tr><td><code>?</code></td><td>any character</td></tr>
<tr><td><code>*</code></td><td>zero or more characters</td></tr>
<tr><td><code>~</code></td><td>post-fix only <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html">“fuzzy”</a> match with default fuzz of 3</td></tr>
</tbody></table>
<p>The <code>?</code> and <code>*</code> wildcards can be applied anywhere within a term.  Left, middle, and right truncation is supported.  The <code>~</code> wildcard is post-fix only and its fuzziness factor can be adjusted.</p>
<p>Examples:</p>
<p><code>be?r</code>:  would match beer, bear, etc<br />
<code>b*r</code>:  would match beer, bar, barber, etc<br />
<code>beer~</code>: would match beer, been, beep, etc<br />
<code>beer~2</code>: would match beer, bear, beep, bean, bell, etc</p>
<p>Special consideration is taken for criteria in the form of: <code>field:*</code> or <code>field:?</code>.  They are re-written using Elasticsearch’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-filter.html">“exists filter”</a>.</p>
<p>Note that phrases can also contain wildcarded terms, such as: <code>field:&quot;phrase~ w?th wild*rd&quot;</code>.  In this case, the phrase is rewritten as a proximity chain such as: <code>field:(phrase~ w/0 w?th w/0 wild*rd)</code>.  See below for details on proximity searching.</p>
<p>Additionally, entire phrases can “fuzzy”.  For example:</p>
<p><code>&quot;this phrase is fuzzy&quot;~3</code></p>
<p>This means that the words “this”, “phrase”, “is”, and “fuzzy” must appear within three tokens of each other, but order is not important.  So it could match <code>&quot;this phrase is a neat fuzzy feature&quot;</code>.</p>
<h2 id="termphrase-boosting"><a class="header" href="#termphrase-boosting">Term/Phrase Boosting</a></h2>
<p>Individual terms in a query can be “boosted” in order to increase the relevancy of matching documents.  Examples for term/phrase boosting are:</p>
<p><code>beer^2.0</code> or <code>&quot;this is a boosted phrase&quot;^2.0</code> or <code>apple w/2 cider^2.0 w/3 vinegar</code>.</p>
<p>A boost can also be applied to fielded searches, such as <code>author:Hemmingway^5.2 or author:Fitzgerald</code>.  This would rank documents whose author is Hemmingway higher, by an arbitrary amount.</p>
<p>The boost value is a floating point number and can either be between 0 and 1 (to decrease the boosting), or greater than 1 to increase the boosting.</p>
<p>From the Elasticsearch documentation:</p>
<pre><code>The boost parameter is used to increase the relative weight 
of a clause (with a boost greater than 1) or decrease the 
relative weight (with a boost between 0 and 1), but the increase 
or decrease is not linear. In other words, a boost of 2 does not 
result in double the score.

Instead, the new score is normalized after the boost is applied. 
Each type of query has its own normalization algorithm, and the 
details are beyond the scope of this book. Suffice to say that 
a higher boost value results in a higher score.
</code></pre>
<h2 id="proximity-searching"><a class="header" href="#proximity-searching">Proximity Searching</a></h2>
<p>Proximity searching allows to indicate that terms (or phrases) should be within a certain number of tokens of each other.</p>
<p>The operators are <strong>W/n</strong> and <strong>WO/n</strong>, where “n” indicates the distance.  <strong>W/n</strong> means <em>any order</em> and <strong>WO/n</strong> means <em>in order</em>.</p>
<p>Given the phrase:  <code>The quick brown fox jumped over the lazy dog's back</code></p>
<p>A proximity search in the form of: <code>jumped w/2 quick</code> would match the above because </p>
<ul>
<li>there are no more than two tokens between quick and jumped; and</li>
<li>order was not required</li>
</ul>
<p>Whereas <code>jumped wo/2 quick</code> would <em>not</em> match because order was required.</p>
<p>Proximity clauses can be chained together and are evaluated right-to-left.  For example:</p>
<p><code>quick w/2 jumped w/4 back</code> is evaluated as if it were written as <code>quick w/2 (jumped w/4 back)</code>.</p>
<p>Additionally, phrase proximity is supported.  For example:</p>
<p><code>&quot;quick brown fox&quot; w/3 &quot;lazy dog's back&quot;</code></p>
<p>Proximity operators take the highest precedence, so when combined with other boolean operators they are evaluated first.  For example:</p>
<p><code>quick and &quot;brown fox&quot; w/3 &quot;lazy dog's&quot; and back</code> is evaluated as if it were written as: <code>quick and (&quot;brown fox&quot; w/3 &quot;lazy dog's&quot;) and back</code></p>
<p>Proximity clauses can be limited to specific fields as well:  <code>title:catcher w/2 title:rye</code>.  Note that mixed fieldnames in a proximity chain is non-sensical and will produce a parse error.</p>
<p>It’s also possible to search for groups within some distance of another group.  This feature relates to Elasticsearch’s <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.7/query-dsl-span-or-query.html">span_or</a> clause. For example:</p>
<p><code>description:((cat OR dog) w/5 (pet wo/3 (sale OR &quot;free to good home&quot; OR free*)))</code></p>
<h2 id="subselects"><a class="header" href="#subselects">Subselects</a></h2>
<p>ZomboDB supports subselects which are akin to SQL <code>IN()</code> clauses.  The query clause is named <code>#subselect</code> and is an 
unary operator that can be used in conjunction with any of ZomboDB’s other query clauses, and can also be nested indefinitely.</p>
<p>An example query:</p>
<pre><code>   title:food AND #subselect&lt;id=&lt;schema.other_table.index_name&gt;join_id&gt;(other_field = 'other value') 
</code></pre>
<p>This is akin to an SQL statement such as:</p>
<pre><code class="language-sql">    SELECT * 
      FROM table 
     WHERE title LIKE 'food' 
       AND id IN (SELECT join_id FROM other_table WHERE other_field = 'other value');
</code></pre>
<p>You can do a subselect from any table/index pair that has an existing ZomboDB index, and if you wish to do a subselect
against the primary index you’re querying, simply specify <code>outer_field=&lt;this.index&gt;inner_field</code>, where <code>this.index</code> is
a literal value.  For example:</p>
<pre><code>    #subselect&lt;parent_id=&lt;this.index&gt;id&gt;(food, beer, wine)
</code></pre>
<p>The above will do a self-join and match all docs with a <code>parent_id</code> that’s equivalent to any doc <code>id</code> that contains
any of <code>food</code>, <code>beer</code>, or <code>wine</code>.</p>
<p>In the case where the table/index you’re subselecting from has the same fieldnames as the outer index, you may want
to use a “named index link” to help ZomboDB disambiguate field names.  Example:</p>
<pre><code>    #subselect&lt;my_name:(id=&lt;schema.other_table.index_name&gt;join_id)&gt;(my_name.common_field = value)
</code></pre>
<p><code>#subselect</code> is different from <code>#expand</code> (described below) in that <code>#expand</code> is intended to add more rows to the results,
whereas <code>#subselect</code> is intended to limit the results.</p>
<p><code>#subselect</code> requires a commercial license to ZomboDB’s companion Elasticsearch plugin.  Please contact zombodb@gmail.com for details.</p>
<h2 id="query-expansion"><a class="header" href="#query-expansion">Query Expansion</a></h2>
<p>Query expansion is a way for a single query to “pull in” additional records from the same index that are related to the records that match your fulltext query.</p>
<p>Say you have a table that holds emails:</p>
<pre><code class="language-sql">CREATE TABLE emails (
   id serial8 not null primary key,
   subject phrase,
   body fulltext,
   from text,
   to text[],
   cc text[],
   thread_id text,
   is_parent boolean
);
</code></pre>
<p>Now say you want to find all the emails that mention <code>beer</code> in the subject, but want to return the entire thread for each matching email.  Your query would be:</p>
<p><code>#expand&lt;thread_id=&lt;this.index&gt;thread_id&gt;(subject:beer)</code></p>
<p><code>this.index</code> is a literal (ie, not to be substituted with your actual index name).</p>
<p>What happens is that ZomboDB first finds all the emails that match <code>subject:beer</code> and internally “joins” back to the index on <code>thread_id = thread_id</code>.</p>
<p>What’s returned are all original matching records plus their thread members.  If an original record doesn’t have a <code>thread_id</code> (ie, <code>thread_id</code> is null), the record is still returned.</p>
<p>The left and right field names can be whatever “join condition” makes sense for the type of expansion you’re trying to perform -- the fields need not be the same.</p>
<p><code>#expand&lt;&gt;()</code> also supports an optional <code>#filter()</code> clause, that filters the expanded results before the final set is applied.  Using the same example, lets say we only want to expand to the “parent” email in all threads that discuss beer:</p>
<p><code>#expand&lt;thread_id=&lt;this.index&gt;thread_id&gt;(subject:beer #filter(is_parent:true))</code></p>
<p>This says “find all emails with ‘beer’ in the subject, expand to their parent emails, by <code>thread_id</code>, and return the combined set of records”.</p>
<p>Note that <code>#expand&lt;&gt;()</code> always add records to the results (it never removes records), so the results in the above example will be every email whose subject contains beer plus the parent email from their respective thread.</p>
<p>If you only want parent emails returned you’d add a boolean clause outside of the expansion:</p>
<p><code>#expand&lt;thread_id=&lt;this.index&gt;thread_id&gt;(subject:beer) and is_parent:true</code></p>
<p>In terms of ZomboDB’s query parser, <code>#expand&lt;&gt;()</code> is an unary operator and as such can be intermixed with boolean expressions (shown above) and infinitely nested as well.  An implementation note is that ZomboDB solves nested expansions from the bottom-up.</p>
<p><code>#expand</code> requires a commercial license to ZomboDB’s companion Elasticsearch plugin.  Please contact zombodb@gmail.com for details.</p>
<h2 id="elasticsearch-json-queries"><a class="header" href="#elasticsearch-json-queries">Elasticsearch JSON Queries</a></h2>
<p>While ZomboDB provides a fairly robust query language, it doesn’t expose every query construct (and parameter) that Elasticsearch supports.</p>
<p>As such, ZomboDB allows you to query using direct Elasticsearch-compatible JSON queries as well.  In fact, this feature operates as a unary operator within ZomboDB’s query language so you can mix-n-match Elasticsearch JSON queries with ZomboDB query constructs.</p>
<p>To use a direct JSON query, simply wrap your Elasticsearch-compatible JSON in <code>({</code> and <code>})</code>.</p>
<p>For example:</p>
<pre><code>beer OR wine OR cheese AND ({ &quot;term&quot;: &quot;subject&quot;: &quot;food&quot; }) NOT pickles

</code></pre>
<p>The JSON query structure you provide can be as complex as you need, and you can include as many <code>({ })</code> constructs within the query as you want.</p>
<h2 id="nested-object-searching-using-with"><a class="header" href="#nested-object-searching-using-with">Nested Object Searching using WITH</a></h2>
<p>ZomboDB automatically indexes fields of type <code>json</code> as “nested objects”.  The boolean operator <strong>WITH</strong> allows forming queries that match on individual nested objects.</p>
<p>For example, if you have a field named <code>contributor_data</code> with a few values such as:</p>
<pre><code>row #1: [ 
   { &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 42, &quot;location&quot;: &quot;TX&quot;, &quot;tags&quot;: [&quot;active&quot;] },
   { &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 36, &quot;location&quot;: &quot;TX&quot;, &quot;tags&quot;: [&quot;nice&quot;] }
]

row #2: [ 
   { &quot;name&quot;: &quot;Bob Dole&quot;, &quot;age&quot;: 92, &quot;location&quot;: &quot;KS&quot;, &quot;tags&quot;: [&quot;nice&quot;, &quot;politician&quot;] },
   { &quot;name&quot;: &quot;Elizabth Dole&quot;, &quot;age&quot;: 79, &quot;location&quot;: &quot;KS&quot;, &quot;tags&quot;: [&quot;nice&quot;] }
]

</code></pre>
<p>To find all top-level documents whose contributors are in TX and are nice:</p>
<pre><code>contributor_data.location:TX AND contributor_data.tags:nice
</code></pre>
<p>The above finds row #1 because row #1’s contributor_data structure contains elements that have a location of TX along with tags of nice.  Essentially, it found row #1 because “John Doe” matched “TX” and “Jane Doe” matched “nice”.</p>
<p>To limit the matching to only evaluate individual elements (rather than across the entire set of elements), use the <strong>WITH</strong> operator:</p>
<pre><code>contributor_data.location:TX WITH contributor_data.tags:nice
</code></pre>
<p>The above also finds row #1, but behind the scenes it only matched the “Jane Doe” subelement, because it’s the only element with a location of “TX” and a tag of “nice”.</p>
<p>The <strong>WITH</strong> operator has the same semantics as <strong>AND</strong> but requires both its left and right sides to be a nested object field reference or a parenthetical boolean expression, and all field references must be against the same nested object.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../getting-started.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../usage/elasticsearch-dsl-queries.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../getting-started.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../usage/elasticsearch-dsl-queries.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
